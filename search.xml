<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java并发编程</title>
    <url>/kygeng.github.io/2022/02/25/%E5%A4%A7%E5%8E%82%E5%AD%A6%E9%99%A2%EF%BC%9AJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105737.png" alt="image-20220104093439415"></p>
<h2 id="线程基础知识复习"><a href="#线程基础知识复习" class="headerlink" title="线程基础知识复习"></a>线程基础知识复习</h2><h3 id="多线程为什么那么重要"><a href="#多线程为什么那么重要" class="headerlink" title="多线程为什么那么重要"></a>多线程为什么那么重要</h3><p>硬件：摩尔定律失效</p>
<p>软件：异步回调的生产需求</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105738.png" alt="image-20211229093512959"></p>
<h3 id="start一个线程"><a href="#start一个线程" class="headerlink" title="start一个线程"></a>start一个线程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105739.png" alt="image-20211229094556843"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105740.png" alt="image-20211229094614030"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105741.png" alt="image-20211229094622829"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105742.png" alt="image-20211229094642045"></p>
<h3 id="Java多线程相关概念"><a href="#Java多线程相关概念" class="headerlink" title="Java多线程相关概念"></a>Java多线程相关概念</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105743.png" alt="image-20220110201647965"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112107.png" alt="image-20230226110138757"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112108.png" alt="image-20211229095753304"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112109.png" alt="image-20211229095944520"></p>
<h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><p>即便是写一个最简单的HelloWord程序，也会有两个线程：用户线程（main）和 守护线程（GC垃圾回收线程）</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105746.png" alt="image-20211229100546645"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105747.png" alt="image-20211229100603341"></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future和Callable接口"><a href="#Future和Callable接口" class="headerlink" title="Future和Callable接口"></a>Future和Callable接口</h3><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。 </p>
<p>Callable接口中定义了需要有返回的任务需要实现的方法。 比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105748.png" alt="image-20211229102351154"></p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105749.png" alt="image-20211229102512122"></p>
<p>规范：system.out.println(futureTask.get())；放在最后</p>
<p>只要出现get方法，不管是否计算完成都阻塞等待结果完成再运行后面的代码</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105750.png" alt="image-20211229102541675"></p>
<h3 id="对Future的改进"><a href="#对Future的改进" class="headerlink" title="对Future的改进"></a>对Future的改进</h3><p>CompletableFuture的优点：</p>
<p>异步任务结束时，会自动回调某个对象的方法;</p>
<p>异步任务出错时，会自动回调某个对象的方法;</p>
<p>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105751.png" alt="image-20211229104116312"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105752.png" alt="image-20211229104138986"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105753.png" alt="image-20211229104230101"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105754.png" alt="image-20211229105819346"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105755.png" alt="image-20211229105833161"></p>
<h3 id="set、get-的区别"><a href="#set、get-的区别" class="headerlink" title="set、get 的区别"></a>set、get 的区别</h3><p>set和get基本上没啥区别，join不抛出异常</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105756.png" alt="image-20211229132059728"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105757.png" alt="image-20211229140513788"></p>
<h3 id="案例：电商网站性价需求"><a href="#案例：电商网站性价需求" class="headerlink" title="案例：电商网站性价需求"></a>案例：电商网站性价需求</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105758.png" alt="image-20211229132526164"></p>
<p>记录一次你项目中的一次亮点：</p>
<p>我做过一个比价需求，这个需求是要求我们去爬别的网站的数据，针对于同一件物品，看看他们在不同的网站上售价分别是多少。爬虫的兄弟提供给了我一些JOSN格式的数据，我自己做了一个HashMap（或Redis的zest中），做完数据清洁，保证没有重复数据之后，大概是有一万条数据。</p>
<p>针对这一万条数据，最笨的方法是全文扫描，一个一个的过，但是这样虽然可以实现，但是比较慢</p>
<p>后面了解到JUC里面有个CompletableFuture，可以做异步多线程并发，而且不阻塞，用它之后，就可以把网站的性能从xxx秒优化到xxx秒，这就是我技术上一个比较值得骄傲的亮点。</p>
<p>而且CompletableFuture默认使用的 forkjoin 的线程池，我自己手写了线程池，ThreadPollExactor，具体的参数根据自己的系统来定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.juc;<br><br><span class="hljs-keyword">import</span> jdk.nashorn.internal.objects.annotations.Getter;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: GengKY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/12/29 13:29</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplateFutureNetMallDemo</span>&#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;NetMall&gt; list= Arrays.asList(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;JD&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;PDD&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;TaoBao&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;DangDang&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;TianMao&quot;</span>)<br>    );<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getPriceByStep</span><span class="hljs-params">(List&lt;NetMall&gt; list,String productName)</span>&#123;<br>        <span class="hljs-keyword">return</span> list.stream()<br>                .map(netMall -&gt; String.format(productName+<span class="hljs-string">&quot;in %s price is %.2f&quot;</span>,netMall.getMallName(),netMall.calPrice(productName)))<br>                .collect(Collectors.toList());<br>    &#125;<br><br><br>    <span class="hljs-comment">//List&lt;NetMall&gt; ----&gt;List&lt;completableFuture&lt;String&gt;&gt; ---&gt;List&lt;string&gt;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getPriceByASync</span><span class="hljs-params">(List&lt;NetMall&gt; list,String productName)</span>&#123;<br>        <span class="hljs-keyword">return</span> list.stream()<br>                .map(netMall -&gt; CompletableFuture.supplyAsync(<br>                        () -&gt; String.format(productName + <span class="hljs-string">&quot;in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calPrice(productName))))<br>                .collect(Collectors.toList())<br>                .stream().map(CompletableFuture::join)<br>                .collect(Collectors.toList());<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;1------------&quot;</span>);<br>        <span class="hljs-type">long</span> startTime=System.currentTimeMillis();<br>        List&lt;String&gt; list1 = getPriceByStep(list, <span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : list1) &#123;<br>            System.out.println(element);<br>        &#125;<br>        <span class="hljs-type">long</span> endTime=System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费时间: &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br><br><br>        System.out.println(<span class="hljs-string">&quot;2------------&quot;</span>);<br>        <span class="hljs-type">long</span> startTime2=System.currentTimeMillis();<br>        List&lt;String&gt; list2 = getPriceByASync(list, <span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : list2) &#123;<br>            System.out.println(element);<br>        &#125;<br>        <span class="hljs-type">long</span> endTime2=System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费时间: &quot;</span>+(endTime2-startTime2)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetMall</span> &#123;<br>    <span class="hljs-keyword">private</span> String mallName;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMallName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mallName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NetMall</span><span class="hljs-params">(String mallName)</span>&#123;<br>        <span class="hljs-built_in">this</span>.mallName=mallName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calPrice</span><span class="hljs-params">(String productName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ThreadLocalRandom.current().nextDouble()*<span class="hljs-number">2</span>+productName.charAt(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105759.png" alt="image-20211229140440119"></p>
<h2 id="CompletableFuture常用方法"><a href="#CompletableFuture常用方法" class="headerlink" title="CompletableFuture常用方法"></a>CompletableFuture常用方法</h2><h3 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105800.png" alt="image-20211229142938975"></p>
<h3 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105801.png" alt="image-20211229143847406"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105802.png" alt="image-20211229144356254"></p>
<h3 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105803.png" alt="image-20211229145139950"></p>
<h3 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105804.png" alt="image-20211229145624011"></p>
<h3 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105805.png" alt="image-20211229150116909"></p>
<h3 id="家庭作业"><a href="#家庭作业" class="headerlink" title="家庭作业"></a>家庭作业</h3><p>2个作业</p>
<p>1.CompletableFuture.supplyAsync0.thenCompose()</p>
<p>2.写在简历上。</p>
<p>thenCompose() 流水线</p>
<h2 id="Java中的”锁”事"><a href="#Java中的”锁”事" class="headerlink" title="Java中的”锁”事"></a>Java中的”锁”事</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105806.png" alt="image-20211229151505483"></p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105807.png" alt="image-20211229151449318"></p>
<h3 id="线程八锁-锁的是什么"><a href="#线程八锁-锁的是什么" class="headerlink" title="线程八锁/锁的是什么"></a>线程八锁/锁的是什么</h3><p>根据锁的范围划分：</p>
<p>无锁、有锁；</p>
<p>锁区块、锁方法体；</p>
<p>对象锁、类锁</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105808.png" alt="image-20211230092802062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105809.png" alt="image-20211230095354383"></p>
<p>8种锁的案例实际体现在3个地方：</p>
<p>作用于实例方法，当前实例加锁，进入向步代码前要获得当前实例的锁</p>
<p>作用于代码块，对括号里配置的对象加锁</p>
<p>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁</p>
<h3 id="从自己码角度分析sync"><a href="#从自己码角度分析sync" class="headerlink" title="从自己码角度分析sync"></a>从自己码角度分析sync</h3><h4 id="sync同步代码块"><a href="#sync同步代码块" class="headerlink" title="sync同步代码块"></a>sync同步代码块</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105810.png" alt="image-20211230101007213"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105811.png" alt="image-20211230101015239"></p>
<p><strong>锁同步代码块：对象锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    Object object=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (object)&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>锁同步代码块：类锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    Object object=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (object.getClass())&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，</p>
<p>其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="sync普通同步方法"><a href="#sync普通同步方法" class="headerlink" title="sync普通同步方法"></a>sync普通同步方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105812.png" alt="image-20211230101330077"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，</p>
<p>该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h4 id="sync锁静态同步方法"><a href="#sync锁静态同步方法" class="headerlink" title="sync锁静态同步方法"></a>sync锁静态同步方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105813.png" alt="image-20211230101355440"></p>
<h4 id="sync锁的是什么"><a href="#sync锁的是什么" class="headerlink" title="sync锁的是什么"></a>sync锁的是什么</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105814.png" alt="image-20211230103656628"></p>
<p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</p>
<p>这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。（把信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105815.png" alt="image-20211230103726913"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105816.png" alt="image-20211230103852991"></p>
<h4 id="MarkWord预热"><a href="#MarkWord预热" class="headerlink" title="MarkWord预热"></a>MarkWord预热</h4><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位，后续讲解锁升级时候我们再加深，目前为了承前启后的学习，对下图先混个眼熟即可，O(∩_∩)O</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105817.png" alt="image-20211230104002030"></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105818.png" alt="image-20211230104418491"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>)<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖出第：\t&quot;</span>+(number--)+<span class="hljs-string">&quot;\t 还剩下:&quot;</span>+number);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaleTicketDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Ticket</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ticket</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;c&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105819.png" alt="image-20211230104902630"></p>
<blockquote>
<p>为什么会有公平锁/非公平锁的设计？为什么默认非公平?</p>
</blockquote>
<p>1、恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</p>
<p>2、使用多线程很重要的考量点是线程切换的开销，<code>当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</code></p>
<blockquote>
<p>使用公平锁会有什么问题？</p>
</blockquote>
<p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，</p>
<p>这就是传说中的 “锁饥饿”</p>
<blockquote>
<p>什么时候用公平？什么时候用非公平？</p>
</blockquote>
<p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</p>
<p>否则那就用公平锁，大家公平使用。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105820.png" alt="image-20211230105307326"></p>
<h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105821.png" alt="image-20211230105621559"></p>
<blockquote>
<p>说明：</p>
</blockquote>
<p>可重入锁又名递归锁</p>
<p>是指在<code>同一个线程在外层方法获取锁的时候</code>，<code>再进入该线程的内层方法</code>会<code>自动获取锁(前提，锁对象得是同一个对象)</code>，不会因为之前已经获取过还没释放而阻塞。</p>
<p>如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了<code>作茧自缚</code>。</p>
<p>所以Java中<code>ReentrantLock和synchronized都是可重入锁</code>，可重入锁的一个优点是<code>可一定程度避免死锁</code>。</p>
<h4 id="隐式的可重入锁"><a href="#隐式的可重入锁" class="headerlink" title="隐式的可重入锁"></a>隐式的可重入锁</h4><p>指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p>
<p>与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</p>
<p><strong>同步块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                System.out.println(<span class="hljs-string">&quot;-----外层调用&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;-----中层调用&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;-----内层调用&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m1&quot;</span>);<br>        m2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m2&quot;</span>);<br>        m3();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m3&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">ReEntryLockDemo</span> <span class="hljs-variable">reEntryLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReEntryLockDemo</span>();<br>        reEntryLockDemo.m1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><p><code>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</code></p>
<p>当执行monitorenter时，如果<code>目标锁对象的计数器为零</code>，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器<code>不为零</code>的情况下，如果锁对象的<code>持有线程是当前线程</code>，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当<code>执行monitorexit时</code>，Java虚拟机则需将锁对象的<code>计数器减1</code>。计数器为零代表锁已被释放。</p>
<h4 id="显式的可重入锁"><a href="#显式的可重入锁" class="headerlink" title="显式的可重入锁"></a>显式的可重入锁</h4><p>加锁、解锁次数不一样的话，自己玩没事</p>
<p>多个线程一起的话，会卡住别人的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<span class="hljs-comment">//1、第一次lock</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;----外层调用lock&quot;</span>);<br>                lock.lock();<span class="hljs-comment">//2、第二次lock</span><br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;----内层调用lock&quot;</span>);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//lock.unlock(); // 正常情况，加锁几次就要解锁几次</span><br>                    <span class="hljs-comment">//正常运行，不会卡住</span><br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<span class="hljs-comment">//1、第一次lock</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;----外层调用lock&quot;</span>);<br>                lock.lock();<span class="hljs-comment">//2、第二次lock</span><br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;----内层调用lock&quot;</span>);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 这里故意注释，实现加锁次数和释放次数不一样</span><br>                    <span class="hljs-comment">// 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</span><br>                    <span class="hljs-comment">//lock.unlock(); // 正常情况，加锁几次就要解锁几次</span><br>                    <span class="hljs-comment">//第二个线程会卡住</span><br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;b thread----外层调用lock&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105822.png" alt="image-20211230132114628"></p>
<p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105823.png" alt="image-20211230132142765" style="zoom:67%;" />

<blockquote>
<p>手写一个死锁案例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;自己持有A，希望获得B&quot;</span>);<br>                <span class="hljs-comment">//暂停几秒钟线程</span><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                <span class="hljs-keyword">synchronized</span> (objectLockB)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;A-------已经获得B&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockB)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;自己持有B，希望获得A&quot;</span>);<br>                <span class="hljs-comment">//暂停几秒钟线程</span><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;B-------已经获得A&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>怎么证明是死锁</p>
</blockquote>
<p>使用 jconsole 命令调出控制台</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105824.png" alt="image-20211230132652869"></p>
<p>使用 <code>jps -l</code> <code>jstack 线程ID</code> </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105825.png" alt="image-20211230133025403"></p>
<h3 id="其他的一些锁"><a href="#其他的一些锁" class="headerlink" title="其他的一些锁"></a>其他的一些锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105826.png" alt="image-20211230132454587"></p>
<h2 id="线程中断机制"><a href="#线程中断机制" class="headerlink" title="线程中断机制"></a>线程中断机制</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105827.png" alt="image-20211013191213603"></p>
<h3 id="面试题反馈"><a href="#面试题反馈" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105828.png" alt="image-20211013191240788"></p>
<h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105829.png" alt="image-20211013191303026"></p>
<h3 id="中断的相关API的方法"><a href="#中断的相关API的方法" class="headerlink" title="中断的相关API的方法"></a>中断的相关API的方法</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105830.png" alt="image-20211013191332009"></p>
<h3 id="如何使用中断标志停止线程"><a href="#如何使用中断标志停止线程" class="headerlink" title="如何使用中断标志停止线程"></a>如何使用中断标志停止线程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105831.png" alt="image-20211013191407893"></p>
<h4 id="通过一个volatile变量实现"><a href="#通过一个volatile变量实现" class="headerlink" title="通过一个volatile变量实现"></a>通过一个volatile变量实现</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105832.png" alt="image-20211013191601256"></p>
<h4 id="通过AtomicBoolean"><a href="#通过AtomicBoolean" class="headerlink" title="通过AtomicBoolean"></a>通过AtomicBoolean</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105833.png" alt="image-20211013191614201"></p>
<h4 id="通过Thread类自带的中断api方法实现"><a href="#通过Thread类自带的中断api方法实现" class="headerlink" title="通过Thread类自带的中断api方法实现"></a>通过Thread类自带的中断api方法实现</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105834.png" alt="image-20211013191624282"></p>
<h3 id="interrupt源码分析"><a href="#interrupt源码分析" class="headerlink" title="interrupt源码分析"></a>interrupt源码分析</h3><p>如果一个<code>被阻塞的线程（wait()、join()、sleep()）</code>是 中断的话，将会<code>清除中断标志位（重新设置为false）</code>，并抛出<code> InterruptedException 异常</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105835.png" alt="image-20211013191700509"></p>
<h3 id="isInterrupted源码分析"><a href="#isInterrupted源码分析" class="headerlink" title="isInterrupted源码分析"></a>isInterrupted源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105836.png" alt="image-20211013192015150"></p>
<h3 id="Interrupt是否是立刻停止"><a href="#Interrupt是否是立刻停止" class="headerlink" title="Interrupt是否是立刻停止"></a>Interrupt是否是立刻停止</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105837.png" alt="image-20211013192148680"></p>
<blockquote>
<p> <strong>以下代码说明，当对一个线程调用Interrupt时，并不会立刻停止</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105838.png" alt="image-20211013192253768"></p>
<h3 id="后手案例"><a href="#后手案例" class="headerlink" title="后手案例"></a>后手案例</h3><h4 id="后手案例-1"><a href="#后手案例-1" class="headerlink" title="后手案例-1"></a>后手案例-1</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105839.png" alt="image-20211013192534951"></p>
<p>执行结果：</p>
<p>程序正常执行，在3秒内持续打印 hello interrupt ，3秒后，打印“***程序结束”</p>
<h4 id="后手案例-2"><a href="#后手案例-2" class="headerlink" title="后手案例-2"></a>后手案例-2</h4><p>相较于“后手案例-1”，在 while 循环内 执行休眠操作，并用 try-catch 捕获异常</p>
<p>猜测：打印六次 “hello interrupt”，打印 “***程序结束”</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105840.png" alt="image-20211013192818500"></p>
<p>运行结果：</p>
<p>报异常，程序无法停止</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105841.png" alt="image-20211013193025661"></p>
<p>出现问题的原因：</p>
<p>线程t1在休眠时，线程t2设置 t1.interrupt，导致报异常</p>
<p>报异常之后，interrupt 状态重新设置为 false ，无法停止</p>
<p>解决方案：</p>
<p>在 try-catch 中在设置一次 interrupt</p>
<h4 id="后手案例-3"><a href="#后手案例-3" class="headerlink" title="后手案例-3"></a>后手案例-3</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105842.png" alt="image-20211013193334717"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105843.png" alt="image-20211013193431140"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105844.png" alt="image-20211013193522118"></p>
<h3 id="静态方法-Thread-interrupted"><a href="#静态方法-Thread-interrupted" class="headerlink" title="静态方法 Thread.interrupted"></a>静态方法 Thread.interrupted</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105845.png" alt="image-20211013193627535"></p>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105846.png" alt="image-20211013193730285"></p>
<h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105847.png" alt="image-20211013193752806"></p>
<h3 id="Interrupted对比IsInterrupted"><a href="#Interrupted对比IsInterrupted" class="headerlink" title="Interrupted对比IsInterrupted"></a>Interrupted对比IsInterrupted</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105848.png" alt="image-20211013193928979"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105849.png" alt="image-20211013193839447"></p>
<h3 id="线程中断总结"><a href="#线程中断总结" class="headerlink" title="线程中断总结"></a>线程中断总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105850.png" alt="image-20211230133342947"></p>
<h2 id="加餐-要了解系统架构设计"><a href="#加餐-要了解系统架构设计" class="headerlink" title="加餐 | 要了解系统架构设计"></a>加餐 | 要了解系统架构设计</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105851.png" alt="image-20211230142150574"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105852.png" alt="image-20211230142304514"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105853.png" alt="image-20211230142208060"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105854.png" alt="image-20211230142350887"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105855.png" alt="image-20211230142425741"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105856.png" alt="image-20211230142443498"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105857.png" alt="image-20211230142508215"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105858.png" alt="image-20211230142536251"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105859.png" alt="image-20211230142733549"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105900.png" alt="image-20211230142947844"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105901.png" alt="image-20211230143055295"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105902.png" alt="image-20211230143257157"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105903.png" alt="image-20211230143309414"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112110.png" alt="image-20211230143323220"></p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h3 id="什么是LockSupport"><a href="#什么是LockSupport" class="headerlink" title="什么是LockSupport"></a>什么是LockSupport</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html">LockSupport Java doc</a></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105904.png" alt="image-20211230143545419"></p>
<p>LockSupport是<code>用来创建锁</code>和<code>其他同步类</code>的<code>基本线程阻塞原语</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105905.png" alt="img"></p>
<h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p><strong>一句话说明LockSupport：</strong></p>
<p><strong>LockSupport就是线程等待和唤醒机制(wait/notify)的加强改良版</strong></p>
<p>LockSupport中的 <code>park()</code>和 <code>unpark()</code>的作用分别是<code>阻塞线程</code>和<code>解除阻塞线程</code>。</p>
<p>总之，比wait/notify，await/signal更强。</p>
<p><strong>3种让线程等待和唤醒的方法</strong></p>
<ul>
<li><p>方式1：使用Object中的wait()方法让线程等待，使用object中的notify()方法唤醒线程</p>
</li>
<li><p>方式2：使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p>
</li>
<li><p>方式3：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</p>
</li>
</ul>
<h3 id="两个重要方法"><a href="#两个重要方法" class="headerlink" title="两个重要方法"></a>两个重要方法</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105906.png" alt="image-20211230144502241"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105907.png" alt="image-20211230144516060"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112111.png" alt="image-20211230144736533"></p>
<h2 id="线程等待唤醒机制"><a href="#线程等待唤醒机制" class="headerlink" title="线程等待唤醒机制"></a>线程等待唤醒机制</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105908.png" alt="image-20211230143644770"></p>
<h3 id="Wait和Notify限制"><a href="#Wait和Notify限制" class="headerlink" title="Wait和Notify限制"></a>Wait和Notify限制</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105909.png" alt="image-20211230144401777"></p>
<p>Object类中的wait和notify方法实现线程等待和唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br><br>	<span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				<span class="hljs-keyword">try</span> &#123;<br>					lock.wait();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br>		<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				lock.notify();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>wait和notify方法<code>必须要在同步块或者方法里面</code>且<code>成对出现使用</code>，否则会抛出java.lang.IllegalMonitorStateException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.notify();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Exception in thread &quot;Thread B&quot; java.lang.IllegalMonitorStateException<br>	at java.base/java.lang.Object.notify(Native Method)<br>	at com.example.demo07.main.WaitNotifyDemo.lambda<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.467ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 2354 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">main</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-61" x="878" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1408" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6E" x="1753" y="0"></use>
</g>
</svg>1(WaitNotifyDemo.java:19)<br>	at java.base/java.lang.Thread.run(Thread.java:829)<br>Thread A come in.<br>Thread A 换醒.<br>java.lang.IllegalMonitorStateException<br>	at java.base/java.lang.Object.wait(Native Method)<br>	at java.base/java.lang.Object.wait(Object.java:328)<br>	at com.example.demo07.main.WaitNotifyDemo.lambda<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.467ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 2354 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">main</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-61" x="878" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1408" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6E" x="1753" y="0"></use>
</g>
</svg>0(WaitNotifyDemo.java:11)<br>	at java.base/java.lang.Thread.run(Thread.java:829)<br></code></pre></td></tr></table></figure>



<p>调用顺序要<code>先wait后notify</code>才OK。</p>
<p>先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				<span class="hljs-keyword">try</span> &#123;<br>					lock.wait();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br><br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				lock.notify();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread B 通知.<br>Thread A come in.<br>.......无限等待......<br></code></pre></td></tr></table></figure>



<h3 id="Await和Signal限制"><a href="#Await和Signal限制" class="headerlink" title="Await和Signal限制"></a>Await和Signal限制</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105910.png" alt="image-20211230144419994"></p>
<p>Condition接口中的await后signal方法实现线程的等待和唤醒，与Object类中的wait和notify方法实现线程等待和唤醒类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionAwaitSignalDemo</span> &#123;		<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;	<br>		<span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>		<span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;	<br>			<span class="hljs-keyword">try</span> &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				lock.lock();<br>				condition.await();				<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125; <span class="hljs-keyword">finally</span> &#123;<br>				lock.unlock();<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;,<span class="hljs-string">&quot;Thread A&quot;</span>).start();<br>		<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				lock.lock();<br>				condition.signal();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<span class="hljs-keyword">finally</span> &#123;<br>				lock.unlock();<br>			&#125;<br>		&#125;,<span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread A come in.<br>Thread B 通知.<br>Thread A 换醒.<br></code></pre></td></tr></table></figure>

<p>await和signal方法<code>必须要在同步块或者方法里面</code>且成对出现使用，否则会抛出 java.lang.IllegalMonitorStateException。</p>
<p>调用顺序要<code>先await后signal</code>才OK。</p>
<h3 id="LockSupport方法介绍"><a href="#LockSupport方法介绍" class="headerlink" title="LockSupport方法介绍"></a>LockSupport方法介绍</h3><p>API中的LockSupport方法摘要</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105911.png" alt="img"></p>
<p><strong>传统的 synchronized 和 Lock 实现等待唤醒通知的约束</strong></p>
<ul>
<li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li>
<li>必须要先等待后唤醒，线程才能够被唤醒</li>
</ul>
<p>LockSupport类中的park等待和unpark唤醒</p>
<p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>
<p>This class associates, with each thread that uses it, a permit (in the sense of the <code>Semaphore</code> class). A call to <code>park</code> will return immediately if the permit is available, consuming it in the process; otherwise it <em>may</em> block. A call to <code>unpark</code> makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.) <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html">link</a></p>
<p><strong>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</strong></p>
<p>LockSupport类使用了一种名为<strong>Permit（许可）的概念</strong>来做到阻塞和唤醒线程的功能，每个线程都有一个许可（permit），permit只有两个值1和零，默认是零。</p>
<p>可以把许可看成是一种(0.1)信号量（Semaphore），但与Semaphore不同的是，<strong>许可的累加上限是1。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105912.png" alt="image-20211230145212290"></p>
<p><strong>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</strong></p>
<p>park()/park(Object blocker) - 阻塞当前线程阻塞传入的具体线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>



<p>permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为0并返回。</p>
<p>unpark(Thread thread) - 唤醒处于阻塞状态的指定线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1（注意多次调用unpark方法，不会累加，pemit值还是1）会自动唤醒thead线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p>
<h3 id="LockSupport案例解析"><a href="#LockSupport案例解析" class="headerlink" title="LockSupport案例解析"></a>LockSupport案例解析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105913.png" alt="img"></p>
<blockquote>
<p><strong>正常使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread A come in.<br>Thread B 通知.<br>Thread A 换醒.<br></code></pre></td></tr></table></figure>

<p>正常 + 无锁块要求。</p>
<p>先前错误的先唤醒后等待顺序，LockSupport可无视这顺序。</p>
<blockquote>
<p>【支持】先执行释放锁的操作unpark，后加锁</p>
</blockquote>
<p><strong>为什么可以先唤醒线程后阻塞线程？</strong></p>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【支持】unpack多次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            LockSupport.unpark(a);<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【不支持】pack多次，导致无限等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【支持】多个通行证，由不同的线程提供</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.juc;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//park多次</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            LockSupport.park();<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 唤醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        thread1.start();<br><br>        <span class="hljs-comment">//线程B unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br><br>        <span class="hljs-comment">//线程C unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread C&quot;</span>).start();<br><br>        <span class="hljs-comment">//线程D unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p><strong>重点说明</strong></p>
</blockquote>
<p>LockSupport是用来创建锁和共他同步类的基本线程阻塞原语。</p>
<p>LockSuport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻寨之后也有对应的唤醒方法。归根结底，LockSupport调用的Unsafe中的native代码。</p>
<p><strong>LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</strong></p>
<p>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0，</p>
<p>调用一次unpark就加1变成1，</p>
<p>调用一次park会消费permit，也就是将1变成0，同时park立即返回。</p>
<p>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，<strong>重复调用unpark也不会积累凭证</strong>。</p>
<blockquote>
<p><strong>形象的理解</strong></p>
</blockquote>
<p>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</p>
<p>当调用park方法时</p>
<ul>
<li>如果有凭证，则会直接消耗掉这个凭证然后正常退出。</li>
<li>如果无凭证，就必须阻塞等待凭证可用。</li>
</ul>
<p>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无放。</p>
<blockquote>
<p><strong>面试题</strong></p>
</blockquote>
<p><strong>1、为什么可以先唤醒线程后阻塞线程？</strong></p>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p>
<p><strong>2、为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></p>
<p>因为凭证的数量最多为1（不能累加），连续调用两次 unpark和调用一次 unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。</p>
<h2 id="Java内存模型值JMM"><a href="#Java内存模型值JMM" class="headerlink" title="Java内存模型值JMM"></a>Java内存模型值JMM</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105914.png" alt="image-20211013201143830"></p>
<h3 id="面试题反馈-1"><a href="#面试题反馈-1" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105915.png" alt="image-20211013201216815"></p>
<h3 id="计算机硬件体系结构"><a href="#计算机硬件体系结构" class="headerlink" title="计算机硬件体系结构"></a>计算机硬件体系结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105916.png" alt="image-20211013201253977"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105917.png" alt="image-20211013201336229"></p>
<h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105918.png" alt="image-20211013201355896"></p>
<h3 id="JVM规范下三大特性"><a href="#JVM规范下三大特性" class="headerlink" title="JVM规范下三大特性"></a>JVM规范下三大特性</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105919.png" alt="image-20211013201444642"></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105920.png" alt="image-20211013201509370"></p>
<h3 id="多线程遍历的读取过程"><a href="#多线程遍历的读取过程" class="headerlink" title="多线程遍历的读取过程"></a>多线程遍历的读取过程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105921.png" alt="image-20211013201630782"></p>
<h4 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112112.png" alt="image-20211013201716933"></p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>我们定义的所有共享变量都储存在<strong>物理主内存</strong>中</p>
<p>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)</p>
<p>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)</p>
<p>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</p>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112113.png" alt="image-20211014091919624"></p>
<h3 id="x、y案例说明"><a href="#x、y案例说明" class="headerlink" title="x、y案例说明"></a>x、y案例说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112114.png" alt="image-20211014091939167"></p>
<h3 id="先行发生原则说明"><a href="#先行发生原则说明" class="headerlink" title="先行发生原则说明"></a>先行发生原则说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112115.png" alt="image-20211014092045774"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112116.png" alt="image-20211014092014938"></p>
<h3 id="happens-before八条规则"><a href="#happens-before八条规则" class="headerlink" title="happens-before八条规则"></a>happens-before八条规则</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112117.png" alt="image-20211014092112713"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112118.png" alt="image-20211014092138339"></p>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112119.png" alt="image-20211014092202674"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112120.png" alt="image-20211014092213335"></p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112121.png" alt="image-20211014100358040"></p>
<h3 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112122.png" alt="image-20211014100434379"></p>
<h3 id="什么是内存屏障"><a href="#什么是内存屏障" class="headerlink" title="什么是内存屏障"></a>什么是内存屏障</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112123.png" alt="image-20211014100538275"></p>
<p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是<code>一类同步屏障指令</code>，是CPU或编译器在<code>对内存随机访问的操作中</code>的一个同步点，使得<code>此点之前的所有读写操作</code>都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会<code>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</code>，通过这些内存屏障指令，volatle实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p>
<p>内存屏障之前的所有<code>写操作都要回写到主内存</code>，</p>
<p>内存屏障之后的所有<code>读操作</code>都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112124.png" alt="image-20211014100605653"></p>
<h3 id="四类内存屏障源码分析"><a href="#四类内存屏障源码分析" class="headerlink" title="四类内存屏障源码分析"></a>四类内存屏障源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112125.png" alt="image-20211014100713279"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112126.png" alt="image-20211014100749867"></p>
<h3 id="四大屏障分别是什么意思"><a href="#四大屏障分别是什么意思" class="headerlink" title="四大屏障分别是什么意思"></a>四大屏障分别是什么意思</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112127.png" alt="image-20211014100842497"></p>
<h3 id="内存屏障插入策略"><a href="#内存屏障插入策略" class="headerlink" title="内存屏障插入策略"></a>内存屏障插入策略</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112128.png" alt="image-20211014103438016"></p>
<h4 id="happens-before之volatile变量规则"><a href="#happens-before之volatile变量规则" class="headerlink" title="happens-before之volatile变量规则"></a>happens-before之volatile变量规则</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112129.png" alt="image-20211014103546032"></p>
<h4 id="写总结"><a href="#写总结" class="headerlink" title="写总结"></a>写总结</h4><p>1、在每个volatile 写操作的前面插入一个StoreStore屏障</p>
<p>2、在每个volatile 写操作的后面插入一个StoreLoad屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112130.png" alt="image-20211014103911526"></p>
<h4 id="读总结"><a href="#读总结" class="headerlink" title="读总结"></a>读总结</h4><p>3、在每个volatile读操作的后面插入一个LoadLoad屏障</p>
<p>4、在每个volatile读操作的后面插入一个LoadStore屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112131.png" alt="image-20211014104016981"></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><h4 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h4><p>不加volatile，没有可见性，程序无法停止</p>
<p>加了volatile，保证可见性，程序可以停止</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112132.png" alt="image-20211014113253889"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112133.png" alt="image-20211014113323752"></p>
<h4 id="volatile变量的读写过程"><a href="#volatile变量的读写过程" class="headerlink" title="volatile变量的读写过程"></a>volatile变量的读写过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112134.png" alt="image-20211014113351616"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112135.png" alt="image-20211227140218862"></p>
<ul>
<li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li>
<li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li>
<li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li>
<li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li>
<li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li>
<li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
<li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
</ul>
<h3 id="没有原子性"><a href="#没有原子性" class="headerlink" title="没有原子性"></a>没有原子性</h3><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><p>输出结果：基本都会小于10000，有可能会出现一次10000</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112136.png" alt="image-20211014113441542"></p>
<h4 id="字节码角度说明"><a href="#字节码角度说明" class="headerlink" title="字节码角度说明"></a>字节码角度说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112137.png" alt="image-20211014113542084"></p>
<h4 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112138.png" alt="image-20211014113625778"></p>
<h4 id="读取一个普通变量的情况"><a href="#读取一个普通变量的情况" class="headerlink" title="读取一个普通变量的情况"></a>读取一个普通变量的情况</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112139.png" alt="image-20211014113645474"></p>
<h4 id="volatile对指令的处理"><a href="#volatile对指令的处理" class="headerlink" title="volatile对指令的处理"></a>volatile对指令的处理</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112140.png" alt="image-20211014113730998"></p>
<h4 id="读取赋值一个volatile变量的情况"><a href="#读取赋值一个volatile变量的情况" class="headerlink" title="读取赋值一个volatile变量的情况"></a>读取赋值一个volatile变量的情况</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112141.png" alt="image-20211014113753742"></p>
<h4 id="间隙期不同非原子操作"><a href="#间隙期不同非原子操作" class="headerlink" title="间隙期不同非原子操作"></a>间隙期不同非原子操作</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112142.png" alt="image-20211014113836241"></p>
<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112143.png" alt="image-20211014115835644"></p>
<h4 id="说明与案例"><a href="#说明与案例" class="headerlink" title="说明与案例"></a>说明与案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112144.png" alt="image-20211014115920913"></p>
<h3 id="内存屏障二次复习"><a href="#内存屏障二次复习" class="headerlink" title="内存屏障二次复习"></a>内存屏障二次复习</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112145.png" alt="image-20211014120000331"></p>
<h4 id="volatile有关的禁止指令重排的行为"><a href="#volatile有关的禁止指令重排的行为" class="headerlink" title="volatile有关的禁止指令重排的行为"></a>volatile有关的禁止指令重排的行为</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112146.png" alt="image-20211014120341715"></p>
<h4 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112147.png" alt="image-20211014120008815"></p>
<h2 id="正确使用volatile"><a href="#正确使用volatile" class="headerlink" title="正确使用volatile"></a>正确使用volatile</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112148.png" alt="image-20211014171532003"></p>
<h3 id="使用案例：状态标志"><a href="#使用案例：状态标志" class="headerlink" title="使用案例：状态标志"></a>使用案例：状态标志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112149.png" alt="image-20211014171643098"></p>
<h3 id="使用案例：读多写少"><a href="#使用案例：读多写少" class="headerlink" title="使用案例：读多写少"></a>使用案例：读多写少</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112150.png" alt="image-20211014171658438"></p>
<h3 id="使用案例：双端检索"><a href="#使用案例：双端检索" class="headerlink" title="使用案例：双端检索"></a>使用案例：双端检索</h3><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112151.png" alt="image-20211014171843474"></p>
<h4 id="单线程、多线程下看问题代码"><a href="#单线程、多线程下看问题代码" class="headerlink" title="单线程、多线程下看问题代码"></a>单线程、多线程下看问题代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112152.png" alt="image-20211014171811111"></p>
<h4 id="双端检索正确代码"><a href="#双端检索正确代码" class="headerlink" title="双端检索正确代码"></a>双端检索正确代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112153.png" alt="image-20211014171915535"></p>
<h4 id="静态内部类实现单例模式"><a href="#静态内部类实现单例模式" class="headerlink" title="静态内部类实现单例模式"></a>静态内部类实现单例模式</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112154.png" alt="image-20211014171936749"></p>
<h2 id="volatile总结"><a href="#volatile总结" class="headerlink" title="volatile总结"></a>volatile总结</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112155.png" alt="image-20211014172038912"></p>
<h3 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h3><p>内存屏障：</p>
<p>是一种 <code>屏障指令</code>，它使得 <code>CPU或编译器</code> 对 <code>屏障指令的前和后</code> 所发出的内存操作 <code>执行一个排序的约束</code>。也叫内存栅栏或栅栏指令</p>
<h3 id="内存屏障四大指令"><a href="#内存屏障四大指令" class="headerlink" title="内存屏障四大指令"></a>内存屏障四大指令</h3><p>在每一个volatile写操作前面插入一个StoreStore屏障</p>
<p>在每一个volatile写操作后面插入一个StoreLoad屏障</p>
<p>在每一个volatile读操作后面插入一个LoadLoad屏障</p>
<p>在每一个volatile读操作后面插入一个LoadStore屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112156.png" alt="image-20211014172234151"></p>
<h3 id="volatile关键字系统底层"><a href="#volatile关键字系统底层" class="headerlink" title="volatile关键字系统底层"></a>volatile关键字系统底层</h3><p><strong>字节码层面</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112157.png" alt="image-20211014172438336"></p>
<p><strong>关键字</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112158.png" alt="image-20211014172448001"></p>
<h3 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112159.png" alt="image-20211014172519245"></p>
<h3 id="volatile禁重排"><a href="#volatile禁重排" class="headerlink" title="volatile禁重排"></a>volatile禁重排</h3><h4 id="写指令"><a href="#写指令" class="headerlink" title="写指令"></a>写指令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112200.png" alt="image-20211014172658140"></p>
<h4 id="读指令"><a href="#读指令" class="headerlink" title="读指令"></a>读指令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112201.png" alt="image-20211014172640353"></p>
<h3 id="对比Lock理解"><a href="#对比Lock理解" class="headerlink" title="对比Lock理解"></a>对比Lock理解</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112202.png" alt="image-20211014172721233"></p>
<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112203.png" alt="image-20211014172800415"></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112204.png" alt="image-20211015095341266"></p>
<h3 id="没有CSA之前"><a href="#没有CSA之前" class="headerlink" title="没有CSA之前"></a>没有CSA之前</h3><h4 id="多线程环境下保证线程安全"><a href="#多线程环境下保证线程安全" class="headerlink" title="多线程环境下保证线程安全"></a>多线程环境下保证线程安全</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112205.png" alt="image-20211015095423890"></p>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112206.png" alt="image-20211015095547076"></p>
<h4 id="说明和原理"><a href="#说明和原理" class="headerlink" title="说明和原理"></a>说明和原理</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112207.png" alt="image-20211015095531099"></p>
<h4 id="硬件级别的保证"><a href="#硬件级别的保证" class="headerlink" title="硬件级别的保证"></a>硬件级别的保证</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112208.png" alt="image-20211015095642550"></p>
<h4 id="CASDemo代码"><a href="#CASDemo代码" class="headerlink" title="CASDemo代码"></a>CASDemo代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112209.png" alt="image-20211015095657387"></p>
<h4 id="compareAndSet源码"><a href="#compareAndSet源码" class="headerlink" title="compareAndSet源码"></a>compareAndSet源码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112210.png" alt="image-20211015095730933"></p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112211.png" alt="image-20211015103607277"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112212.png" alt="image-20211015103622849"></p>
<h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><h4 id="手写自旋锁-1"><a href="#手写自旋锁-1" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112213.png" alt="image-20211015103708544"></p>
<h4 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112214.png" alt="image-20211015103727183"></p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112215.png" alt="image-20211015103814690"></p>
<h4 id="CAS的缺点：CPU空转"><a href="#CAS的缺点：CPU空转" class="headerlink" title="CAS的缺点：CPU空转"></a>CAS的缺点：CPU空转</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112216.png" alt="image-20211015103851075"></p>
<h4 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112217.png" alt="image-20211015103919880"></p>
<h4 id="代码：存在ABA问题"><a href="#代码：存在ABA问题" class="headerlink" title="代码：存在ABA问题"></a>代码：存在ABA问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112218.png" alt="image-20211015103947131"></p>
<h4 id="代码：解决ABA问题"><a href="#代码：解决ABA问题" class="headerlink" title="代码：解决ABA问题"></a>代码：解决ABA问题</h4><p>带邮戳的原子引用：AtomicStampedReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">atomicStampedReference.compareAndSet(x,y,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>





<p>使用：</p>
<p><strong>Class AtomicstampedReference&lt;V&gt;</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112219.png" alt="image-20211015104032870"></p>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>红色和黑色的有什么区别？</p>
<p>为什么要用 LongAdder 替代 AtomicLong？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112220.png" alt="image-20211231093302659"></p>
<h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>countDownLatch 你用在哪里？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112221.png" alt="image-20211231093514011"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span>&#123;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPlusPlus</span><span class="hljs-params">()</span>&#123;<br>        atomicInteger.incrementAndGet();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <br>        <span class="hljs-type">MyNumber</span> <span class="hljs-variable">myNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyNumber</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">5000</span>; j++)&#123;<br>                        myNumber.addPlusPlus();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        countDownLatch.await();<span class="hljs-comment">//不加此行代码的话，由于main线程太快，main结束时，atomicInteger.incrementAndGet()还没算到 500000</span><br>        System.out.println(myNumber.getAtomicInteger().get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112222.png" alt="image-20211231094211978"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <br>        <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span><br>        <span class="hljs-comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;atomicIntegerArray.length(); i++) &#123;<br>            System.out.println(atomicIntegerArray.get(i));<br>        &#125;<br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmpInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        tmpInt = atomicIntegerArray.getAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">1122</span>);<br>        System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">0</span>));<br>        atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        tmpInt = atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112223.png" alt="image-20211231094659460"></p>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    String userName;<br>    <span class="hljs-type">int</span>    age;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>,<span class="hljs-number">24</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">li4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;li4&quot;</span>,<span class="hljs-number">26</span>);<br><br>        AtomicReference&lt;User&gt; atomicReferenceUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>        atomicReferenceUser.set(z3);<br>        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());<br>        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>手写自旋锁</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.Interview.study.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2018-12-28 17:57</span><br><span class="hljs-comment"> * 题目：实现一个自旋锁</span><br><span class="hljs-comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span><br><span class="hljs-comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span>&#123;<br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myLock</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t come in&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-literal">null</span>,thread))&#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myUnLock</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread,<span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t myUnLock over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            <span class="hljs-comment">//暂停一会儿线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">5</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">1</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><blockquote>
<p>解决ABA问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicStampedReference</span> <span class="hljs-variable">atomicStampedReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        abaProblem();<br>        abaResolve();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaResolve</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第1次stamp  &quot;</span>+stamp);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,stamp,stamp+<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第2次stamp  &quot;</span>+atomicStampedReference.getStamp());<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第3次stamp  &quot;</span>+atomicStampedReference.getStamp());<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;t4 ----第1次stamp  &quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">20210308</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+result+<span class="hljs-string">&quot;\t&quot;</span>+atomicStampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaProblem</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">20210308</span>);<br>            System.out.println(atomicInteger.get());<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><blockquote>
<p>不建议用来解决ABA问题</p>
<p>用来解决一次性问题，不适合重复使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.juc.senior.inner.atomic;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-23 10:56</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;update ok&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">2020</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(atomicInteger.get());<br><br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br><br>        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决,让我们知道引用变量中途被更改了几次=========================&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+stampedReference.getStamp());<br>            <span class="hljs-comment">//故意暂停200毫秒，让后面的t4线程拿到和t3一样的版本号</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>            stampedReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 2次版本号&quot;</span>+stampedReference.getStamp());<br>            stampedReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 3次版本号&quot;</span>+stampedReference.getStamp());<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t =======1次版本号&quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停2秒钟,让t3先完成ABA操作了，看看自己还能否修改</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2020</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t=======2次版本号&quot;</span>+stampedReference.getStamp()+<span class="hljs-string">&quot;\t&quot;</span>+stampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start();<br><br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br><br>        System.out.println(<span class="hljs-string">&quot;============AtomicMarkableReference不关心引用变量更改过几次，只关心是否更改过======================&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+marked);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,marked,!marked);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 2次版本号&quot;</span>+markableReference.isMarked());<br>            markableReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,markableReference.isMarked(),!markableReference.isMarked());<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 3次版本号&quot;</span>+markableReference.isMarked());<br>        &#125;,<span class="hljs-string">&quot;t5&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+marked);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">2020</span>,marked,!marked);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+markableReference.getReference()+<span class="hljs-string">&quot;\t&quot;</span>+markableReference.isMarked());<br>        &#125;,<span class="hljs-string">&quot;t6&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象的属性修改原子类"><a href="#对象的属性修改原子类" class="headerlink" title="对象的属性修改原子类"></a>对象的属性修改原子类</h3><p><font color=red><strong>以一种线程安全的方式操作非线程安全对象内的某些字段</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112224.png" alt="image-20211231100712901"></p>
<blockquote>
<p><strong>AtomicIntegerFieldUpdater</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bankName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CCB&quot;</span>;<span class="hljs-comment">//银行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//钱数</span><br>    AtomicIntegerFieldUpdater&lt;BankAccount&gt; accountAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="hljs-string">&quot;money&quot;</span>);<br><br>    <span class="hljs-comment">//不加锁+性能高，局部微创</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferMoney</span><span class="hljs-params">(BankAccount bankAccount)</span>&#123;<br>        accountAtomicIntegerFieldUpdater.incrementAndGet(bankAccount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-07-14 18:06</span><br><span class="hljs-comment"> * 以一种线程安全的方式操作非线程安全对象的某些字段。</span><br><span class="hljs-comment"> * 需求：</span><br><span class="hljs-comment"> * 1000个人同时向一个账号转账一元钱，那么累计应该增加1000元，</span><br><span class="hljs-comment"> * 除了synchronized和CAS,还可以使用AtomicIntegerFieldUpdater来实现。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <br>        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                bankAccount.transferMoney(bankAccount);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">//暂停毫秒</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(bankAccount.money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>AtomicReferenceField</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVar</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; atomicReferenceFieldUpdater = 	AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="hljs-string">&quot;isInit&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(MyVar myVar)</span>&#123;<br>        <span class="hljs-keyword">if</span>(atomicReferenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---init.....&quot;</span>);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---init.....over&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;------其它线程正在初始化&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-18 17:20</span><br><span class="hljs-comment"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">MyVar</span> <span class="hljs-variable">myVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVar</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myVar.init(myVar);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原子操作增强类原理深度解析"><a href="#原子操作增强类原理深度解析" class="headerlink" title="原子操作增强类原理深度解析"></a>原子操作增强类原理深度解析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112225.png" alt="image-20211231105318134"></p>
<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote>
<p><strong>阿里要命题目</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112226.png" alt="image-20211231105432864"></p>
<blockquote>
<p><strong>常用API</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112227.png" alt="image-20211231105955468"></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>LongAccumulator提供了自定义的函数操作</p>
</blockquote>
<p>long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAccumulatorDemo</span><br>&#123;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_LongAdder</span><span class="hljs-params">()</span><br>    &#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongBinaryOperator</span>()<br>    &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">applyAsLong</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> left - right;<br>        &#125;<br>    &#125;,<span class="hljs-number">777</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_LongAccumulator</span><span class="hljs-params">()</span><br>    &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">LongAccumulatorDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulatorDemo</span>();<br><br>        demo.add_LongAccumulator();<br>        demo.add_LongAccumulator();<br>        System.out.println(demo.longAccumulator.longValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>LongAdderAPIDemo</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">package</span> com.atguigu.juc.atomics;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAccumulator;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-19 15:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderAPIDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br><br>        longAdder.increment();<br>        longAdder.increment();<br>        longAdder.increment();<br><br>        System.out.println(longAdder.longValue());<br><br>        <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x,y) -&gt; x * y,<span class="hljs-number">2</span>);<br><br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">2</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">3</span>);<br><br>        System.out.println(longAccumulator.longValue());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p><strong>1、定义五个方法</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112228.png" alt="image-20211231110759464"></p>
<p><strong>2、定义测试方法</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112229.png" alt="image-20211231110930670"></p>
<p><strong>3、测试结果</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">D: \devsoft\Javaljdk<span class="hljs-number">1.8.0_111</span>\binljava.exe<br>----costTime: <span class="hljs-number">1555</span>毫秒    add_synchronized    <span class="hljs-number">50000000</span><br>---costTime:  <span class="hljs-number">1010</span> 毫秘   add_AtomicInteger   <span class="hljs-number">50000000</span><br>----costTime: <span class="hljs-number">1056</span> 毫秒   add_AtomicLong      <span class="hljs-number">50000000</span><br>----costTime: <span class="hljs-number">162</span>毫秒     add_LongAdder       <span class="hljs-number">50000006</span><br>----costTime: <span class="hljs-number">214</span> 毫秒    add_LongAccumulator <span class="hljs-number">50000000</span><br></code></pre></td></tr></table></figure>

<h3 id="LongAdder为什么快"><a href="#LongAdder为什么快" class="headerlink" title="LongAdder为什么快"></a>LongAdder为什么快</h3><h3 id="LongAdder源码分析"><a href="#LongAdder源码分析" class="headerlink" title="LongAdder源码分析"></a>LongAdder源码分析</h3><p><font color=red><strong>太难了，暂时未看，等待后期补充【2021-12-31】</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112230.png" alt="image-20211231111331263"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112231.png" alt="image-20211231111358350"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112232.png" alt="image-20211231111408168"></p>
<h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112233.png" alt="image-20211015095759133"></p>
<h3 id="什么是UnSafe类"><a href="#什么是UnSafe类" class="headerlink" title="什么是UnSafe类"></a>什么是UnSafe类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112234.png" alt="image-20211015095842499"></p>
<h3 id="原子整形是否安全"><a href="#原子整形是否安全" class="headerlink" title="原子整形是否安全"></a>原子整形是否安全</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112235.png" alt="image-20211015095925331"></p>
<h3 id="getAndIncrement源码"><a href="#getAndIncrement源码" class="headerlink" title="getAndIncrement源码"></a>getAndIncrement源码</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112236.png" alt="image-20211015095952684"></p>
<h3 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112237.png" alt="image-20211015100105497"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112238.png" alt="image-20211015100114590"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112239.png" alt="image-20211015100122894"></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="Threadlocal简介"><a href="#Threadlocal简介" class="headerlink" title="Threadlocal简介"></a>Threadlocal简介</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112240.png" alt="image-20220104093557634"></p>
<h3 id="是什么-能干啥-API"><a href="#是什么-能干啥-API" class="headerlink" title="是什么/能干啥/API"></a>是什么/能干啥/API</h3><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法〉都有自己的、独立初始化的变量副本。</p>
<p>ThreadLocal实例通常是<code>类中的私有静态字段</code>，使用它的目的是希望<code>将状态（例如，用户ID或事务ID）与线程关联起来</code>。</p>
<p>实现<code>每一个线程都有自己专属的本地变量副本</code>(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，</p>
<p>主要解决了<code>让每个线程绑定自己的值</code>，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112241.png" alt="image-20211015114634074"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112242.png" alt="image-20211015114705321"></p>
<h3 id="案例：买房提成"><a href="#案例：买房提成" class="headerlink" title="案例：买房提成"></a>案例：买房提成</h3><h4 id="ThreadLocal初始化方法"><a href="#ThreadLocal初始化方法" class="headerlink" title="ThreadLocal初始化方法"></a>ThreadLocal初始化方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112243.png" alt="image-20211015114741295"></p>
<h4 id="买房提成案例"><a href="#买房提成案例" class="headerlink" title="买房提成案例"></a>买房提成案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112244.png" alt="image-20211015114755232"></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><strong>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，</strong></p>
<p><strong>如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。</strong></p>
<p>尽量在代理中使用try-finally块进行回收。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112245.png" alt="image-20211015114835559"></p>
<h3 id="从阿里ThreadLocal规范开始"><a href="#从阿里ThreadLocal规范开始" class="headerlink" title="从阿里ThreadLocal规范开始"></a>从阿里ThreadLocal规范开始</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112246.png" alt="image-20220104093715736"></p>
<h3 id="非线程安全的SimpleDateFormat"><a href="#非线程安全的SimpleDateFormat" class="headerlink" title="非线程安全的SimpleDateFormat"></a>非线程安全的SimpleDateFormat</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112247.png" alt="image-20211015121813651"></p>
<h4 id="错误的代码演示"><a href="#错误的代码演示" class="headerlink" title="错误的代码演示"></a>错误的代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112248.png" alt="image-20211015121840093"></p>
<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112249.png" alt="image-20211015121932062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112250.png" alt="image-20211015121920759"></p>
<h4 id="源码分析结论"><a href="#源码分析结论" class="headerlink" title="源码分析结论"></a>源码分析结论</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112251.png" alt="image-20211015122316518"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112252.png" alt="image-20211015122027813"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">30</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//每次用到的时候new</span><br>            System.out.println(sdf.parse(<span class="hljs-string">&quot;2020-11-11 11:11:11&quot;</span>));<br>            sdf = <span class="hljs-literal">null</span>;<span class="hljs-comment">//帮助GC回收</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;,String.valueOf(i)).start();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112253.png" alt="image-20211015122118700"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt;  sdf_threadLocal =<br>        ThreadLocal.withInitial(()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br></code></pre></td></tr></table></figure>



<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112254.png" alt="image-20211015122141371"></p>
<p><strong>次解决方案来自阿里推荐</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112255.png" alt="image-20211015122221608"></p>
<h4 id="其他方案："><a href="#其他方案：" class="headerlink" title="其他方案："></a>其他方案：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112256.png" alt="image-20211015122348115"></p>
<p><strong>代码</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112257.png" alt="image-20211015122424957"></p>
<h4 id="DataUtils"><a href="#DataUtils" class="headerlink" title="DataUtils"></a>DataUtils</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.juc.senior.utils;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-03 10:14</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateUtils</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1   SimpleDateFormat如果多线程共用是线程不安全的类</span><br><span class="hljs-comment">    public static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static String format(Date date)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return SIMPLE_DATE_FORMAT.format(date);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static Date parse(String datetime) throws ParseException</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return SIMPLE_DATE_FORMAT.parse(datetime);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; SIMPLE_DATE_FORMAT_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().format(date);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String datetime)</span> <span class="hljs-keyword">throws</span> ParseException<br>    &#123;<br>        <span class="hljs-keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().parse(datetime);<br>    &#125;<br><br><br>    <span class="hljs-comment">//3 DateTimeFormatter 代替 SimpleDateFormat</span><br>    <span class="hljs-comment">/*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static String format(LocalDateTime localDateTime)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static LocalDateTime parse(String dateString)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);</span><br><span class="hljs-comment">    &#125;*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="家庭作业-1"><a href="#家庭作业-1" class="headerlink" title="家庭作业"></a>家庭作业</h4><p>来自：阿里手册</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112258.png" alt="image-20220104100811176"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3 DateTimeFormatter 代替 SimpleDateFormat</span><br><span class="hljs-comment">/*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public static String format(LocalDateTime localDateTime)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    return DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public static LocalDateTime parse(String dateString)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure>

<h3 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112259.png" alt="image-20220104101005176"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112300.png" alt="image-20220104101300208"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112301.png" alt="image-20220104101333879"></p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><font color=red><strong>threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。</strong></font></p>
<p><font color=red><strong>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112302.png" alt="image-20220104101714282"></p>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112303.png" alt="image-20220104102637567"></p>
<blockquote>
<p>存在的问题：</p>
</blockquote>
<p><code>线程池环境下</code>，线程经常会被复用</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112304.png" alt="image-20220104102713615"></p>
<blockquote>
<p>什么是内存泄漏</p>
</blockquote>
<p>不再会被使用的对象或者变量占用的内存<code>不能被回收</code>，就是内存泄露。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112305.png" alt="image-20220104102918586"></p>
<blockquote>
<p>再看ThreadLocalMap</p>
</blockquote>
<p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)不过是经过了两层包装的ThreadLocal对象:</p>
<p>(1）第一层包装是<code>使用WeakReference&lt;ThreadLoca&lt;?&gt;&gt;</code> 将ThreadLocal对象<code>变成一个弱引用的对象;</code></p>
<p>(2）第二层包装是<code>定义了一个专门的类Entry</code>来<code>扩展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112306.png" alt="image-20220104132656644"></p>
<blockquote>
<p>整体架构</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112307.png" alt="image-20220104132844917"></p>
<h3 id="强软弱虚四大引用"><a href="#强软弱虚四大引用" class="headerlink" title="强软弱虚四大引用"></a>强软弱虚四大引用</h3><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是<code>出现了OOM也不会对该对象进行回收</code>，死都不收。</p>
<p>强引用是我们<code>最常见</code>的普通对象引用，<code>只要还有强引用指向一个对象</code>，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是<code>造成Java内存泄漏的主要原因之一</code>。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用<code>赋值为 null</code>，<br>一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>    myObject = <span class="hljs-literal">null</span>;<br>    System.gc();<br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p>
<p>对于只有软引用的对象来说，</p>
<p>当<code>系统内存充足</code>时它      不会     被回收，</p>
<p>当<code>系统内存不足</code>时它         会     被回收。</p>
<p>软引用通常用在<code>对内存敏感的程序</code>中，比如<code>高速缓存</code>就有用到软引用，内存够用的时候就保留，不够用就回收！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，</p>
<p>对于只有弱引用的对象来说，<code>只要垃圾回收机制一运行</code>，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span><br>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable<br>    &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        WeakReference&lt;MyObject&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>        System.out.println(<span class="hljs-string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">softReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112308.png" alt="image-20220104133420878"></p>
<hr>
<p>虚引用需要java.lang.ref.PhantomReference类来实现。</p>
<p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并<code>不会决定对象的生命周期</code>。<br>如果一个对象<code>仅持有虚引用</code>，那么它就<code>和没有任何引用一样，在任何时候都可能被垃圾回收器回收，</code><br>它<code>不能单独使用</code>也<code>不能通过它访问对象</code>，虚引用必须和<code>引用队列 (ReferenceQueue)</code>联合使用。</p>
<p>虚引用的主要作用是<code>跟踪对象被垃圾回收的状态</code>。 仅仅是提供了一种<code>确保对象被 finalize以后，做某些事情的机制</code>。 PhantomReference的<code>get方法总是返回null</code>，因此无法访问对应的引用对象。</p>
<p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>换句话说，设置虚引用关联的<code>唯一目的</code>，就是在这个<code>对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</code></p>
<p> <img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112309.png" alt="image-20220104133649886"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span><br>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable<br>    &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>        PhantomReference&lt;MyObject&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>(),referenceQueue);<br>        <span class="hljs-comment">//System.out.println(phantomReference.get());</span><br><br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">600</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                System.out.println(phantomReference.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyObject</span>&gt; reference = referenceQueue.poll();<br>                <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;***********有虚对象加入队列了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">weakReference</span><span class="hljs-params">()</span><br>    &#123;<br>        WeakReference&lt;MyObject&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>        System.out.println(<span class="hljs-string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">softReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112310.png" alt="image-20220104133742871"></p>
<h3 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112311.png" alt="image-20220104134029494"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112312.png" alt="image-20220104133918513"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112313.png" alt="image-20220104133959157"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112314.png" alt="image-20220104134328338"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112315.png" alt="image-20220104134433258"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112316.png" alt="image-20220104134738063"></p>
<p>结论：</p>
<p>从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，</p>
<p>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。</p>
<h3 id="弱引用结论"><a href="#弱引用结论" class="headerlink" title="弱引用结论"></a>弱引用结论</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112317.png" alt="image-20220104134851393"></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112318.png" alt="image-20220104135035912"></p>
<h2 id="Java对象内存布局和对象头"><a href="#Java对象内存布局和对象头" class="headerlink" title="Java对象内存布局和对象头"></a>Java对象内存布局和对象头</h2><h3 id="面试题反馈-2"><a href="#面试题反馈-2" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112319.png" alt="image-20211012185412065"></p>
<p>Object object = new Object()</p>
<p>谈谈你对这句话的理解?一般而言JDK8按照默认情况下,new一个对象占多少内存空间</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，<code>对象在堆内存中的存储布局</code>可以划分为三个部分：</p>
<p><code>一个对象实例</code>：对象头（Header)、实例数据（ Instance Daa）和对齐填充（Padding） </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112320.png" alt="image-20211012185625269"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112321.png" alt="image-20211012193045120"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><font color=red><strong>对象头= 对象标记（MarkWord）+类元信息（类型指针）</strong></font></p>
<p>MarkWord被设计成一个非固定的数据结构</p>
<p>以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p>
<p>默认存储：对象的HashCode、分代年龄和锁标志位等信息。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112322.png" alt="image-20211227162705811"></p>
<h4 id="对象标记（MarkWord）"><a href="#对象标记（MarkWord）" class="headerlink" title="对象标记（MarkWord）"></a>对象标记（MarkWord）</h4><p>它保存什么？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112323.png" alt="image-20211012193335272"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112324.png" alt="image-20211012193346287"></p>
<p>默认存储对象的HashCode、分代年龄和锁标志位等信息。</p>
<p>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构</p>
<p>以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p>
<h4 id="类元信息（类型指针）"><a href="#类元信息（类型指针）" class="headerlink" title="类元信息（类型指针）"></a>类元信息（类型指针）</h4><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>参考宋红康老师JVM课程中的原图</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112325.png" alt="image-20211012193439744"></p>
<h4 id="对象头多大"><a href="#对象头多大" class="headerlink" title="对象头多大"></a>对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p><strong>存放类的属性(Field)数据信息，包括父类的属性信息，</strong></p>
<p>如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112326.png" alt="image-20211012193707630"></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>&#123;<br>	<span class="hljs-built_in">int</span> i=<span class="hljs-number">5</span>;<br>	<span class="hljs-built_in">char</span> a=<span class="hljs-string">&#x27;a&#x27;</span>;<br>&#125;<br><br>MyObjec对象头 <span class="hljs-number">16</span>个字节：MarkWord <span class="hljs-number">8</span>个字节 + 类型指针 <span class="hljs-number">8</span>个字节<br><span class="hljs-built_in">int</span>类型：<span class="hljs-number">32</span>bit <span class="hljs-number">3</span>个字节<br><span class="hljs-built_in">char</span>类型：<span class="hljs-number">16</span>bit <span class="hljs-number">2</span>个字节<br>此时一共：<span class="hljs-number">16</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>=<span class="hljs-number">21</span>个字节<br>属性填充：<span class="hljs-number">3</span>个字节<br>一共：<span class="hljs-number">24</span>个字节<br></code></pre></td></tr></table></figure>

<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>虚拟机要求<strong>对象起始地址必须是8字节的整数倍</strong>。</p>
<p>填充数据<strong>不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐</strong>。</p>
<h2 id="对象头的MarkWord"><a href="#对象头的MarkWord" class="headerlink" title="对象头的MarkWord"></a>对象头的MarkWord</h2><h3 id="官网理论"><a href="#官网理论" class="headerlink" title="官网理论"></a>官网理论</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112327.png" alt="image-20211012194101288"></p>
<h3 id="再说对象头MarkWord"><a href="#再说对象头MarkWord" class="headerlink" title="再说对象头MarkWord"></a>再说对象头MarkWord</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112328.png" alt="image-20211012194133425"></p>
<h4 id="32位虚拟机"><a href="#32位虚拟机" class="headerlink" title="32位虚拟机"></a>32位虚拟机</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112329.png" alt="image-20211012194154484"></p>
<h4 id="64位虚拟机"><a href="#64位虚拟机" class="headerlink" title="64位虚拟机"></a>64位虚拟机</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112330.png" alt="image-20211012194209714"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112331.png" alt="image-20211012194238368"></p>
<h4 id="64位虚拟机源码"><a href="#64位虚拟机源码" class="headerlink" title="64位虚拟机源码"></a>64位虚拟机源码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112332.png" alt="image-20211012194253289"></p>
<h2 id="对象布局说明和压缩指针"><a href="#对象布局说明和压缩指针" class="headerlink" title="对象布局说明和压缩指针"></a>对象布局说明和压缩指针</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112333.png" alt="image-20211012201849463"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112334.png" alt="image-20211012201921382"></p>
<h3 id="JOL使用案例"><a href="#JOL使用案例" class="headerlink" title="JOL使用案例"></a>JOL使用案例</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112335.png" alt="image-20211012202019923"></p>
<h4 id="new-Object代码说明"><a href="#new-Object代码说明" class="headerlink" title="new Object代码说明"></a>new Object代码说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112336.png" alt="image-20211012202129097"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112337.png" alt="image-20211012202207850"></p>
<h4 id="换个对象试试"><a href="#换个对象试试" class="headerlink" title="换个对象试试"></a>换个对象试试</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112338.png" alt="image-20211012202257998"></p>
<h4 id="修改GC年龄"><a href="#修改GC年龄" class="headerlink" title="修改GC年龄"></a>修改GC年龄</h4><p>GC年龄采用4位bit存储，最大值为15，使用参数修改大于15时，会报错，无法启动JVM</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112339.png" alt="image-20211012202402683"></p>
<h4 id="自动压缩"><a href="#自动压缩" class="headerlink" title="自动压缩"></a>自动压缩</h4><p>默认开启自动压缩</p>
<p>使用 打印JVM参数</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112340.png" alt="image-20211012202742428"></p>
<p>关闭自动压缩</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112341.png" alt="image-20211012202824337"></p>
<h2 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112342.png" alt="image-20211013094038359"></p>
<h3 id="面试题引入"><a href="#面试题引入" class="headerlink" title="面试题引入"></a>面试题引入</h3><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体;能用对象锁，就不要用类锁。</p>
<p>说明︰尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112343.png" alt="image-20211013094115206"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112344.png" alt="image-20211013094150776"></p>
<h3 id="Synchronized的性能变化"><a href="#Synchronized的性能变化" class="headerlink" title="Synchronized的性能变化"></a>Synchronized的性能变化</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112345.png" alt="image-20211013094246274"></p>
<h3 id="为什么每一个对象都可以成为一个锁"><a href="#为什么每一个对象都可以成为一个锁" class="headerlink" title="为什么每一个对象都可以成为一个锁"></a>为什么每一个对象都可以成为一个锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112346.png" alt="image-20211013094401059"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112347.png" alt="image-20211013094435413"></p>
<h3 id="Monitor（监视器锁）"><a href="#Monitor（监视器锁）" class="headerlink" title="Monitor（监视器锁）"></a>Monitor（监视器锁）</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112348.png" alt="image-20211013094447226"></p>
<h3 id="Synchronized锁优化背景"><a href="#Synchronized锁优化背景" class="headerlink" title="Synchronized锁优化背景"></a>Synchronized锁优化背景</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112349.png" alt="image-20211013094614743"></p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112350.png" alt="image-20211013094724969"></p>
<h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>==synchronized用的锁是存在Java对象头里的Mark Word中，锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位==</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112351.png" alt="image-20211013095018134"></p>
<h2 id="锁升级详解"><a href="#锁升级详解" class="headerlink" title="锁升级详解"></a>锁升级详解</h2><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><h4 id="无锁案例"><a href="#无锁案例" class="headerlink" title="无锁案例"></a>无锁案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112352.png" alt="image-20211013095230223"></p>
<h4 id="hashcode有调用才会存储"><a href="#hashcode有调用才会存储" class="headerlink" title="hashcode有调用才会存储"></a>hashcode有调用才会存储</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112353.png" alt="image-20211013095334614"></p>
<h4 id="16进制下的hashcode"><a href="#16进制下的hashcode" class="headerlink" title="16进制下的hashcode"></a>16进制下的hashcode</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112354.png" alt="image-20211013095405797"></p>
<h4 id="2进制下的hashcode"><a href="#2进制下的hashcode" class="headerlink" title="2进制下的hashcode"></a>2进制下的hashcode</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112355.png" alt="image-20211013095423101"></p>
<h4 id="总结：程序不会有锁的竞争"><a href="#总结：程序不会有锁的竞争" class="headerlink" title="总结：程序不会有锁的竞争"></a>总结：程序不会有锁的竞争</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112356.png" alt="image-20211013095533001"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>什么是偏向锁：</p>
<p><code>当一段同步代码一直被同一个线程多次访问</code>，由于只有一个线程那么该线程在后续访问时便会自动获得锁</p>
<p>为什么会有偏向锁：</p>
<p>Hotspot的作者经过研究发现，<code>大多数情况下：多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况</code>，偏向锁就是在这种情况下出现的，它的出现是<code>为了解决只有在一个线程执行同步时提高性能</code>。</p>
<p>过程说明：</p>
<p>那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。</p>
<p>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，<code>如果一致直接进入同步。</code>无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p>
<p>升级为轻量级锁：</p>
<p>假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。</p>
<p><code>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</code></p>
<p>偏向锁的撤销</p>
<p>竞争线程<code>尝试CAS更新对象头失败</code>，会等待到<code>全局安全点</code>（此时不会执行任何代码）撤销偏向锁。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112357.png" alt="image-20211013104052400"></p>
<h4 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112358.png" alt="image-20211013104113759"></p>
<h4 id="64位标记图再看"><a href="#64位标记图再看" class="headerlink" title="64位标记图再看"></a>64位标记图再看</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112359.png" alt="image-20211013140221900"></p>
<h4 id="偏向锁的持有说明"><a href="#偏向锁的持有说明" class="headerlink" title="偏向锁的持有说明"></a>偏向锁的持有说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112400.png" alt="image-20211013140310398"></p>
<h4 id="偏向锁的举例说明"><a href="#偏向锁的举例说明" class="headerlink" title="偏向锁的举例说明"></a>偏向锁的举例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112401.png" alt="image-20211013140421616"></p>
<h4 id="偏向锁JVM命令"><a href="#偏向锁JVM命令" class="headerlink" title="偏向锁JVM命令"></a>偏向锁JVM命令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112402.png" alt="image-20211013140505059"></p>
<h4 id="偏向锁代码演示【无效果】"><a href="#偏向锁代码演示【无效果】" class="headerlink" title="偏向锁代码演示【无效果】"></a>偏向锁代码演示【无效果】</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112403.png" alt="image-20211013140554657"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112404.png" alt="image-20211013140538655"></p>
<h4 id="偏向锁代码演示【有效果】"><a href="#偏向锁代码演示【有效果】" class="headerlink" title="偏向锁代码演示【有效果】"></a>偏向锁代码演示【有效果】</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112405.png" alt="image-20211013140708554"></p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112406.png" alt="image-20211013140739996"></p>
<h4 id="偏向锁获取撤销流程"><a href="#偏向锁获取撤销流程" class="headerlink" title="偏向锁获取撤销流程"></a>偏向锁获取撤销流程</h4><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112407.png" alt="image-20211013144527645" style="zoom:67%;" />

<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112408.png" alt="image-20211013144131221"></p>
<h4 id="64位标记图"><a href="#64位标记图" class="headerlink" title="64位标记图"></a>64位标记图</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112409.png" alt="image-20211013144212443"></p>
<h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112410.png" alt="image-20211013144238381"></p>
<h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112411.png" alt="image-20211013144306778"></p>
<h4 id="自旋到一定次数"><a href="#自旋到一定次数" class="headerlink" title="自旋到一定次数"></a>自旋到一定次数</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112412.png" alt="image-20211013144352678"></p>
<h4 id="轻量级锁与偏向锁的区别和不同"><a href="#轻量级锁与偏向锁的区别和不同" class="headerlink" title="轻量级锁与偏向锁的区别和不同"></a>轻量级锁与偏向锁的区别和不同</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112413.png" alt="image-20211013144409712"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112414.png" alt="image-20211013144613806"></p>
<h4 id="锁标志位"><a href="#锁标志位" class="headerlink" title="锁标志位"></a>锁标志位</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112415.png" alt="image-20211013144705260"></p>
<h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112416.png" alt="image-20211013144716981"></p>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112417.png" alt="image-20211013144738215"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112418.png" alt="image-20211013144754332"></p>
<h2 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112419.png" alt="image-20211013144839121"></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112420.png" alt="image-20211013144904203"></p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112421.png" alt="image-20211013144924541"></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><font color=red>AbstractQueuedSynchronizer</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112422.png" alt="image-20220105093806917"></p>
<blockquote>
<p><strong>通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112423.png" alt="image-20220105093407830"></p>
<blockquote>
<p>AQS相关</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112424.png" alt="image-20220105093527767"></p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p>加锁会导致阻塞 =&gt; <code>有阻塞就需要排队，实现排队必然需要队列</code></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112425.png" alt="image-20220105094303829"></p>
<blockquote>
<p>能干嘛：解释说明</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112426.png" alt="image-20220105094524031"></p>
<blockquote>
<p><font color=red><strong>AQS内部体系结构</strong></font></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112427.png" alt="image-20220105095103564"></p>
<blockquote>
<p>官网解释</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112428.png" alt="image-20220105094157634"></p>
<blockquote>
<p><font color=red><strong>AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</strong></font></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112429.png" alt="image-20220105094050754"></p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112430.png" alt="image-20211013153241873"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112431.png" alt="image-20211013153358110"></p>
<h3 id="面试题引入-1"><a href="#面试题引入-1" class="headerlink" title="面试题引入"></a>面试题引入</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112432.png" alt="image-20211013153311204"></p>
<h3 id="锁得演变过程"><a href="#锁得演变过程" class="headerlink" title="锁得演变过程"></a>锁得演变过程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112433.png" alt="image-20211013153419241"></p>
<h3 id="什么是读写锁"><a href="#什么是读写锁" class="headerlink" title="什么是读写锁"></a>什么是读写锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112434.png" alt="image-20211013153459517"></p>
<h3 id="锁降级说明"><a href="#锁降级说明" class="headerlink" title="锁降级说明"></a>锁降级说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112435.png" alt="image-20211013153631694"></p>
<h3 id="读锁和写锁互斥"><a href="#读锁和写锁互斥" class="headerlink" title="读锁和写锁互斥"></a>读锁和写锁互斥</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112436.png" alt="image-20211013160126827"></p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112437.png" alt="image-20211013153603364"></p>
<h3 id="锁降级说明-1"><a href="#锁降级说明-1" class="headerlink" title="锁降级说明"></a>锁降级说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112438.png" alt="image-20211013153631694"></p>
<h3 id="Java8官网说明"><a href="#Java8官网说明" class="headerlink" title="Java8官网说明"></a>Java8官网说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112439.png" alt="image-20211013153729050"></p>
<h3 id="可以降级"><a href="#可以降级" class="headerlink" title="可以降级"></a>可以降级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112440.png" alt="image-20211013153717658"></p>
<h3 id="不可锁升级"><a href="#不可锁升级" class="headerlink" title="不可锁升级"></a>不可锁升级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112441.png" alt="image-20211013153825161"></p>
<h3 id="读写锁降级演示"><a href="#读写锁降级演示" class="headerlink" title="读写锁降级演示"></a>读写锁降级演示</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112442.png" alt="image-20211013153854646"></p>
<p><font color=red>锁可以降级，程序正常执行</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112443.png" alt="image-20211013153925882"></p>
<p><font color=red>程序不能正常执行，会卡住，写锁没有释放，无法获取读锁</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112444.png" alt="image-20211013154000848"></p>
<h3 id="持有写锁后获取读锁"><a href="#持有写锁后获取读锁" class="headerlink" title="持有写锁后获取读锁"></a>持有写锁后获取读锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112445.png" alt="image-20211013154746431"></p>
<h3 id="Oracle源码之锁降级"><a href="#Oracle源码之锁降级" class="headerlink" title="Oracle源码之锁降级"></a>Oracle源码之锁降级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112446.png" alt="image-20211013160158063"></p>
<h2 id="StampedLock邮戳锁"><a href="#StampedLock邮戳锁" class="headerlink" title="StampedLock邮戳锁"></a>StampedLock邮戳锁</h2><h3 id="什么是StampedLock"><a href="#什么是StampedLock" class="headerlink" title="什么是StampedLock"></a>什么是StampedLock</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112447.png" alt="image-20211013165245758"></p>
<h3 id="什么是锁饥饿问题"><a href="#什么是锁饥饿问题" class="headerlink" title="什么是锁饥饿问题"></a>什么是锁饥饿问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112448.png" alt="image-20211013164511754"></p>
<h3 id="怎么缓解锁饥饿问题"><a href="#怎么缓解锁饥饿问题" class="headerlink" title="怎么缓解锁饥饿问题"></a>怎么缓解锁饥饿问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112449.png" alt="image-20211013164559573"></p>
<h3 id="StampedLock乐观读锁"><a href="#StampedLock乐观读锁" class="headerlink" title="StampedLock乐观读锁"></a>StampedLock乐观读锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112450.png" alt="image-20211013164654214"></p>
<h3 id="StampedLock的特点"><a href="#StampedLock的特点" class="headerlink" title="StampedLock的特点"></a>StampedLock的特点</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112451.png" alt="image-20211013164747555"></p>
<h3 id="StampedLock三种访问模式"><a href="#StampedLock三种访问模式" class="headerlink" title="StampedLock三种访问模式"></a>StampedLock三种访问模式</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112452.png" alt="image-20211013164836354"></p>
<h3 id="三种访问模式代码演示"><a href="#三种访问模式代码演示" class="headerlink" title="三种访问模式代码演示"></a>三种访问模式代码演示</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112453.png" alt="image-20211013164953897"></p>
<h3 id="StampedLock的缺点"><a href="#StampedLock的缺点" class="headerlink" title="StampedLock的缺点"></a>StampedLock的缺点</h3><p><font color=red>StampedLock可能会导致死锁，建议不要再工作中使用，仅为了应付面试</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112454.png" alt="image-20211013164856029"></p>
<h2 id="结课总结"><a href="#结课总结" class="headerlink" title="结课总结"></a>结课总结</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112455.png" alt="image-20211013165313322"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis6</title>
    <url>/kygeng.github.io/2022/02/23/%E5%A4%A7%E5%8E%82%E5%AD%A6%E9%99%A2%EF%BC%9ARedis6/</url>
    <content><![CDATA[<h1 id="大厂学院-Redis6"><a href="#大厂学院-Redis6" class="headerlink" title="大厂学院-Redis6"></a>大厂学院-Redis6</h1><h2 id="1-课程说明"><a href="#1-课程说明" class="headerlink" title="1.课程说明"></a>1.课程说明</h2><blockquote>
<p>课程说明</p>
</blockquote>
<p>参考资料：<a href="https://www.itdachang.com/">https://www.itdachang.com/</a></p>
<p>本文章基于【大厂学苑】课程《极致性能Redis实战与原理》进行整理/记录，仅用于个人学习/交流使用。</p>
<blockquote>
<p>前置要求</p>
</blockquote>
<p>学过Redis</p>
<p>安装了Redis</p>
<p>Redis版本必须是 6.0.8+</p>
<blockquote>
<p>相关网站</p>
</blockquote>
<blockquote>
<p>几篇文章【对于课程内容更加深刻讲解】</p>
</blockquote>
<p> <a href="https://zhuanlan.zhihu.com/p/144805500">Redis 6.0 多线程IO处理过程详解</a></p>
<blockquote>
<p>本课程落地案例</p>
</blockquote>
<p>案例实战：SpringBoot + Mybatis + Redis(重写Redis的序列化)的缓存实战</p>
<p>案例实战：微信文章阅读量小厂统计</p>
<p>案例实战：天猫网站首页亿级UV的Redis统计方案</p>
<p>案例实战：美团地图位置附近的酒店推送</p>
<p>案例实战：Redis布隆过滤器+防止缓存穿透含白名单校验器</p>
<p>案例实战：淘宝聚划算功能实现+防止缓存击穿</p>
<p>案例实战：分布式锁redisson实战和源码深度分析</p>
<p>案例实战：B站视频、淘宝购物分享短连接推广</p>
<p>案例实战：微信抢红包</p>
<h2 id="2-Redis官网查阅和基本配置"><a href="#2-Redis官网查阅和基本配置" class="headerlink" title="2.Redis官网查阅和基本配置"></a>2.Redis官网查阅和基本配置</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120713.png" alt="image-20211213135002620"></p>
<h2 id="3-Redis单线程与多线程"><a href="#3-Redis单线程与多线程" class="headerlink" title="3.Redis单线程与多线程"></a>3.Redis单线程与多线程</h2><h3 id="Redis3单线程"><a href="#Redis3单线程" class="headerlink" title="Redis3单线程"></a>Redis3单线程</h3><h4 id="什么是Redis单线程"><a href="#什么是Redis单线程" class="headerlink" title="什么是Redis单线程"></a>什么是Redis单线程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120714.png" alt="image-20211213135209574"></p>
<p><strong>同步删除</strong> : 删除key时释放value空间是在主线程中执行。</p>
<p><strong>异步删除</strong> : 删除key时释放value空间是在异步线程中执行。</p>
<p>使用 unlink指令， 它能对删除操作进行懒处理，丢给后退线程来异步回收内存  <code>unlink key</code></p>
<h4 id="Redis单线程的意义"><a href="#Redis单线程的意义" class="headerlink" title="Redis单线程的意义"></a>Redis单线程的意义</h4><p><strong>Redis单线程：</strong></p>
<p>主要是指<code>Redis的网络IO</code>和<code>键值对读写</code>是由<code>一个线程</code>来完成的，Redis在处理客户端的请求时，包括<code>获取(socket 读)、解析、执行、内容返回(socket写)</code>等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是<code>Redis对外提供键值存储服务</code>的主要流程。</p>
<p><strong>Redis多线程：</strong></p>
<p>但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。</p>
<p>Redis工作线程是单线程的，但是，整个Redis来说，是多线程的</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120715.png" alt="image-20211213135323186"></p>
<h4 id="Redis3-X单线程快的原因"><a href="#Redis3-X单线程快的原因" class="headerlink" title="Redis3.X单线程快的原因"></a>Redis3.X单线程快的原因</h4><p><code>基于内存操作：</code>Redis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高;</p>
<p><code>数据结构简单：</code>Redis 的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是o(1)，因此性能比较高</p>
<p><code>多路复用和非阻塞I/O: </code>Redis使用I/O多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了I/O阻塞操作</p>
<p><code>避免上下文切换：</code>因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗</p>
<h3 id="Redis4多线程"><a href="#Redis4多线程" class="headerlink" title="Redis4多线程"></a>Redis4多线程</h3><h4 id="Redis4采用多线程的原因"><a href="#Redis4采用多线程的原因" class="headerlink" title="Redis4采用多线程的原因"></a>Redis4采用多线程的原因</h4><p><font color=red><strong>Redis的性能瓶颈在于内存或网络IO，不在于内存</strong></font></p>
<p>对于内存来说，优化方向容易（加内容条）</p>
<p>所以大部分优化的内容在于网络IO，所以出现了 网络IO多路复用技术</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120716.png" alt="image-20211213135541976"></p>
<p><strong>简单来说，Redis 4.0之前一直采用单线程的主要原因有以下三个:</strong></p>
<p>1、使用单线程模型是Redis 的开发和维护更简单，因为单线程模型方便开发和调试;</p>
<p>2、即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用和非阻塞IO;</p>
<p>3、对于Redis 系统来说，<font color=red>主要的性能瓶颈是内存或者网络带宽而并非 CPU。</font></p>
<h4 id="Redis单线程的问题"><a href="#Redis单线程的问题" class="headerlink" title="Redis单线程的问题"></a>Redis单线程的问题</h4><p><strong>删除大的key的时候卡顿</strong></p>
<p>单线程也有单线程的苦恼</p>
<p><strong>举个栗子：</strong></p>
<p>正常情况下使用 del 指令可以很快的删除数据，而当<code>被删除的 key是一个非常大的对象时</code>，例如时包含了成千上万个元素的hash集合时，那么<code> del 指令就会造成Redis主线程卡顿</code>。</p>
<p>这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，</p>
<p>由于redis是单线程的，del bigKey …..</p>
<p>等待很久这个线程才会释放，类似加了一个synchronized锁，你可以想象高并发下，程序堵成什么样子?</p>
<p><strong>如何解决：</strong></p>
<p>使用<code>惰性删除</code>可以有效的避免Redis卡顿的问题</p>
<p>在Redis 4.0就引入了<code>多个线程来实现数据的异步惰性删除</code>但是<code>其处理读写请求的仍然只有一个线程，所以仍然算是单线程</code></p>
<h4 id="Redis异步删除解决方案"><a href="#Redis异步删除解决方案" class="headerlink" title="Redis异步删除解决方案"></a>Redis异步删除解决方案</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120717.png" alt="image-20211213135720964"></p>
<p>Redis提供了flushdb和flushall指令， 用来清空数据库， 这也是极其缓慢的操作。Redis4.0同样给这两个指令带来异步化， 在指令后面增加async参数就可以将整个大树连根拔起， 扔给后台线程慢慢焚烧</p>
<h2 id="4-多线程I-O多路复用简介"><a href="#4-多线程I-O多路复用简介" class="headerlink" title="4.多线程I/O多路复用简介"></a>4.多线程I/O多路复用简介</h2><p>Redis必须安装在linux、Unix系统上才能发挥最大性能，因为epoll函数</p>
<h3 id="Redis的性能瓶颈"><a href="#Redis的性能瓶颈" class="headerlink" title="Redis的性能瓶颈"></a>Redis的性能瓶颈</h3><p>对于Redis主要的性能瓶颈是内存或者网络带宽而并非CPU。</p>
<img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120718.png" alt="image-20211213172217277" style="zoom:67%;" />

<h3 id="Unix编程中的五种IO模型"><a href="#Unix编程中的五种IO模型" class="headerlink" title="Unix编程中的五种IO模型"></a>Unix编程中的五种IO模型</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120719.png" alt="image-20211213142101919"></p>
<h3 id="Redis是单线程还是多线程？"><a href="#Redis是单线程还是多线程？" class="headerlink" title="Redis是单线程还是多线程？"></a>Redis是单线程还是多线程？</h3><p>Redis工作线程是单线程的，但是，整个Redis来说，是多线程的</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120720.png" alt="image-20211213142213970"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120721.png" alt="image-20211213142246252"></p>
<h2 id="5-开启Redis6的多线程"><a href="#5-开启Redis6的多线程" class="headerlink" title="5.开启Redis6的多线程"></a>5.开启Redis6的多线程</h2><p>而在Redis 6.0中引入了<code>IO多线程的读写</code>，这样就可以更加高效的处理更多的任务了</p>
<p><font color=red><strong>Redis <code>只是将IO读写变成了多线程</code>，而<code>命令的执行</code>依旧是由<code>主线程串行执行</code>的，因此在多线程下操作Redis<code>不会出现线程安全</code>的问题。</strong></font></p>
<p>Redis6多线程数的设置：</p>
<p>关于线程数的设置，官方的建议是如果为<code>4核的CPU</code>，建议线程数设置为<code>2或3</code>，如果为<code>8核CPU</code>建议线程数<code>设置为6</code>，<code>线程数一定要小于机器核数</code>，线程数并不是越大越好。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120722.png" alt="image-20211213142319711"></p>
<h2 id="6-Redis简单案例"><a href="#6-Redis简单案例" class="headerlink" title="6.Redis简单案例"></a>6.Redis简单案例</h2><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120723.png" alt="image-20211213150140098"></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p><code>缓存击穿：</code>击中、穿过去：查到Redis上，Redis缓存key过期</p>
<p><code>缓存穿透：</code>穿透：查Redis没有，查数据库没有，都没有，Redis和数据库都穿透过去了</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120724.png" alt="image-20211213151233469"></p>
<h3 id="借鉴思想"><a href="#借鉴思想" class="headerlink" title="借鉴思想"></a>借鉴思想</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120725.png" alt="image-20211213151253756"></p>
<h2 id="7-Redis五种数据类型"><a href="#7-Redis五种数据类型" class="headerlink" title="7.Redis五种数据类型"></a>7.Redis五种数据类型</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120726.png" alt="image-20211213170827882"></p>
<p>Redis 本身是有一个<code>Redis 发布订阅(pup/sub)</code>来<code>实现消息队列</code>的功能，但它有个缺点就是<code>消息无法持久化</code>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。简单来说发布订阅(pub/sub)可以分发消息，但无法记录历史消息。</p>
<p>而<code>Redis Stream 提供了消息的持久化和主备复制功能</code>，可以让<code>任何客户端访问任何时刻的数据</code>，并且<code>能记住每一个客户端的访问位置</code>，还能<code>保证消息不丢失</code>。它算是redis自己消息功能的补充。</p>
<p>但是，术业有专攻，一般使用<code>主流MQ</code>(Kafka/RabbitMQ/RocketMQ/Pulsar)来实现消息队列功能。</p>
<h3 id="数据类型API"><a href="#数据类型API" class="headerlink" title="数据类型API"></a>数据类型API</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120727.png" alt="image-20211213170854686"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120728.png" alt="image-20211220092754058"></p>
<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120729.png" alt="image-20211213170905364"></p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120730.png" alt="image-20211213170925793"></p>
<p><code>一个双端链表的结构</code>，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。</p>
<p><a href="https://mp.weixin.qq.com/s/_q0bI62iFrG8h-gZ-bCvNQ">Redis 消息队列的三种方案（List、Streams、Pub/Sub）</a></p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120731.png" alt="image-20211213171020047"></p>
<h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120732.png" alt="image-20211213171053759"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="string：统计"><a href="#string：统计" class="headerlink" title="string：统计"></a>string：统计</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120733.png" alt="image-20211220092844654"></p>
<h4 id="hash：购物车"><a href="#hash：购物车" class="headerlink" title="hash：购物车"></a>hash：购物车</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120734.png" alt="image-20211220093017545"></p>
<h4 id="list：消息订阅、评论列表"><a href="#list：消息订阅、评论列表" class="headerlink" title="list：消息订阅、评论列表"></a>list：消息订阅、评论列表</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120735.png" alt="image-20211220093218701"></p>
<h4 id="set：认识的人、抽奖"><a href="#set：认识的人、抽奖" class="headerlink" title="set：认识的人、抽奖"></a>set：认识的人、抽奖</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120736.png" alt="image-20211220093404335"></p>
<h4 id="zset：排行榜、热搜"><a href="#zset：排行榜、热搜" class="headerlink" title="zset：排行榜、热搜"></a>zset：排行榜、热搜</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120737.png" alt="image-20211220093511222"></p>
<h4 id="补充说明：list和set做评论列表"><a href="#补充说明：list和set做评论列表" class="headerlink" title="补充说明：list和set做评论列表"></a>补充说明：list和set做评论列表</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120738.png" alt="image-20211220093625131"></p>
<h3 id="综合案例：微信点赞"><a href="#综合案例：微信点赞" class="headerlink" title="综合案例：微信点赞"></a>综合案例：微信点赞</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120739.png" alt="image-20211213171229895"></p>
<h2 id="8-Redis新的数据类型"><a href="#8-Redis新的数据类型" class="headerlink" title="8.Redis新的数据类型"></a>8.Redis新的数据类型</h2><h3 id="为什么会有着三种数据类型"><a href="#为什么会有着三种数据类型" class="headerlink" title="为什么会有着三种数据类型"></a>为什么会有着三种数据类型</h3><h4 id="面试题反馈"><a href="#面试题反馈" class="headerlink" title="面试题反馈"></a>面试题反馈</h4><p>手机App中的每天的用巨登录信息：1天对应1系列用户ID或移动设备ID</p>
<p>电商网站上商品的用巨评论列表:1个商品对应了1系列的评论;</p>
<p>用巨在手机App上的签到打卡信息:1天对应1系列用巨的签到记录</p>
<p>应用网站上的网页访问信息:1个网页对应1系列的访问点击。</p>
<p><strong>面试问：记录对集合中的数据进行统计</strong></p>
<p>在移动应用中，需要统计每天的新增用户数和第2天的留存用户数;</p>
<p>在电商网站的商品评论中，需要统计评论列表中的最新评论;</p>
<p>在签到打卡中，需要统计一个月内连续打卡的用户数;</p>
<p>在网页访问记录中，需要统计独立访客(UniqueVisitor，UV）量。</p>
<p>……</p>
<h4 id="需求的痛点"><a href="#需求的痛点" class="headerlink" title="需求的痛点"></a>需求的痛点</h4><p><strong>痛点：</strong></p>
<p>类似今日头条、抖音、淘宝这样的额用户访问级别都是<code>亿级</code>的，请问如何处理?</p>
<p><strong>需求痛点：</strong></p>
<ul>
<li><p>   亿级数据的收集+统计</p>
</li>
<li><p>一句话：<code>存的进+取得快+多统计</code></p>
</li>
<li><p>真正有价值的是统计……</p>
</li>
</ul>
<h3 id="亿级系统中常见的四种统计"><a href="#亿级系统中常见的四种统计" class="headerlink" title="亿级系统中常见的四种统计"></a>亿级系统中常见的四种统计</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120740.png" alt="image-20211213171616208"></p>
<h4 id="排序统计案例设计"><a href="#排序统计案例设计" class="headerlink" title="排序统计案例设计"></a>排序统计案例设计</h4><p>抖音视频最新评论留言的场景，请你设计一个展现列表。</p>
<p>考察你的数据结构和设计思路</p>
<p>以抖音vcr最新的留言评价为案例，所有评论需要两个功能，<code>按照时间排序+分页</code>显示</p>
<p>能够排序+分页显示的redis数据结构是什么合适?</p>
<p><strong>list和zest的选择：</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120741.png" alt="image-20211213171749244"></p>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><h4 id="什么是bitmap"><a href="#什么是bitmap" class="headerlink" title="什么是bitmap"></a>什么是bitmap</h4><p>一句话：由<code>0和1状态表现</code>的二进制位的bit数组</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120742.png" alt="image-20211214110434830"></p>
<h4 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120743.png" alt="image-20211214101906760"></p>
<h4 id="使用场景说明"><a href="#使用场景说明" class="headerlink" title="使用场景说明"></a>使用场景说明</h4><p><font color=red><strong>能干嘛：用于状态统计（签到统计、是否登录、是否点击…）</strong></font></p>
<ul>
<li><p>Y、N，类似AtomicBoolean，用户是否登陆过Y、N</p>
</li>
<li><p>比如京东每日签到送京豆电影、广告是否被点击播放过</p>
</li>
<li><p>钉钉打未上下班，签到统计</p>
</li>
</ul>
<p>在签到统计时，<code>每个用户一天的签到用1个bit位</code>就能表示</p>
<p><code>一个月（假设是31天）的签到情况用31个bit位</code>就可以，<code>一年的签到也只需要用365个bit位</code>，根本不用太复杂的集合类型</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120744.png" alt="image-20211214101437057"></p>
<h4 id="案例：JD签到领京豆"><a href="#案例：JD签到领京豆" class="headerlink" title="案例：JD签到领京豆"></a>案例：JD签到领京豆</h4><p>实现方式：</p>
<ul>
<li>MySQL（淘汰）</li>
<li>bitmap</li>
</ul>
<h5 id="MySQL实现方式"><a href="#MySQL实现方式" class="headerlink" title="MySQL实现方式"></a>MySQL实现方式</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120745.png" alt="image-20211214101633931"></p>
<h5 id="困难和解决思路"><a href="#困难和解决思路" class="headerlink" title="困难和解决思路"></a>困难和解决思路</h5><p>方法正确但是难以落地实现，</p>
<p>签到用户量较小时这么设计能行，但京东这个体量的用户（估算3000W签到用户，一天一条数据，一个月就是9亿数据）对于京东这样的体量，如果一条签到记录对应着当日用记录，那会很恐怖…..</p>
<p>如何解决这个痛点?</p>
<p>1、一条签到记录对应一条记录，会占据越来越大的空间。</p>
<p>2、一个月最多31天，刚好我们的int类型是32位，那这样一个int类型就可以搞定一个月，32位大于31天，当天来了位是1没来就是0。</p>
<p>3、一条数据直接存储一个月的签到记录，不再是存储一天的签到记录。</p>
<h5 id="bitmap方式"><a href="#bitmap方式" class="headerlink" title="bitmap方式"></a>bitmap方式</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120746.png" alt="image-20211214102008346"></p>
<h4 id="bittop说明"><a href="#bittop说明" class="headerlink" title="bittop说明"></a>bittop说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120747.png" alt="image-20211214102252638"></p>
<h4 id="strlen说明"><a href="#strlen说明" class="headerlink" title="strlen说明"></a>strlen说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120748.png" alt="image-20211214102450725"></p>
<h4 id="bitmap底层编码说明"><a href="#bitmap底层编码说明" class="headerlink" title="bitmap底层编码说明"></a>bitmap底层编码说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120749.png" alt="image-20211214102536049"></p>
<h3 id="hyperloglgo"><a href="#hyperloglgo" class="headerlink" title="hyperloglgo"></a>hyperloglgo</h3><h4 id="专业名词说明"><a href="#专业名词说明" class="headerlink" title="专业名词说明"></a>专业名词说明</h4><p>什么是<code>UV：Unique Visitor，独立访客</code>，一般理解为客户端IP，需要去重考虑</p>
<p>什么是<code>PV：什么是PV，Page View，页面浏览量</code>，不用去重</p>
<p>什么是<code>DAU：Daily Active User，日活跃用户量</code>。登录或者使用了某个产品的用户数(去重复登录的用户)常用于反映网站、互联网应用或者网络游戏的运营情况</p>
<p>什么是<code>MAU：Monthly Active User，月活跃用户量</code></p>
<h4 id="什么是hyperloglog"><a href="#什么是hyperloglog" class="headerlink" title="什么是hyperloglog"></a>什么是hyperloglog</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120750.png" alt="image-20211214103839296"></p>
<h4 id="实现去重统计的方案"><a href="#实现去重统计的方案" class="headerlink" title="实现去重统计的方案"></a>实现去重统计的方案</h4><ul>
<li><p>Java中的HashSet</p>
</li>
<li><p>MySQL</p>
</li>
<li><p>Redis中的Set</p>
</li>
<li><p>Redis中的bitmaps</p>
</li>
<li><p>Redis中的hyperloglog</p>
</li>
</ul>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120751.png" alt="image-20211214103956435"></p>
<p>样本元素越多内存消耗急剧增大，难以管控+各种慢，对于亿级统计不太合适，大数据害死人</p>
<h4 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h4><p><code>只是进行不重复的基数统计</code>，不是集合也不保存数据，<code>只记录数量而不记录具体内容</code>。</p>
<p><code>通过牺牲准确率来换取空间</code>，对于不要求绝对准确率的场景下可以使用，因为<code>概率算法不直接存储数据本身</code>，通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存。</p>
<p>HyperLogLog就是一种概率算法的实现。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120752.png" alt="image-20211214104206448"></p>
<h4 id="面试题：为什么Redis集群最大槽数是16384"><a href="#面试题：为什么Redis集群最大槽数是16384" class="headerlink" title="面试题：为什么Redis集群最大槽数是16384"></a>面试题：为什么Redis集群最大槽数是16384</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120753.png" alt="image-20220110194608719"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120754.png" alt="image-20220110194600102"></p>
<h4 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120755.png" alt="image-20211214104449243"></p>
<h4 id="案例：访问人数统计"><a href="#案例：访问人数统计" class="headerlink" title="案例：访问人数统计"></a>案例：访问人数统计</h4><p>UV的统计需要去重，一个用户一天内的多次访问只能算作一次</p>
<p>淘宝、天猫首页的UV，平均每天是1~1.5个亿左右</p>
<p>每天存1.5个亿的IP，访问者来了后先去查是否存在，不存在加入</p>
<h5 id="解决方案1：使用Redis的hash存储结构"><a href="#解决方案1：使用Redis的hash存储结构" class="headerlink" title="解决方案1：使用Redis的hash存储结构"></a>解决方案1：使用Redis的hash存储结构</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120756.png" alt="image-20211214112652520"></p>
<h5 id="解决方案2：Redis的hyperLogLog"><a href="#解决方案2：Redis的hyperLogLog" class="headerlink" title="解决方案2：Redis的hyperLogLog"></a>解决方案2：Redis的hyperLogLog</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120757.png" alt="image-20211214112731280"></p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120758.png" alt="image-20211214144535620"></p>
<h4 id="地理位置名词说明"><a href="#地理位置名词说明" class="headerlink" title="地理位置名词说明"></a>地理位置名词说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120759.png" alt="image-20211214112844453"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120800.png" alt="image-20211214112855286"></p>
<h4 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120801.png" alt="image-20211214112940694"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120802.png" alt="image-20211214112955687"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120803.png" alt="image-20211214113009971"></p>
<h4 id="案例：附近的XX"><a href="#案例：附近的XX" class="headerlink" title="案例：附近的XX"></a>案例：附近的XX</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeoController</span><br>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CITY</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;city&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;新增天安门故宫长城经纬度&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/geoadd&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">geoAdd</span><span class="hljs-params">()</span><br>    &#123;<br>        Map&lt;String, Point&gt; map= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;天安门&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">116.403963</span>,<span class="hljs-number">39.915119</span>));<br>        map.put(<span class="hljs-string">&quot;故宫&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">116.403414</span> ,<span class="hljs-number">39.924091</span>));<br>        map.put(<span class="hljs-string">&quot;长城&quot;</span> ,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">116.024067</span>,<span class="hljs-number">40.362639</span>));<br><br>        redisTemplate.opsForGeo().add(CITY,map);<br><br>        <span class="hljs-keyword">return</span> map.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;获取地理位置的坐标&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/geopos&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Point <span class="hljs-title function_">position</span><span class="hljs-params">(String member)</span> &#123;<br>        <span class="hljs-comment">//获取经纬度坐标</span><br>        List&lt;Point&gt; list= <span class="hljs-built_in">this</span>.redisTemplate.opsForGeo().position(CITY,member);<br>        <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;geohash算法生成的base32编码值&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/geohash&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hash</span><span class="hljs-params">(String member)</span> &#123;<br>        <span class="hljs-comment">//geohash算法生成的base32编码值</span><br>        List&lt;String&gt; list= <span class="hljs-built_in">this</span>.redisTemplate.opsForGeo().hash(CITY,member);<br>        <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;计算两个位置之间的距离&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/geodist&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> Distance <span class="hljs-title function_">distance</span><span class="hljs-params">(String member1, String member2)</span> &#123;<br>        Distance distance= <span class="hljs-built_in">this</span>.redisTemplate.opsForGeo().distance(CITY,member1,member2, RedisGeoCommands.DistanceUnit.KILOMETERS);<br>        <span class="hljs-keyword">return</span> distance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过经度，纬度查找附近的</span><br><span class="hljs-comment">     * 北京王府井位置116.418017,39.914402,这里为了方便讲课，故意写死</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiOperation(&quot;通过经度，纬度查找附近的&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/georadius&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> GeoResults <span class="hljs-title function_">radiusByxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//这个坐标是北京王府井位置</span><br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">116.418017</span>, <span class="hljs-number">39.914402</span>, Metrics.MILES.getMultiplier());<br>        <span class="hljs-comment">//返回50条</span><br>        RedisGeoCommands.<span class="hljs-type">GeoRadiusCommandArgs</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(<span class="hljs-number">10</span>);<br>        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; geoResults= <span class="hljs-built_in">this</span>.redisTemplate.opsForGeo().radius(CITY,circle, args);<br>        <span class="hljs-keyword">return</span> geoResults;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过地方查找附近</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiOperation(&quot;通过地方查找附近&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/georadiusByMember&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> GeoResults <span class="hljs-title function_">radiusByMember</span><span class="hljs-params">()</span> &#123;<br>        String member=<span class="hljs-string">&quot;天安门&quot;</span>;<br>        <span class="hljs-comment">//返回50条</span><br>        RedisGeoCommands.<span class="hljs-type">GeoRadiusCommandArgs</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//半径10公里内</span><br>        Distance distance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">10</span>, Metrics.KILOMETERS);<br>        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; geoResults= <span class="hljs-built_in">this</span>.redisTemplate.opsForGeo().radius(CITY,member, distance,args);<br>        <span class="hljs-keyword">return</span> geoResults;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="9-布隆过滤器BloomFilter"><a href="#9-布隆过滤器BloomFilter" class="headerlink" title="9.布隆过滤器BloomFilter"></a>9.布隆过滤器BloomFilter</h2><p>面试题：</p>
<p>现有50亿个电话号码，现有10万个电话号码，如何要快速准确的判断这些电话号码是否已经存在?</p>
<p>1、通过数据库查询——-实现快速有点难。</p>
<p>2、数据预放到内存集合中：50亿*8字节大约40G，内存太大了。</p>
<h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h3><p>布隆过滤器（英语:Bloom Filter）是1970年由布隆提出的。</p>
<p><font color=red><strong>它实际上是一个很长的二进制数组+一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中。</strong></font></p>
<p>通常我们会遇到很多要<code>判断一个元素是否在某个集合中的业务场景，</code>一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。</p>
<p>但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n),O(logn),O(1)。这个时候，布隆过滤器（Bloom Filter）就应运而生</p>
<p><strong>一句话：由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在</strong></p>
<p>本质就是判断具体数据存不存在一个大的集合中</p>
<p>布隆过滤器是一种类似set的数据结构大是统计结果不太准确</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120804.png" alt="image-20211214135758264"></p>
<p>类似一个bit数组</p>
<h3 id="特点和考点"><a href="#特点和考点" class="headerlink" title="特点和考点"></a>特点和考点</h3><p>高效地插入和查询，占用空间少，返回的结果是不确定性的。</p>
<p><font color=red>一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。</font></p>
<p>布隆过滤器<code>可以添加元素,但是不能删除元素。</code></p>
<p>因为删掉元素会导致误判率增加。</p>
<p><code>误判只会发生在过滤器没有添加过的元素</code>，对于添加过的元素不会发生误判。</p>
<p><code>有，很可能有</code></p>
<p><code>无，肯定无</code></p>
<p>使用时<code>最好不要让实际元素数量远大于初始化数量</code></p>
<p>当实际元素数量超过初始化数量时，应该对布隆过滤器进行<code>重建</code>，重新分配一个size更大的过滤器，再将所有的历史元素批量add进行</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="解决缓存穿透的问题"><a href="#解决缓存穿透的问题" class="headerlink" title="解决缓存穿透的问题"></a>解决缓存穿透的问题</h4><p><strong>缓存穿透是什么：</strong></p>
<p>一般情况下，先查询缓存redis是否有该条数据，缓存中没有时，再查询数据库。</p>
<p>当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。</p>
<p>缓存透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。</p>
<p><strong>可以使用布隆过滤器解决缓存穿透的问题：</strong></p>
<p>把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。</p>
<p>当有新的请求时，先到布隆过滤器中查询是否存在:</p>
<p>如果布隆过滤器中不存在该条数据则直接返回;</p>
<p>如果布隆过滤器中己存在，才去查询缓存redis，如果redis里没查询到则穿透到Mysql数据库</p>
<h4 id="黑名单、白名单校验"><a href="#黑名单、白名单校验" class="headerlink" title="黑名单、白名单校验"></a>黑名单、白名单校验</h4><p>发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。</p>
<p>假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。</p>
<p>把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。</p>
<h3 id="Java中的传统hash"><a href="#Java中的传统hash" class="headerlink" title="Java中的传统hash"></a>Java中的传统hash</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120805.png" alt="image-20211214135332966"></p>
<h3 id="布隆过滤器实现原理和数据结构"><a href="#布隆过滤器实现原理和数据结构" class="headerlink" title="布隆过滤器实现原理和数据结构"></a>布隆过滤器实现原理和数据结构</h3><p>实质就是一个<code>大型位数组</code>和<code>几个不同的无偏hash函数</code>(无偏表示分布均匀)。</p>
<p>由一个<code>初值都为零</code>的<code>bit数组</code>和多个个哈希函数构成，用来快速判断某个数据是否存在。</p>
<p>但是跟HyperLogLog一样，它也一样有那么一点点不精确，也存在一定的<code>误判概率</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120806.png" alt="image-20211214135414892"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120807.png" alt="image-20211214135431235"></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1、初始化</p>
<p>2、添加</p>
<p>3、判断是否存在</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120808.png" alt="image-20211214135459093"></p>
<h3 id="为什么不删除"><a href="#为什么不删除" class="headerlink" title="为什么不删除"></a>为什么不删除</h3><p><strong>布隆过滤器误判率，为什么不要删除</strong></p>
<p>布隆过滤器的误判是指多个输入经过哈希之后在相同的bit位置1了，这样就无法判断究竞是哪个输入产生的，</p>
<p>因此<code>误判的根源在于相同的 bit位被多次映射且置1。</code></p>
<p>这种情况也造成了布隆过滤器的删除问题，因为<code>布隆过滤器的每一个 bit并不是独占的，很有可能多个元素共享了某一位。</code></p>
<p><code>如果我们直接删除这一位的话，会影响其他的元素</code></p>
<p><strong>特性：</strong></p>
<p>一个元素判断结果为没有时则一定没有，</p>
<p>如果判断结果为存在的时候元素不一定存在。</p>
<p>布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。</p>
<h3 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h3><p>为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。</p>
<p>论文《Cuckoo Filter:Better Than Bloom》</p>
<p>作者将布谷鸟过滤器和布隆过滤器进行了深入的对比。</p>
<p>相比布谷鸟过滤器而言</p>
<p>布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数</p>
<h2 id="10-缓存雪崩-穿透-击穿"><a href="#10-缓存雪崩-穿透-击穿" class="headerlink" title="10.缓存雪崩/穿透/击穿"></a>10.缓存雪崩/穿透/击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h4><p>发生：</p>
<p>redis主机挂了，Redis 全盘崩溃</p>
<p>比如缓存中数据同时过期</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>redis缓存集群实现高可用，主从+哨兵，Redis Cluster</p>
<p>ehcache本地缓存＋Hystrix或者阿里sentinel限流&amp;降级</p>
<p>开启Redis持久化机制aof/rdb，尽快恢复缓存集群</p>
<img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120809.png" alt="image-20211214140955416" style="zoom:80%;" />

<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h4><p><strong>是什么：</strong></p>
<p>请求去查询头条记录，先redis后mysql发现都查询不到该条记录，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</p>
<p>这个redis变成了一个摆设。。。。。。</p>
<p>简单来说是本来无一物，既不在Redis缓存中，也不在数据库中</p>
<p><strong>危害：</strong></p>
<p>第一次来查询后，一般我们有回写redis机制</p>
<p>第二次来查询的时候redis就有了，偶尔出现穿透现象一般情况无关紧要</p>
<h4 id="产生原因：黑客恶意攻击"><a href="#产生原因：黑客恶意攻击" class="headerlink" title="产生原因：黑客恶意攻击"></a>产生原因：黑客恶意攻击</h4><p>黑客会对你的系统选行攻击，拿一个不存在的id去查询数据会凶生大量的请求到数据库去查询。可能会致你的数据库由于压力过大而宕掉</p>
<p>id相同打你系统</p>
<ul>
<li>第一次打到mysql，空对象缓存后第二次就返回null了，</li>
</ul>
<p>id不同打你系统</p>
<ul>
<li>避免mysql被攻击，不用再到数据库中去走一圈了，由于存在空对象缓存和缓存回写(看自己业务不限死)，redis中的无关紧要的key也会越写越多(<code>记得设置redis过期时间</code>)</li>
</ul>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120810.png" alt="image-20211214144154839"></p>
<h4 id="方案一：空对象缓存"><a href="#方案一：空对象缓存" class="headerlink" title="方案一：空对象缓存"></a>方案一：空对象缓存</h4><p>一旦发生缓存穿透，我们就可以针对查询的数据，在<code>Redis中缓存一个空值</code>或是和业务层协商确定的缺省值(例如，库存的缺省值可以设为0)。</p>
<p>紧接着，应用发送的后续请求再进行查询时，就可以直接从Redis中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</p>
<h4 id="方案二：Guava中布隆过滤器"><a href="#方案二：Guava中布隆过滤器" class="headerlink" title="方案二：Guava中布隆过滤器"></a>方案二：Guava中布隆过滤器</h4><blockquote>
<p><strong>布隆过滤器说明</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120811.png" alt="image-20211214153558803"></p>
<p>Guava中布隆过滤器的实现算是比较权威的，Google出品</p>
<p>所以实际项目中我们不需要手动实现个布隆过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jrebloom布隆过滤器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.redislabs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jrebloom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>简单使用：</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120812.png" alt="image-20211214151632253"></p>
<blockquote>
<p><strong>使用默然参数构建布隆过滤器</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120813.png" alt="image-20211214151745904"></p>
<blockquote>
<p><strong>源码剖析：</strong></p>
</blockquote>
<p>我们首先往布隆过滤器里面加了 100w 条数据</p>
<p>然后我们再拿 10w 个不再布隆过滤器里面的数据进行查询</p>
<p>我们可以看到：</p>
<p><code>Guava为我们创建了 700w 多个（7298440）坑位，默认的 容错率是 0.03 ，使用了 5个 hash算法  </code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120814.png" alt="image-20211214144518693"></p>
<blockquote>
<p><strong>使用自定义参数构建布隆过滤器</strong></p>
</blockquote>
<p>我们首先往布隆过滤器里面加了 100w 条数据</p>
<p>然后我们再拿 10w 个不再布隆过滤器里面的数据进行查询</p>
<p>我们自己指定：<code>误判的参数为 0.01</code></p>
<p>我们可以看到：</p>
<p><code>Guava为我们创建了 900w 多个坑位，使用了 7个 hash算法  </code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120815.png" alt="image-20211214143319169"></p>
<blockquote>
<p><strong>容错率是不是越低越好？</strong></p>
</blockquote>
<p>不是，容错率越低</p>
<p>需要创建的坑位越多</p>
<p>需要使用的hash算法越多</p>
<p><code>效率越低</code></p>
<h4 id="方案三：Redis布隆过滤器解决缓存穿透"><a href="#方案三：Redis布隆过滤器解决缓存穿透" class="headerlink" title="方案三：Redis布隆过滤器解决缓存穿透"></a>方案三：Redis布隆过滤器解决缓存穿透</h4><p>Guava缺点说明：</p>
<p>Guava提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现〉，但是它有一个重大的缺陷就是<code>只能单机使用</code>，而现在互联网一般都是<code>分布式的场景</code></p>
<p>为了解决这个问题，我们就需要用到 <code>Redis 中的布隆过滤器</code>了</p>
<blockquote>
<p><strong>白名单过滤器</strong></p>
</blockquote>
<ul>
<li>白名单架构说明</li>
<li>误判问题，但是概率小可以接受;不能从布隆过滤器删除</li>
<li><font color=red><strong>全部合法的key都需要放入过滤器+redis里面，不然数据就是返回null</strong></font></li>
</ul>
<blockquote>
<p><strong>白名单架构说明</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120816.png" alt="image-20211214152423167"></p>
<blockquote>
<p>代码说明</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120817.png" alt="20211226183321"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120818.png" alt="20211226183321 - 副本"></p>
<blockquote>
<p><strong>重要总结</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120819.png" alt="image-20211214153345709"></p>
<blockquote>
<p>家庭作业思考题：黑名单使用</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120820.png" alt="image-20211214153411073"></p>
<h4 id="Docker安装RedisBloom"><a href="#Docker安装RedisBloom" class="headerlink" title="Docker安装RedisBloom"></a>Docker安装RedisBloom</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120821.png" alt="image-20211214165453823"></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>业务上规避（提前关闭入口，更换数据，留下数据预热时间）</p>
<p>lua脚本保证多条指令一起执行，并不能保证高并发</p>
<h4 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h4><p><strong>是什么：</strong></p>
<p><code>大量的请求同时查询一个key时</code>，<code>此时这个key正好失效了</code>，就会导致大量的请求都打到数据库</p>
<p>简单说就是<code>热点key突然失效</code>了，暴打mysql</p>
<p><strong>危害：</strong></p>
<p>会造成某一时刻数据库请求量过大，压力剧增。</p>
<p><strong>解决：</strong></p>
<p>方案0：业务上规避</p>
<p>方案1：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120822.png" alt="image-20211214165708633"></p>
<p>方案2：对于访问频繁的热点key，干脆就不设置过期时间</p>
<p>方案3：互斥独占锁防止击穿，第一次课就讲解过</p>
<p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。</p>
<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120823.png" alt="image-20211214165848494"></p>
<h4 id="案例：淘宝聚划算"><a href="#案例：淘宝聚划算" class="headerlink" title="案例：淘宝聚划算"></a>案例：淘宝聚划算</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120824.png" alt="image-20211214170219718"></p>
<p>要求：高并发、实时</p>
<h5 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h5><p>1、100%高并发，绝对不可以用mysql实现</p>
<p>2、先把mysql里面参加活动的数据抽取进redis，一般采用定时器扫描来决定上线活动还是下线取消。</p>
<p>3、支持分页功能，一页20条记录</p>
<p>4、请大家思考，redis里面什么样子的数据类型支持上述功能?</p>
<p><font color=red>zset主要多用于做排行榜</font></p>
<p><font color=red>list主要多用于1对N的分页展现，分楼层、分阶段展现</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120825.png" alt="image-20211214170436760"></p>
<h5 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120826.png" alt="image-20211214170823068"></p>
<h4 id="案例：淘宝聚划算【修复BUG】"><a href="#案例：淘宝聚划算【修复BUG】" class="headerlink" title="案例：淘宝聚划算【修复BUG】"></a>案例：淘宝聚划算【修复BUG】</h4><p>存在的问题：</p>
<p>不是原子性的命令，存在热点缓存突然失效的隐患</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120827.png" alt="image-20220110194712109"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120828.png" alt="image-20220110194722911"></p>
<h4 id="定时轮询、互斥更新、差异失效时间"><a href="#定时轮询、互斥更新、差异失效时间" class="headerlink" title="定时轮询、互斥更新、差异失效时间"></a>定时轮询、互斥更新、差异失效时间</h4><p>如何解决缓存击穿</p>
<p>1、新建</p>
<p>开辟两块缓存，主A从B，<code>先更新B再更新A</code>，严格照这个顺序。</p>
<p>2、查询</p>
<p>先查询<code>主缓存A</code>，如果A没有(消失或者失效了)再查询从缓存B。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120829.png" alt="image-20211214170736896"></p>
<h3 id="缓存内容总结"><a href="#缓存内容总结" class="headerlink" title="缓存内容总结"></a>缓存内容总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120830.png" alt="image-20211214164844817"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120831.png" alt="image-20211214171131379"></p>
<h2 id="11-分布式锁"><a href="#11-分布式锁" class="headerlink" title="11.分布式锁"></a>11.分布式锁</h2><h3 id="面试题引入"><a href="#面试题引入" class="headerlink" title="面试题引入"></a>面试题引入</h3><p>Redis除了拿来做缓存，你还见过基于Redis的什么用法?</p>
<p>Redis做分布式锁的时候有需要注意的问题?</p>
<p>如果是Redis是单点部署的，会带来什么问题? 那你准备怎么解决单点问题呢?</p>
<p>集群模式下，比如主从模式，有没有什么问题呢?</p>
<p>你知道Redis是怎么解决集群模式也不靠谱的问题的吗?</p>
<p>那你简单的介绍一下Redlock吧？你简历上写redisson，你谈谈</p>
<p>你觉得Redlock 有什么问题呢?</p>
<p>Redis分布式锁如何续期？看门狗知道吗?</p>
<h3 id="分布式锁理论"><a href="#分布式锁理论" class="headerlink" title="分布式锁理论"></a>分布式锁理论</h3><blockquote>
<p> <strong>锁的种类：</strong></p>
</blockquote>
<p><code>单机版，同一个JVM虚拟机内</code>：synchnonized或者Lock接口</p>
<p><code>分布式，不同个JVM虚拟机内</code>：单机的线程锁机制不再起作用，资源类在不同的服务器之间共享了。</p>
<blockquote>
<p> <strong>一个靠谱的分布式锁需要具备的条件和刚需：</strong></p>
</blockquote>
<p><code>1、独占性</code></p>
<p>onlyone，任何时刻只能有且仅有一个线程持有</p>
<p><code>2、高可用</code></p>
<p>若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况</p>
<p><code>3、防死锁</code></p>
<p>杜绝死锁，必须有超时控制机制或者撤销操作，有个兜底终止跳出方案</p>
<p><code>4、不乱抢</code></p>
<p>防止张冠李戴，不能私下unlock别人的锁，只能自己加锁自己释放。</p>
<p><code>5、重入性</code></p>
<p>同一个节点的同一个线程如果获得锁之后，它也可以再次获取这个锁。</p>
<blockquote>
<p> <strong>Redis中的分布式锁：</strong></p>
</blockquote>
<p><font color=red><strong>差评，setnx+expire不安全，两条命令非原子性的</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120832.png" alt="image-20211215103425722"></p>
<blockquote>
<p><strong>使用场景：</strong></p>
</blockquote>
<p>多个服务间保证同一时刻同一时间段内同一用户只能有一个请求（防止关键业务出现并发攻击）</p>
<p>Redis分布式锁比较正确的姿势是采用redisson这个客户端工具：</p>
<p><code>天上飞的理念(RedLock)</code> 必然有 <code>落地的实现(Redisson)</code></p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP即：</p>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance（分区容忍性）</li>
</ul>
<p>①<strong>一致性：</strong>对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。</p>
<p>②<strong>可用性：</strong>任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。</p>
<p>③<strong>分区容忍性：</strong>由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。</p>
<p><font color=red><strong>对于不同的行业，选择应该不同：</strong></font></p>
<p>互联网公司，要保证高并发，选择 AP，选择使用 Redis集群</p>
<p><code>金融行业，</code>要保证数据一致性，选择 CP，选择使用 Zookeeper集群</p>
<h4 id="Redis单机：CP"><a href="#Redis单机：CP" class="headerlink" title="Redis单机：CP"></a>Redis单机：CP</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120833.png" alt="image-20211215104315299"></p>
<h4 id="Redis集群：AP"><a href="#Redis集群：AP" class="headerlink" title="Redis集群：AP"></a>Redis集群：AP</h4><p><font color=red><strong>异步复制</strong></font></p>
<p>redis异步复制造成的锁丢失，</p>
<p>比如：主节点没来的及把刚刚set进来这条数据给从节点，master就挂了，这个锁的信息就是丢失</p>
<h4 id="Zookeeper集群：CP"><a href="#Zookeeper集群：CP" class="headerlink" title="Zookeeper集群：CP"></a>Zookeeper集群：CP</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120834.png" alt="image-20211215104505381"></p>
<blockquote>
<p>故障：</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120835.png" alt="image-20211215104517923"></p>
<h4 id="Eureka集群：AP"><a href="#Eureka集群：AP" class="headerlink" title="Eureka集群：AP"></a>Eureka集群：AP</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120836.png" alt="image-20211215104614642"></p>
<h3 id="分布式锁演变过程"><a href="#分布式锁演变过程" class="headerlink" title="分布式锁演变过程"></a>分布式锁演变过程</h3><blockquote>
<p>1.单机版没有加锁</p>
</blockquote>
<p>没有加锁，并发下数字不对，出现超卖现象</p>
<p>思考：Synchronized 还是 Reentrantlock 还是都可以</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120837.png" alt="image-20211215103919197"></p>
<blockquote>
<ol start="2">
<li>Nginx环境下，超卖问题</li>
</ol>
</blockquote>
<p>分布式部署后，单机锁还是出现超卖现象，需要分布式锁</p>
<blockquote>
<p>8.lua脚本</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120838.png" alt="image-20211215104140181"></p>
<blockquote>
<p> <strong>代码演进过程【总结】</strong></p>
</blockquote>
<p>1、synchronized单机版oK，上分布式</p>
<p>2、nginx分布式微服务单机锁不行</p>
<p>3、取消单机锁，上Redis分布式锁setnx</p>
<p>4、只加了锁，没有释放锁，出异常的话，可能无法释放锁,必须要在代码层面finally释放锁</p>
<p>5、宕机了，部署了微服务代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间设定</p>
<p>6、为redis的分布式锁key，增加过期时间，此外，还必须要setnx+过期时间必须同一行</p>
<p>7、必须规定只能自己删除自己的锁,你不能把别人的锁删除了，防止张冠李戴，1删2，2删3</p>
<p>8、Redis集群环境下，我们自己写的也不oK直接上RedLock之Redisson落地实现</p>
<h3 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h3><p>三个重要的过程：加锁、解锁、超时</p>
<p><strong>加锁：</strong></p>
<p>加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间</p>
<p><strong>解锁：</strong></p>
<p>将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉，只能自己删除自己的锁</p>
<p>1.当代码块执行完之后，要保证锁能够释放 –&gt; lock.unlock</p>
<p>2.当出现异常情况时，要保证锁能释放 –&gt; try-finally</p>
<p>3.当系统宕机时，要保证锁能释放 –&gt; 设置过期时间</p>
<p>4.要保证释放自己的锁，不能张冠李戴 –&gt; 判断</p>
<p>5.要保证判读的操作和释放锁的操作是原子性的 –&gt; lua脚本</p>
<p><strong>超时：</strong></p>
<p>锁key要注意过期时间，不能长期占用</p>
<p>单机模式中，一般都是用set/setnx+lua脚本搞定，想想它的缺点是什么?</p>
<p>上面一般中小公司，不是高并发场景，是可以使用的。单机redis小业务也撑得住</p>
<p>加锁关键逻辑：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120839.png" alt="image-20211215110023125"></p>
<p>解锁关键逻辑：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120840.png" alt="image-20211215110034801"></p>
<h3 id="多机环境下的问题"><a href="#多机环境下的问题" class="headerlink" title="多机环境下的问题"></a>多机环境下的问题</h3><p>基于setnx的分布式锁有什么缺点?</p>
<p>redis之父提出了Redlock算法解决这个问题</p>
<p>Redlock算法设计理念</p>
<h4 id="基于setnx的分布式锁的缺点"><a href="#基于setnx的分布式锁的缺点" class="headerlink" title="基于setnx的分布式锁的缺点"></a>基于setnx的分布式锁的缺点</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120841.png" alt="image-20211215110134033"></p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>单机redis分布式锁不OK</p>
<p>多机redis集群也不OK,master=slave模式行不通</p>
<p><font color=red><strong>必须多机,但是不是master-slave模式,</strong></font></p>
<p>而是3台或者5台机器，<code>全部是master</code></p>
<p>不要异步同步出现锁丢失，而是<code>全部master</code>，一起获得</p>
<h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120842.png" alt="image-20211215110339693"></p>
<h4 id="ReadLock容错率公式"><a href="#ReadLock容错率公式" class="headerlink" title="ReadLock容错率公式"></a>ReadLock容错率公式</h4><p>redis分布式锁，多主集群模式，它需要计算容错率</p>
<p>N= 2X +1       <code>N(部署台数)=2X(宕机数)+1</code></p>
<p>比如，我网络中死了1台机器，我要求还是OK的，可以用，请问，最多多主集群部署几台? <code>N=2*1+1 =3</code></p>
<p>网络中死了2台机器,我要求还是OK的，可以用，请问，最多多主集群部署几台?  <code>N= 2*2+1=5</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120843.png" alt="image-20211215110427993"></p>
<h4 id="案例：多机器分布式锁"><a href="#案例：多机器分布式锁" class="headerlink" title="案例：多机器分布式锁"></a>案例：多机器分布式锁</h4><p>开启服务</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120844.png" alt="image-20211215135408312"></p>
<p>改pom</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120845.png" alt="image-20211215135436067"></p>
<p>写配置</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120846.png" alt="image-20211215135455049"></p>
<p>配置类</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120847.png" alt="image-20220110194834708"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120848.png" alt="image-20220110194849037"></p>
<p>Controller</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120849.png" alt="image-20211215142611656"></p>
<h4 id="缓存续命"><a href="#缓存续命" class="headerlink" title="缓存续命"></a>缓存续命</h4><p>还记得之前说过的缓存续命吗?</p>
<p>Redis分布式锁过期了，但是业务逻辑还没处理完怎么办</p>
<p><font color=red><strong>守护线程”续命”</strong></font></p>
<ul>
<li><code>额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间。</code></li>
<li>Redisson里面就实现了这个方案，使用<code>“看门狗”定期检查（每1/3的锁时间检查1次）</code>，<code>如果线程还持有锁，则刷新过期时间;</code></li>
</ul>
<p>在获取锁成功后，给锁加一个watchdog，watcadog会起一个<code>定时任务</code>，在锁没有被释放且快要过期的时候会续期</p>
<p>缓存续命</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120850.png" alt="image-20211215142929666"></p>
<p><font color=red><strong>watch dog自动延期机制：</strong></font></p>
<p>客户端A加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间，默认每次续命又从30秒新开始</p>
<p>知不知道缓存续命：知道、看门狗</p>
<p>默认时间是多少：看门狗检查锁的超时时间是30S、每隔10秒回检查一下客户端A是否还持有锁（30S 的 三分之一）</p>
<h3 id="RedLock源码分析"><a href="#RedLock源码分析" class="headerlink" title="RedLock源码分析"></a>RedLock源码分析</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120851.png" alt="image-20211215143128373"></p>
<h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>通过exists判断，如果锁不存在，则设置值和过期时间，加锁成功</p>
<p>通过hexists判断，如果锁已存在，并且锁的是当前线程。则证明是重入锁，加锁成功</p>
<p>如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。</p>
<p>返回当前锁的过期时间(代表了lockzzyy这个锁key的剩余时间)，加锁失败</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120852.png" alt="image-20211215143427692"></p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120853.png" alt="image-20211215143440862"></p>
<h2 id="12-Redis中过期键删除策略"><a href="#12-Redis中过期键删除策略" class="headerlink" title="12.Redis中过期键删除策略"></a>12.Redis中过期键删除策略</h2><p>redli过期键的删除策略</p>
<p>如果一个键是过期的，那它<code>到了过期时间之后</code>是不是马上就从内存中被被删除呢??</p>
<p>如果回答yes，立即删除,你自己走还是面试官送你?</p>
<p>如果不是，那过期后到底什么时候被删除呢?是个什么操作?</p>
<blockquote>
<p>三种不同的删除策略</p>
</blockquote>
<p><code>立即删除：</code></p>
<p>会占用CPU的时间，如果在CPU比较忙的时候，会产生大量的性能消耗，会影响数据的读写操作。</p>
<p><code>惰性删除：</code></p>
<p>数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据，发现已过期，删除，返回不存在。</p>
<p>看作是一种内存泄漏：无用的垃圾数据占用了大量的内存，而服务器却不会主动的删除他们</p>
<p><code>定期删除：</code></p>
<p>每隔一段时间执行一次删除过期键操作，并通过<code>限制删除操作执行的时长和频率</code>来减少删除操作对CPU时间的影响。</p>
<p>采用随机抽取的方式</p>
<blockquote>
<p>上面两种方案都走极端：</p>
</blockquote>
<p>上述步骤都过堂了，还有漏洞吗?</p>
<p>1、定期删除时，从来没有被抽查到<br>2、惰性删除时，也从来没有被点中使用过</p>
<p>上述2步骤===&gt;大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽</p>
<p>redis缓存淘汰策略登场</p>
<h3 id="立即删除"><a href="#立即删除" class="headerlink" title="立即删除"></a>立即删除</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120854.png" alt="image-20211215151742867"></p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120855.png" alt="image-20211215151804566"></p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120856.png" alt="image-20211215151835596"></p>
<h2 id="13-Redis中缓存淘汰策略"><a href="#13-Redis中缓存淘汰策略" class="headerlink" title="13.Redis中缓存淘汰策略"></a>13.Redis中缓存淘汰策略</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120857.png" alt="image-20211215152300308"></p>
<blockquote>
<p>简单总结</p>
</blockquote>
<p>1、不会删除任何key：OOM</p>
<p>2、删除马上要过期的key</p>
<p>3、所有key：LRU</p>
<p>4、设置了过期时间的key：LRU</p>
<p>5、所有key：随机删除</p>
<p>6、设置了过期时间的key：随机删除</p>
<p>7、所有key：LFU</p>
<p>8、设计了过期时间的的key：LFU</p>
<p>LRU：Least Recently Used：最近最少被使用</p>
<p>LFU：Least Frequently Used：最近使用次数最少</p>
<h2 id="14-Redis中源码概述"><a href="#14-Redis中源码概述" class="headerlink" title="14.Redis中源码概述"></a>14.Redis中源码概述</h2><h3 id="从HelloWorld说起"><a href="#从HelloWorld说起" class="headerlink" title="从HelloWorld说起"></a>从HelloWorld说起</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120858.png" alt="image-20211215161606567"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120859.png" alt="image-20211215152421259"></p>
<h3 id="RedisObject说明"><a href="#RedisObject说明" class="headerlink" title="RedisObject说明"></a>RedisObject说明</h3><h4 id="RedisObject结构的作用"><a href="#RedisObject结构的作用" class="headerlink" title="RedisObject结构的作用"></a>RedisObject结构的作用</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120900.png" alt="image-20211215161647870"></p>
<h4 id="RedisObject各个字段的含义"><a href="#RedisObject各个字段的含义" class="headerlink" title="RedisObject各个字段的含义"></a>RedisObject各个字段的含义</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120901.png" alt="image-20211216092201863"></p>
<h4 id="案例：set-age-17"><a href="#案例：set-age-17" class="headerlink" title="案例：set age 17"></a>案例：set age 17</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120902.png" alt="image-20211215161833491"></p>
<h3 id="Redis数据结构和数据类型的关系"><a href="#Redis数据结构和数据类型的关系" class="headerlink" title="Redis数据结构和数据类型的关系"></a>Redis数据结构和数据类型的关系</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120903.png" alt="image-20211215161924126"></p>
<h3 id="Redis源码"><a href="#Redis源码" class="headerlink" title="Redis源码"></a>Redis源码</h3><h4 id="src源码包下的内容"><a href="#src源码包下的内容" class="headerlink" title="src源码包下的内容"></a>src源码包下的内容</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120904.png" alt="image-20211215162128895"></p>
<h3 id="Redis中的KV键值对"><a href="#Redis中的KV键值对" class="headerlink" title="Redis中的KV键值对"></a>Redis中的KV键值对</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120905.png" alt="image-20211215162441763"></p>
<h4 id="上帝视角"><a href="#上帝视角" class="headerlink" title="上帝视角"></a>上帝视角</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120906.png" alt="image-20211215162716163"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120907.png" alt="image-20211215162555005"></p>
<h2 id="15-Redis中的数据类型详解"><a href="#15-Redis中的数据类型详解" class="headerlink" title="15.Redis中的数据类型详解"></a>15.Redis中的数据类型详解</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120908.png" alt="image-20211215161924126"></p>
<h3 id="面试题反馈-1"><a href="#面试题反馈-1" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120909.png" alt="image-20211216092734100"></p>
<p>Redis内部会根据用户给的<code>不同键值而使用不同的编码格式</code>，<code>自适应地选择较优化的内部编码格式</code>，而这一切<code>对用户完全透明</code>！</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>同一个String，底层可以存三种数据结构</p>
<h4 id="三大编码格式"><a href="#三大编码格式" class="headerlink" title="三大编码格式"></a>三大编码格式</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120910.png" alt="image-20211216091954305"></p>
<p><strong>案例说明：</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120911.png" alt="image-20211215161452283"></p>
<h4 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a>C语言中的字符串</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120912.png" alt="image-20211215161255259"></p>
<h4 id="SDS简单动态字符串"><a href="#SDS简单动态字符串" class="headerlink" title="SDS简单动态字符串"></a>SDS简单动态字符串</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120913.png" alt="image-20211215161336070"></p>
<h4 id="Redis为什要设计SDS"><a href="#Redis为什要设计SDS" class="headerlink" title="Redis为什要设计SDS"></a>Redis为什要设计SDS</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120914.png" alt="image-20211215161403770"></p>
<h4 id="三大编码案例"><a href="#三大编码案例" class="headerlink" title="三大编码案例"></a>三大编码案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120915.png" alt="image-20211216092347962"></p>
<h5 id="INT编码格式"><a href="#INT编码格式" class="headerlink" title="INT编码格式"></a>INT编码格式</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120916.png" alt="image-20211216092425635"></p>
<h5 id="EMBSTR编码格式"><a href="#EMBSTR编码格式" class="headerlink" title="EMBSTR编码格式"></a>EMBSTR编码格式</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120917.png" alt="image-20211216092501533"></p>
<h5 id="RAW编码格式"><a href="#RAW编码格式" class="headerlink" title="RAW编码格式"></a>RAW编码格式</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120918.png" alt="image-20211216092529465"></p>
<h5 id="为什么会变成RAW"><a href="#为什么会变成RAW" class="headerlink" title="为什么会变成RAW"></a>为什么会变成RAW</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120919.png" alt="image-20211216092559386"></p>
<h5 id="逻辑转变图"><a href="#逻辑转变图" class="headerlink" title="逻辑转变图"></a>逻辑转变图</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120920.png" alt="image-20211216092625294"></p>
<h5 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120921.png" alt="image-20211216092646512"></p>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p><code>ziplist --&gt; hashlist</code></p>
<p>hash-max-ziplist-entries：使用压缩列表保存时哈希集合中的<code>最大元素个数</code>。</p>
<p>hash-max-ziplist-value：使用压缩列表保存时哈希集合中<code>单个元素的最大长度</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120922.png" alt="image-20211216094934259"></p>
<h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120923.png" alt="image-20211216093154413"></p>
<h4 id="Hash两种编码格式"><a href="#Hash两种编码格式" class="headerlink" title="Hash两种编码格式"></a>Hash两种编码格式</h4><p>1、哈希对象保存的键值对数量小于514个;</p>
<p>2、所有的键值对的健和值的字符串长度都小于等于64byte (一个英文字母一个字节) 时用ziplist，反之用hashtable</p>
<p>3、ziplist升级到hashtable可以，反过来降级不可以</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120924.png" alt="image-20211216093718806"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120925.png" alt="image-20211216093818764"></p>
<h5 id="ziplist-c"><a href="#ziplist-c" class="headerlink" title="ziplist.c"></a>ziplist.c</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120926.png" alt="image-20211216093934047"></p>
<h5 id="ziplist源代码"><a href="#ziplist源代码" class="headerlink" title="ziplist源代码"></a>ziplist源代码</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120927.png" alt="image-20211216094033274"></p>
<h5 id="ziplist组成单元"><a href="#ziplist组成单元" class="headerlink" title="ziplist组成单元"></a>ziplist组成单元</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120928.png" alt="image-20211216094114074"></p>
<h5 id="ziplist存取情况"><a href="#ziplist存取情况" class="headerlink" title="ziplist存取情况"></a>ziplist存取情况</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120929.png" alt="image-20211216094136617"></p>
<h5 id="压缩列表节点构成"><a href="#压缩列表节点构成" class="headerlink" title="压缩列表节点构成"></a>压缩列表节点构成</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120930.png" alt="image-20211216094248705"></p>
<h5 id="zlentry实体结构解析"><a href="#zlentry实体结构解析" class="headerlink" title="zlentry实体结构解析"></a>zlentry实体结构解析</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120931.png" alt="image-20211216094328871"></p>
<h5 id="t-hash-c"><a href="#t-hash-c" class="headerlink" title="t_hash.c"></a>t_hash.c</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120932.png" alt="image-20211216094438738"></p>
<h5 id="OBJ-ENCODING-HT编码"><a href="#OBJ-ENCODING-HT编码" class="headerlink" title="OBJ_ENCODING_HT编码"></a>OBJ_ENCODING_HT编码</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120933.png" alt="image-20211216094450429"></p>
<h4 id="为什要有压缩链表"><a href="#为什要有压缩链表" class="headerlink" title="为什要有压缩链表"></a>为什要有压缩链表</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120934.png" alt="image-20211216094159595"></p>
<h3 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120935.png" alt="image-20211216094625559"></p>
<h4 id="案例说明-1"><a href="#案例说明-1" class="headerlink" title="案例说明"></a>案例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120936.png" alt="image-20211216094637130"></p>
<h4 id="qulicklist结构说明"><a href="#qulicklist结构说明" class="headerlink" title="qulicklist结构说明"></a>qulicklist结构说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120937.png" alt="image-20211216094757592"></p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120938.png" alt="image-20211216094850031"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120939.png" alt="image-20211216094918441"></p>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120940.png" alt="image-20211216095023195"></p>
<h4 id="案例说明-2"><a href="#案例说明-2" class="headerlink" title="案例说明"></a>案例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120941.png" alt="image-20211216095039282"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120942.png" alt="image-20211216095721485"></p>
<h3 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h3><p>ziplist –&gt;跳表</p>
<h4 id="案例说明-3"><a href="#案例说明-3" class="headerlink" title="案例说明"></a>案例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120943.png" alt="image-20211216095135469"></p>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120944.png" alt="image-20211217092436932"></p>
<h3 id="跳表面试题"><a href="#跳表面试题" class="headerlink" title="跳表面试题"></a>跳表面试题</h3><h4 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h4><p>跳表是可以实现二分查找的有序链表</p>
<p>skiplist是一种<code>以空间换取时间的结构</code>。</p>
<p>由于链表，无法进行二分查找，因此借鉴数据库索引的思想，提取出链表中关键节点（索引），先在关键节点上查找，再进入下层链表查找。提取多层关键节点，就形成了跳跃表</p>
<p>时间复杂度是O(logN)</p>
<p>空间复杂度是O(N)</p>
<h4 id="为什么会出现跳表"><a href="#为什么会出现跳表" class="headerlink" title="为什么会出现跳表"></a>为什么会出现跳表</h4><p>痛点</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120945.png" alt="image-20211217093516023"></p>
<p>优化</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120946.png" alt="image-20211217093534433"></p>
<h4 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h4><p>跳表的时间复杂度</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120947.png" alt="image-20211217093545869"></p>
<p>跳表的空间复杂度</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120948.png" alt="image-20211217093554342"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120949.png" alt="image-20211217093718065"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120950.png" alt="image-20211217092521573"></p>
<h4 id="redis数据类型以及数据结构的关系"><a href="#redis数据类型以及数据结构的关系" class="headerlink" title="redis数据类型以及数据结构的关系"></a>redis数据类型以及数据结构的关系</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120951.png" alt="image-20211217092607044"></p>
<h4 id="不同数据类型对应的底层数据结构"><a href="#不同数据类型对应的底层数据结构" class="headerlink" title="不同数据类型对应的底层数据结构"></a>不同数据类型对应的底层数据结构</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120952.png" alt="image-20211217092624715"></p>
<h4 id="redis数据类型以及数据结构的时间复杂度"><a href="#redis数据类型以及数据结构的时间复杂度" class="headerlink" title="redis数据类型以及数据结构的时间复杂度"></a>redis数据类型以及数据结构的时间复杂度</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120953.png" alt="image-20211217092632993"></p>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120954.png" alt="image-20211224135737464"></p>
<p>在低版本的Redis中，list采用的底层数据结构是ziplist+linkedList;</p>
<p>高版本的Redis中底层数据结构是quicklist(它替换了ziplist+linkedList)，而quicklist也用到了ziplist</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120955.png" alt="image-20211224140350885"></p>
<h2 id="16-cannal入门概述"><a href="#16-cannal入门概述" class="headerlink" title="16.cannal入门概述"></a>16.cannal入门概述</h2><h3 id="什么是canal"><a href="#什么是canal" class="headerlink" title="什么是canal"></a>什么是canal</h3><p><font color=red><strong>思考：主流技术栈的演变趋势</strong></font></p>
<p><strong>主流：mysql+hive+hbase</strong></p>
<p><strong>新未来：clickhouse + doris</strong></p>
<h4 id="面试题反馈-2"><a href="#面试题反馈-2" class="headerlink" title="面试题反馈"></a>面试题反馈</h4><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题?</p>
<p>双写一致性，你先动缓存redis还是数据库mysql哪一个? why?</p>
<h4 id="什么是canal-1"><a href="#什么是canal-1" class="headerlink" title="什么是canal"></a>什么是canal</h4><p>canal [ke’nael]，中文翻译为水道/管道/沟渠/运河，主要用途是<code>用于MySQL</code>数据库<code>增量日志数据的订阅、消费和解析</code>，是阿里巴巴开发并开源的，采用Java语言开发;</p>
<p>历史背景是早期阿里巴巴因为杭州和美国双机房部署，存在跨机房数据同步的业务需求，实现方式主要是基于业务trgger (触发器）获取增量变更。从2010年开始，阿里巴巴逐步尝试采用解析数据库日志获取增量变更进行同步，由此衍生出了canal项目</p>
<p><code>效果：mysql改了，被canal组件捕获，立刻完整一致的将写操作，同步给我们的redis缓存源</code></p>
<p>cannal<code>不仅仅能同步给redis缓存源</code>，在业务代码中，也可以同步给 MQ、MongoDB等</p>
<h4 id="cannal能干嘛"><a href="#cannal能干嘛" class="headerlink" title="cannal能干嘛"></a>cannal能干嘛</h4><p>数据库镜像</p>
<p>数据库实时备份</p>
<p>索引构建和实时维护(拆分异构索引、倒排索引等)</p>
<p>业务cache 刷新</p>
<p>带业务逻辑的增量数据处理</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120956.png" alt="image-20211217094431364"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120957.png" alt="image-20211217094455586"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120958.png" alt="image-20211217094503853"></p>
<h3 id="配置使用-案例"><a href="#配置使用-案例" class="headerlink" title="配置使用/案例"></a>配置使用/案例</h3><h4 id="mysql配置"><a href="#mysql配置" class="headerlink" title="mysql配置"></a>mysql配置</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226120959.png" alt="image-20220110194245107"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121000.png" alt="image-20220110194239906"></p>
<h4 id="canal服务端配置"><a href="#canal服务端配置" class="headerlink" title="canal服务端配置"></a>canal服务端配置</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121001.png" alt="image-20211220095210306"></p>
<h4 id="cannal客户端配置"><a href="#cannal客户端配置" class="headerlink" title="cannal客户端配置"></a>cannal客户端配置</h4><p><font color=red><strong>编写业务代码</strong></font></p>
<h2 id="17-双写一致性工程案例"><a href="#17-双写一致性工程案例" class="headerlink" title="17.双写一致性工程案例"></a>17.双写一致性工程案例</h2><h3 id="微信抢红包案例"><a href="#微信抢红包案例" class="headerlink" title="微信抢红包案例"></a>微信抢红包案例</h3><h4 id="微信抢红包业务分析"><a href="#微信抢红包业务分析" class="headerlink" title="微信抢红包业务分析"></a>微信抢红包业务分析</h4><h4 id="微信抢红包案例总结"><a href="#微信抢红包案例总结" class="headerlink" title="微信抢红包案例总结"></a>微信抢红包案例总结</h4><h2 id="18-双写一致性更新策略"><a href="#18-双写一致性更新策略" class="headerlink" title="18.双写一致性更新策略"></a>18.双写一致性更新策略</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121002.png" alt="image-20211217095500574"></p>
<blockquote>
<p><strong>几种更新策略：</strong></p>
</blockquote>
<p>0、挂牌报错，凌晨升级：单线程，这样重量级的数据操作最好不要多线程</p>
<p>1、先更新数据库，再更新缓存</p>
<p>2、先删除缓存，再更新数据库</p>
<p>3、先更新数据库，再删除缓存</p>
<p>4、不许问：先更新缓存，再更新数据库这种策略</p>
<h3 id="目的：最终一致性"><a href="#目的：最终一致性" class="headerlink" title="目的：最终一致性"></a>目的：最终一致性</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121003.png" alt="image-20211217095623337"></p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p>低并发，写回旧值</p>
<p>高并发，缓存击穿</p>
<h4 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121004.png" alt="image-20211217095938031"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121005.png" alt="image-20211217100028808"></p>
<h4 id="异常总结"><a href="#异常总结" class="headerlink" title="异常总结"></a>异常总结</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121006.png" alt="image-20211217100044242"></p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="复习阿里缓存击穿方案"><a href="#复习阿里缓存击穿方案" class="headerlink" title="复习阿里缓存击穿方案"></a>复习阿里缓存击穿方案</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121007.png" alt="image-20211217100159765"></p>
<h5 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121008.png" alt="image-20211217100232534"></p>
<h5 id="延时双删面试题"><a href="#延时双删面试题" class="headerlink" title="延时双删面试题"></a>延时双删面试题</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121009.png" alt="image-20211217100317217"></p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><h4 id="异常问题-1"><a href="#异常问题-1" class="headerlink" title="异常问题"></a>异常问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121010.png" alt="image-20211217101033544"></p>
<h4 id="业务指导思想"><a href="#业务指导思想" class="headerlink" title="业务指导思想"></a>业务指导思想</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121011.png" alt="image-20211217101209601"></p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121012.png" alt="image-20211217101234824"></p>
<h3 id="不许问：先更新缓存，再更新数据库这种策略"><a href="#不许问：先更新缓存，再更新数据库这种策略" class="headerlink" title="不许问：先更新缓存，再更新数据库这种策略"></a>不许问：先更新缓存，再更新数据库这种策略</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="最终目的"><a href="#最终目的" class="headerlink" title="最终目的"></a>最终目的</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121013.png" alt="image-20211217101308108"></p>
<h4 id="方案2和3的取舍"><a href="#方案2和3的取舍" class="headerlink" title="方案2和3的取舍"></a>方案2和3的取舍</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121014.png" alt="image-20211217101328751"></p>
<h4 id="一图总结"><a href="#一图总结" class="headerlink" title="一图总结"></a>一图总结</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121015.png" alt="image-20211217101351173"></p>
<h2 id="19-I-O多路复用模型"><a href="#19-I-O多路复用模型" class="headerlink" title="19.I/O多路复用模型"></a>19.I/O多路复用模型</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121016.png" alt="image-20211220095649708"></p>
<h3 id="Redis单线程如何处理并发客户端连接"><a href="#Redis单线程如何处理并发客户端连接" class="headerlink" title="Redis单线程如何处理并发客户端连接"></a>Redis单线程如何处理并发客户端连接</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121017.png" alt="image-20211220100000938"></p>
<h3 id="参考Redis设计与实现"><a href="#参考Redis设计与实现" class="headerlink" title="参考Redis设计与实现"></a>参考Redis设计与实现</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121018.png" alt="image-20211220100119892"></p>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121019.png" alt="20211231170055"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121020.png" alt="20211231170055 - 副本"></p>
<h3 id="Unix中的五种IO编程模型"><a href="#Unix中的五种IO编程模型" class="headerlink" title="Unix中的五种IO编程模型"></a>Unix中的五种IO编程模型</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121021.png" alt="20211226183755"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121022.png" alt="20211226183755 - 副本"></p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121023.png" alt="image-20211220100259829"></p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121024.png" alt="image-20211220100400099"></p>
<h4 id="五种IO模型总结"><a href="#五种IO模型总结" class="headerlink" title="五种IO模型总结"></a>五种IO模型总结</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121025.png" alt="image-20211220100710792"></p>
<h3 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121026.png" alt="image-20211220100801144"></p>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121027.png" alt="image-20211220100816226"></p>
<h4 id="FileDescriptor和说人话"><a href="#FileDescriptor和说人话" class="headerlink" title="FileDescriptor和说人话"></a>FileDescriptor和说人话</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121028.png" alt="image-20211220100845977"></p>
<h4 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121029.png" alt="image-20211220100934897"></p>
<h4 id="Reactor设计模式"><a href="#Reactor设计模式" class="headerlink" title="Reactor设计模式"></a>Reactor设计模式</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121030.png" alt="image-20211220101017787"></p>
<h4 id="Redis为什么是单线程"><a href="#Redis为什么是单线程" class="headerlink" title="Redis为什么是单线程"></a>Redis为什么是单线程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121031.png" alt="image-20211220101048287"></p>
<h2 id="20-I-O多路复用具体实现"><a href="#20-I-O多路复用具体实现" class="headerlink" title="20.I/O多路复用具体实现"></a>20.I/O多路复用具体实现</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121032.png" alt="image-20211220101215537"></p>
<h3 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121033.png" alt="image-20220110194457995"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121034.png" alt="image-20220110194505372"></p>
<h4 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121035.png" alt="image-20211220101317194"></p>
<h4 id="epoll方法"><a href="#epoll方法" class="headerlink" title="epoll方法"></a>epoll方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121036.png" alt="image-20211220101416232"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121037.png" alt="image-20211220101444623"></p>
<h4 id="三个方法对比"><a href="#三个方法对比" class="headerlink" title="三个方法对比"></a>三个方法对比</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121038.png" alt="image-20211220101503713"></p>
<h4 id="为什么三个都保留"><a href="#为什么三个都保留" class="headerlink" title="为什么三个都保留"></a>为什么三个都保留</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121039.png" alt="image-20211220101543466"></p>
<h2 id="21-课程总结-感悟"><a href="#21-课程总结-感悟" class="headerlink" title="21.课程总结/感悟"></a>21.课程总结/感悟</h2><h2 id="以下是对Redis不熟悉的内容补充"><a href="#以下是对Redis不熟悉的内容补充" class="headerlink" title="==以下是对Redis不熟悉的内容补充"></a>==以下是对Redis不熟悉的内容补充</h2><h2 id="22-事务"><a href="#22-事务" class="headerlink" title="22.事务"></a>22.事务</h2><p><a href="http://www.redis.cn/topics/transactions.html">事务官方文档</a></p>
<h3 id="是什么-能干嘛"><a href="#是什么-能干嘛" class="headerlink" title="是什么/能干嘛"></a>是什么/能干嘛</h3><p>是什么：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p>
<p>能干嘛：一个队列中，一次性、顺序性、排他性的执行一系列命令。</p>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行所有事务块内的命令。</td>
</tr>
<tr>
<td>MULTI</td>
<td>标记一个事务块的开始。</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
</tbody></table>
<h4 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121040.png" alt="image-20211224142020039"></p>
<h4 id="watch监控"><a href="#watch监控" class="headerlink" title="watch监控"></a>watch监控</h4><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。<a href="http://www.redis.cn/topics/transactions.html">link</a></p>
<blockquote>
<p>悲观锁/乐观锁/CAS(Check And Set)</p>
</blockquote>
<ul>
<li>悲观锁<ul>
<li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
</ul>
</li>
<li>乐观锁<ul>
<li>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</li>
<li>乐观锁策略:提交版本必须大于记录当前版本才能执行更新</li>
</ul>
</li>
<li>CAS</li>
</ul>
<h4 id="信用卡可用余额和欠额"><a href="#信用卡可用余额和欠额" class="headerlink" title="信用卡可用余额和欠额"></a>信用卡可用余额和欠额</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226121041.png" alt="image-20211224142800807"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变， 比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化， EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</li>
</ul>
<h3 id="总结：三阶段-三特性"><a href="#总结：三阶段-三特性" class="headerlink" title="总结：三阶段/三特性"></a>总结：三阶段/三特性</h3><h4 id="3阶段"><a href="#3阶段" class="headerlink" title="3阶段"></a>3阶段</h4><ul>
<li>开启：以MULTI开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由EXEC命令触发事务</li>
</ul>
<h4 id="3特性"><a href="#3特性" class="headerlink" title="3特性"></a>3特性</h4><ul>
<li><strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li><strong>不保证原子性</strong>：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<p>不遵循传统的ACID中的AI</p>
<h2 id="23-消息订阅发布简介"><a href="#23-消息订阅发布简介" class="headerlink" title="23.消息订阅发布简介"></a>23.消息订阅发布简介</h2><p><strong>用观察者模式理解学习</strong></p>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzMxLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5SZWRpcy9yYXcvbWFzdGVyL2ltYWdlLzMyLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SUBSCRIBE redisChat<br><br><span class="hljs-function"><span class="hljs-title">Reading</span></span> messages... (press Ctrl-C to quit)<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;subscribe&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;redisChat&quot;</span><br><span class="hljs-number">3</span>) (<span class="hljs-keyword">integer</span>) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">redis</span> <span class="hljs-number">127.0.0.1:6379</span>&gt; PUBLISH redisChat <span class="hljs-string">&quot;Redis is a great caching technique&quot;</span><br><br>(integer) <span class="hljs-number">1</span><br><br>redis <span class="hljs-number">127.0.0.1:6379</span>&gt; PUBLISH redisChat <span class="hljs-string">&quot;Learn redis by runoob.com&quot;</span><br><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 订阅者的客户端会显示如下消息</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;redisChat&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;Redis is a great caching technique&quot;</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;redisChat&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;Learn redis by runoob.com&quot;</span><br></code></pre></td></tr></table></figure>

<p>订阅多个通配符 *</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">PSUBSCRIBE <span class="hljs-keyword">new</span><span class="hljs-type"></span>*<br></code></pre></td></tr></table></figure>

<p>收取消息，</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">PUBLISH <span class="hljs-keyword">new</span><span class="hljs-type">1</span> redis2015<br></code></pre></td></tr></table></figure>

<h2 id="24-Jedis实现事务"><a href="#24-Jedis实现事务" class="headerlink" title="24.Jedis实现事务"></a>24.Jedis实现事务</h2><h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Response;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Transaction;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>		<span class="hljs-comment">// 监控key，如果该动了事务就被放弃</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 3 jedis.watch(&quot;serialNum&quot;); jedis.set(&quot;serialNum&quot;,&quot;s#####################&quot;);</span><br><span class="hljs-comment">		 * jedis.unwatch();</span><br><span class="hljs-comment">		 */</span><br><br>		<span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<span class="hljs-comment">// 被当作一个命令进行执行</span><br>		Response&lt;String&gt; response = transaction.get(<span class="hljs-string">&quot;serialNum&quot;</span>);<br>		transaction.set(<span class="hljs-string">&quot;serialNum&quot;</span>, <span class="hljs-string">&quot;s002&quot;</span>);<br>		response = transaction.get(<span class="hljs-string">&quot;serialNum&quot;</span>);<br>		transaction.lpush(<span class="hljs-string">&quot;list3&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>		transaction.lpush(<span class="hljs-string">&quot;list3&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>		transaction.lpush(<span class="hljs-string">&quot;list3&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br><br>		transaction.exec();<br>		<span class="hljs-comment">// 2 transaction.discard();</span><br>		System.out.println(<span class="hljs-string">&quot;serialNum***********&quot;</span> + response.get());<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Transaction;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTX</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>		<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>		<span class="hljs-type">int</span> balance;<span class="hljs-comment">// 可用余额</span><br>		<span class="hljs-type">int</span> debt;<span class="hljs-comment">// 欠额</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">amtToSubtract</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">// 实刷额度</span><br><br>		jedis.watch(<span class="hljs-string">&quot;balance&quot;</span>);<br>		<span class="hljs-comment">// jedis.set(&quot;balance&quot;,&quot;5&quot;);//此句不该出现，讲课方便。模拟其他程序已经修改了该条目</span><br>		Thread.sleep(<span class="hljs-number">7000</span>);<br>		balance = Integer.parseInt(jedis.get(<span class="hljs-string">&quot;balance&quot;</span>));<br>		<span class="hljs-keyword">if</span> (balance &lt; amtToSubtract) &#123;<br>			jedis.unwatch();<br>			System.out.println(<span class="hljs-string">&quot;modify&quot;</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			System.out.println(<span class="hljs-string">&quot;***********transaction&quot;</span>);<br>			<span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<br>			transaction.decrBy(<span class="hljs-string">&quot;balance&quot;</span>, amtToSubtract);<br>			transaction.incrBy(<span class="hljs-string">&quot;debt&quot;</span>, amtToSubtract);<br>			transaction.exec();<br>			balance = Integer.parseInt(jedis.get(<span class="hljs-string">&quot;balance&quot;</span>));<br>			debt = Integer.parseInt(jedis.get(<span class="hljs-string">&quot;debt&quot;</span>));<br><br>			System.out.println(<span class="hljs-string">&quot;*******&quot;</span> + balance);<br>			System.out.println(<span class="hljs-string">&quot;*******&quot;</span> + debt);<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通俗点讲，watch命令就是标记一个键，如果标记了一个键， 在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中 重新再尝试一次。</span><br><span class="hljs-comment">	 * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减； 足够的话，就启动事务进行更新操作，</span><br><span class="hljs-comment">	 * 如果在此期间键balance被其它人修改， 那在提交事务（执行exec）时就会报错， 程序中通常可以捕获这类错误再重新执行一次，直到成功。</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>		<span class="hljs-type">TestTX</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestTX</span>();<br>		<span class="hljs-type">boolean</span> <span class="hljs-variable">retValue</span> <span class="hljs-operator">=</span> test.transMethod();<br>		System.out.println(<span class="hljs-string">&quot;main retValue-------: &quot;</span> + retValue);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis6</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式01-创建型模式</title>
    <url>/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式-创建型模式"><a href="#设计模式-创建型模式" class="headerlink" title="设计模式 | 创建型模式"></a>设计模式 | 创建型模式</h1><h2 id="创建型模式总览"><a href="#创建型模式总览" class="headerlink" title="创建型模式总览"></a>创建型模式总览</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 </p>
<p>单例模式：用来创建全局唯一的对象。</p>
<p>工厂模式：用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式：用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>原型模式：针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>实战案例一：处理资源访问冲突 </p>
<p>实战案例二：表示全局唯一类</p>
<p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>配置信息类：在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。 </p>
<p>唯一递增 ID 号码生成器：（区分：唯一 ID 生成器 和 唯一递增 ID 生成器）如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>SpringIoC中注入的bean，如果没有额外配置，默认是单例</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>饿汉式、懒汉式、双重检测实现方式</p>
<p>静态内部类、枚举</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建不同但是相关类型的对象（继 承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>简单工厂：</strong></p>
<p>我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<p>简单工厂模式的第一种实现方法：</p>
<p>简单工厂模式的第二种实现方法： </p>
<p>如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p>
<p><strong>工厂方法：</strong></p>
<p>简化简单工厂中的 if-else 逻辑，使用多态的方法实现</p>
<p><strong>抽象工厂：</strong></p>
<p>没有前两种常用，在简单工厂和工厂方法中，类只有一种分类方式。</p>
<p>抽象工厂让一个工厂负责创建多个不同类型的对象，而不是只创建一种对象。这样就可以有效地减少工厂类的个数。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Spring中的BeanFactory</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>简单工厂、工厂方法、抽象工厂</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<hr>
<p>当我们创建对象的时候，需要传递的参数很多，构造函数列表冗长，代码的可读性和易用性会变差</p>
<p>使用set方法设置，那么校验这些必填项是否已经填写的逻辑就无处安放</p>
<p>除此之外，假设配置项之间有一定的依赖关系，设置一个属性之后，必须要显示的设置另外几个（例如：更新余额之后，设置最后的更新时间）</p>
<p>或者创建对象时，配置项之间有一定的约束条件（例如：min &lt;= mid &lt;= max）</p>
<p>同时，我们希望创建的类的对象是不可变对象，即不能在这个类中暴露 set 方法</p>
<p>那么，我们可以，把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。</p>
<p>但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。</p>
<p>如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
<p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
<p>把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。</p>
<blockquote>
<p>创建对象的几种方式：</p>
</blockquote>
<p>（1）使用构造函数或者配合 set 方法</p>
<p>（2）使用建造者模式创建对象</p>
<p>（3）使用工厂模式创建对象</p>
<p><strong>Q：使用构造函数或者配合 set 方法就能创建对象，为什么还要用建造者模式</strong></p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p><strong>Q：建造者模式 和 工厂模式 有什么区别</strong></p>
<p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别： </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。</p>
<p><strong>Q：什么是对象创建成本比较大？</strong></p>
<p>从数据库中读取数据创建对象、创建对象时需要经过经过大量的计算</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>浅拷贝：clone</p>
<p>深拷贝：BeanUtils、递归拷贝对象和对象引用、先序列化再反序列化成新的对象</p>
<h2 id="Ex：创建对象的几种方式"><a href="#Ex：创建对象的几种方式" class="headerlink" title="Ex：创建对象的几种方式"></a>Ex：创建对象的几种方式</h2><p>1、使用 new 关键字创建对象：</p>
<p>这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造函数（无参的和有参的）。比如：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Student student <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>2、反射：使用Class类的newInstance方法：</p>
<p>我们也可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：`</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Student student2 = (Student)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;根路径.Student&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;　<br></code></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> Student.class.newInstance();<br></code></pre></td></tr></table></figure>

<p>3、反射：使用Constructor类的newInstance方法</p>
<p>本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。</p>
<p>我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Constructor&lt;Student&gt; constructor = Student.class.getInstance(); <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> constructor.newInstance();　<br></code></pre></td></tr></table></figure>

<p>这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
<p>这也是众多框架Spring、Hibernate、Struts等使用后者的原因。</p>
<p>4、使用Clone的方法：</p>
<p>无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> &lt;Student&gt;stu.clone();<br></code></pre></td></tr></table></figure>

<p>这也是原型模式的应用。</p>
<p>5、使用反序列化：</p>
<p>当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.obj&quot;</span>)); <br><span class="hljs-type">Student</span> <span class="hljs-variable">stu3</span> <span class="hljs-operator">=</span> (Student)in.readObject();<br></code></pre></td></tr></table></figure>



<p>6、另外：两种newInstance方法有没有区别？  </p>
<p>Class类位于java的lang包中，而构造器类是java反射机制的一部分。</p>
<p>Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。</p>
<p>Class类的newInstance需要其构造方法是共有的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。</p>
<p>Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常。</p>
<p>Class类本质上调用了反射包构造器类中无参数的newInstance方法，捕获了InvocationTargetException，将构造器本身的异常抛出。</p>
<h1 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="实战案例一：处理资源访问冲突"><a href="#实战案例一：处理资源访问冲突" class="headerlink" title="实战案例一：处理资源访问冲突"></a>实战案例一：处理资源访问冲突</h3><p>在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        writer.write(mesasge);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Logger类的应用示例：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(username + <span class="hljs-string">&quot; logined!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(OrderVo order)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(<span class="hljs-string">&quot;Created an order: &quot;</span> + order.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>存在的问题：</p>
</blockquote>
<p>所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。</p>
<p>在 UserController 和 OrderController 中，我们分别创 建两个 Logger 对象。</p>
<p>在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时 分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存 在日志信息互相覆盖的情况。</p>
<blockquote>
<p>解决方案1：加对象锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被 强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同 的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p>
<blockquote>
<p>解决方案2：加类锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Logger.class) &#123; <span class="hljs-comment">// 类级别的锁</span><br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之 间同时调用 log() 函数，而导致的日志覆盖问题。</p>
<blockquote>
<p>其他解决方案：</p>
</blockquote>
<p>分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易 的事情。</p>
<p>除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题： 多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志 文件。这种方式实现起来也稍微有点复杂。 </p>
<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁 的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句 柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>
<h3 id="实战案例二：表示全局唯一类"><a href="#实战案例二：表示全局唯一类" class="headerlink" title="实战案例二：表示全局唯一类"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以 对象的形式存在，也理所应当只有一份。 </p>
<p>再比如，唯一递增 ID 号码生成器（区分：唯一 ID 生成器 和 唯一递增 ID 生成器），如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br>	<span class="hljs-comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br>	<span class="hljs-comment">// 比如下面会用到的incrementAndGet().</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-comment">// IdGenerator使用举例</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； </p>
<p>考虑对象创建时的线程安全问题； </p>
<p>考虑是否支持延迟加载； </p>
<p>考虑 getInstance() 性能是否高（是否加锁）。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存 多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行 为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。 </p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化 过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作， 会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作， 提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问 题。 </p>
<p>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程 序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一 段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优势是支持延迟加载</p>
<p>缺点也很明显，我们给 getInstance() 这个方法加了一把大锁 （synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于 串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用 到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低 等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>
<h4 id="双端检索"><a href="#双端检索" class="headerlink" title="双端检索"></a>双端检索</h4><p>既支持延迟 加载、又支持高并发的单例实现方式，也就是双重检测实现方式。 在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(IdGenerator.class) &#123; <span class="hljs-comment">// 此处为类级别的锁</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻 辑），就被另一个线程使用了。 </p>
<p>要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p>
<p>实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作 设计为原子操作，就自然能禁止重排序）。</p>
<p>关于这点的详细解释，跟特定语言有关，我就不 展开讲了，感兴趣的同学可以自行研究一下。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>比双重检测更加简单，利用 Java 的静态内部类，有点 类似饿汉式，但又能做到了延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>









<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p><strong>单例的定义</strong></p>
<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p><strong>单例的用处</strong></p>
<p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p>
<p><strong>单例的实现</strong></p>
<p>单例有下面几种经典的实现方式。</p>
<p><strong>饿汉式</strong></p>
<p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p>
<p><strong>懒汉式</strong></p>
<p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p>
<p><strong>双重检测实现方式</strong></p>
<p>既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<p><strong>静态内部类</strong></p>
<p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p>
<p><strong>枚举</strong></p>
<p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<h2 id="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h2><h3 id="单例存在哪些问题"><a href="#单例存在哪些问题" class="headerlink" title="单例存在哪些问题?"></a>单例存在哪些问题?</h3><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。</p>
<p>单例模式书写简洁、使用方便，在代码中，我们不需要创建 对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。</p>
<p>但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体 看看到底有哪些问题。 </p>
<h4 id="1-单例对-OOP-特性的支持不友好"><a href="#1-单例对-OOP-特性的支持不友好" class="headerlink" title="1.单例对 OOP 特性的支持不友好"></a>1.单例对 OOP 特性的支持不友好</h4><p>单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来 讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">//...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">// ...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要 修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>
<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词， 而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是 实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计， 会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多 态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>
<h4 id="2-单例会隐藏类之间的依赖关系"><a href="#2-单例会隐藏类之间的依赖关系" class="headerlink" title="2.单例会隐藏类之间的依赖关系"></a>2.单例会隐藏类之间的依赖关系</h4><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间 的依赖关系，搞清楚这个类依赖了哪些外部类。 通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。</p>
<p>但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需 要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>
<h4 id="3-单例对代码的扩展性不友好"><a href="#3-单例对代码的扩展性不友好" class="headerlink" title="3.单例对代码的扩展性不友好"></a>3.单例对代码的扩展性不友好</h4><p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例 或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类 大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p>
<p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。 </p>
<p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资 源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p>
<p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例 类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源 池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设 计成单例类。</p>
<h4 id="4-单例对代码的可测试性不友好"><a href="#4-单例对代码的可测试性不友好" class="headerlink" title="4.单例对代码的可测试性不友好"></a>4.单例对代码的可测试性不友好</h4><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。 </p>
<p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上 相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是 说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用 例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>
<h5 id="5-单例不支持有参数的构造函数"><a href="#5-单例不支持有参数的构造函数" class="headerlink" title="5.单例不支持有参数的构造函数"></a>5.单例不支持有参数的构造函数</h5><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来 指定连接池的大小。</p>
<p>针对这个问题，我们来看下都有哪些解决方案。 </p>
<p>第一种解决思路是：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在 使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = paramA;<br>        <span class="hljs-built_in">this</span>.paramB = paramB;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Run init() first.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Singleton has been created!&quot;</span>);<br>        &#125;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(paramA, paramB);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br>Singleton.init(<span class="hljs-number">10</span>,<span class="hljs-number">50</span>); <span class="hljs-comment">// 先init，再使用</span><br>Singleton singleton=Singleton.getInstance();<br></code></pre></td></tr></table></figure>

<p>第二种解决思路是：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>= null;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramA;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramB;<br>   <span class="hljs-keyword"> private</span> Singleton(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    &#125;<br>   <span class="hljs-keyword"> public</span> synchronized<span class="hljs-keyword"> static</span> Singleton getInstance(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton(paramA, paramB);<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br>Singleton singleton = Singleton.getInstance(10, 50);<br></code></pre></td></tr></table></figure>

<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提 示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的 解决思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>

<p>第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一 个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态 常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fianl <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">245</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = Config.PARAM_A;<br>        <span class="hljs-built_in">this</span>.paramB = Config.PARAM_B;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有何替代方案"><a href="#有何替代方案" class="headerlink" title="有何替代方案"></a>有何替代方案</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常 用到的一种实现思路。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 静态方法实现方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGenerator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> id.<span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">long</span> id = IdGenerator.getId();<br></code></pre></td></tr></table></figure>

<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。</p>
<p>我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一个种使用方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 1. 老的使用方式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">long</span> id = IdGenerator.getInstance().getId();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// 2. 新的使用方式：依赖注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>(<span class="hljs-params">IdGenerator idGenerator</span>)</span> &#123;<br>    <span class="hljs-built_in">long</span> id = idGenerator.getId();<br>&#125;<br><span class="hljs-comment">// 外部调用demofunction()的时候，传入idGenerator</span><br>IdGenerator idGenerator = IdGenerator.getInsance();<br>demofunction(idGenerator);<br></code></pre></td></tr></table></figure>

<p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传 递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其 他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。 </p>
<p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实 际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强 制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程 序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。 </p>
<p>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面的章节中讲解。</p>
<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>1.单例存在哪些问题？</p>
<p>单例对 OOP 特性的支持不友好</p>
<p>单例会隐藏类之间的依赖关系</p>
<p>单例对代码的扩展性不友好</p>
<p>单例对代码的可测试性不友好</p>
<p>单例不支持有参数的构造函数</p>
<p>2.单例有什么替代解决方案？</p>
<p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p>
<p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<h2 id="单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？"><a href="#单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？" class="headerlink" title="单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？"></a>单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？</h2><h3 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h3><h3 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h3><h3 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h3><h3 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h3><h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>今天的内容比较偏理论，在实际的项目开发中，没有太多的应用。讲解的目的，主要还是拓展你的思路，锻炼你的逻辑思维能力，加深你对单例的认识。</p>
<p>1.如何理解单例模式的唯一性？</p>
<p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<p>2.如何实现线程唯一的单例？</p>
<p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<p>3.如何实现集群环境下的单例？</p>
<p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p>4.如何实现一个多例模式？</p>
<p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p>
<h1 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h2><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过， 在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以 工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所 以，在今天的讲解中，我们沿用第一种分类方法。</p>
<h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。 </p>
<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath)<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>		<span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。</p>
<p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfig<br>        <span class="hljs-title function_">if</span> <span class="hljs-params">(parser == <span class="hljs-literal">null</span>)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时 候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>        &#125;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解 中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作 简单工厂模式的第二种实现方法。 </p>
<h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按 照多态的实现思路，对上面的代码进行重构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFact</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需 要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模 式比起简单工厂模式更加符合开闭原则。</p>
<p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong> </p>
<p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻 辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不 复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。 </p>
<p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。</p>
<p>抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。 </p>
<p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析 器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方 式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br>针对系统配置的解析器：基于接口I<span class="hljs-params">System</span>ConfigParser<br>Json<span class="hljs-params">System</span>ConfigParser<br>Xml<span class="hljs-params">System</span>ConfigParser<br>Yaml<span class="hljs-params">System</span>ConfigParser<br>Properties<span class="hljs-params">System</span>ConfigParser<br></code></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编 写一个工厂类，也就是要编写 8 个工厂类。</p>
<p>如果我们未来还需要增加针对业务配置的解析 器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。</p>
<p>而我们知道，过多的类 也会让系统难维护。这个问题该怎么解决呢？ </p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类 型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>();<br>    <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>();<br><span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景 进行总结。 </p>
<p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>
<p>何为创建逻辑比较复杂呢？我总结了下面两种情况。 </p>
<ul>
<li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。 </p>
</li>
<li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中</p>
</li>
</ul>
<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p>
<p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。 </p>
<p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不 要使用工厂模式的最本质的参考标准。 </p>
<ul>
<li><p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。 </p>
</li>
<li><p>代码复用：创建代码抽离到独立的工厂类之后可以复用。 </p>
</li>
<li><p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 </p>
</li>
<li><p>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</p>
</li>
</ul>
<h2 id="工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>工厂模式（下）：如何设计实现一个Dependency Injection框架？</h2><h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获 取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周 期管理。 </p>
<blockquote>
<p>首先，我们来看配置解析。 </p>
</blockquote>
<p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类 代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事 先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。</p>
<p>所 以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲 的配置。 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提 供的信息来创建对象</p>
<p>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创 建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依 赖 redisCounter。</p>
<blockquote>
<p>其次，我们再来看对象创建。 </p>
</blockquote>
<p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加， 这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。</p>
<p>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码 量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我 们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事 先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。 </p>
<p>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加 载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对 象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。 但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运 行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自 动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</p>
<blockquote>
<p>最后，我们来看对象的生命周期管理。 </p>
</blockquote>
<p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一 种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。</p>
<p>在 Spring 框架中，我 们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返 回新创建的对象，scope=singleton 表示返回单例对象。 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用 到的时候（比如:BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。 </p>
<p>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对 象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之 前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数 据库连接池、关闭文件。</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。但是，大 部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当 然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂 的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直 接影响到我们排查问题的效率。 </p>
<p>今天，我们讲解了一个简单的 DI 容器的实现原理，其核心逻辑主要包括：配置文件解析， 以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在 学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程 序员聚焦在业务代码的开发上。</p>
<h1 id="建造者模式-1"><a href="#建造者模式-1" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。 </p>
<p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。</p>
<p>比如，你有没有考虑过这样几个问题：</p>
<p>直接使用构造函数或者配合 set 方法就能创建对象，为 什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>
<h3 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h3><p>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？ 你可以先思考一下，下面我通过一个例子来带你看一下。 </p>
<p>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155842.png" alt="image-20220110155833218"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Int</span><br><span class="hljs-params">   </span><br><span class="hljs-params">    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数， 参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变 差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非 常隐蔽的 bug。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以 我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填 写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选 配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下 面这三个问题，那现在的设计思路就不能满足了。</p>
<ul>
<li><p>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时 候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构 造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
</li>
<li><p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
</li>
<li><p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之 后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
</li>
</ul>
<p>为了解决这些问题，建造者模式就派上用场了。 </p>
<h3 id="如何使用建造者模式"><a href="#如何使用建造者模式" class="headerlink" title="如何使用建造者模式"></a>如何使用建造者模式</h3><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。 这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且， ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = builder.name;<br>        <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>        <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>        <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>    &#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br><br>    <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>	<span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>        <br>        <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br>    <span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>            .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>            .setMaxTotal(<span class="hljs-number">16</span>)<br>            .setMaxIdle(<span class="hljs-number">10</span>)<br>            .setMinIdle(<span class="hljs-number">12</span>)<br>            .build();<br></code></pre></td></tr></table></figure>

<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。 比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会 导致在第一个 set 之后，对象处于无效状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure>

<p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。 如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一 次性地创建对象，让对象一直处于有效状态。 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变 的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的 成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复 的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</p>
<h3 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h3><p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节 课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？ </p>
<p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子 类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对 象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别。 </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道 的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才 能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用</p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的 问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属 性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p>除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来 创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定 创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可 选参数，“定制化”地创建不同的对象。</p>
<h1 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式：如何最快速地clone一个HashMap散列表？"><a href="#原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="原型模式：如何最快速地clone一个HashMap散列表？"></a>原型模式：如何最快速地clone一个HashMap散列表？</h2><p>JavaScript 是一种基于原型的面 向对象编程语言。即便 JavaScript 现在也引入了类的概念，但它也只是基于原型的语法糖 而已。</p>
<h3 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。 </p>
<p><strong>那何为“对象的创建成本比较大”？</strong> </p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。</p>
<p>应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。 </p>
<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。</p>
<p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong> </p>
<p>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜 索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用 于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建 立一个散列表索引。</p>
<p>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中， HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。</p>
<p>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量 地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删 除关键词的行为。</p>
<p>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定 期根据数据库中的数据，更新内存中的索引和数据。</p>
<p>我们该如何实现这个需求呢？ </p>
<p>实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta， 从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据 的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们 就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散 列表中。</p>
<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版 本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更 新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。 </p>
<p>那我们该如何实现现在这个需求呢？ </p>
<p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中 的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建 另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版 本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<p>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数 据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为 了提高效率，<u>原型模式就派上用场了</u>。</p>
<p>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有 更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新 的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<p>里我们利用了 Java 中的 clone() 语法来复制一个对象</p>
<h3 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h3><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷 贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图 所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155940.png" alt="image-20220110153656490"></p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155942.png" alt="image-20220110153706912"></p>
<p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存 地址，不会递归地拷贝引用对象本身。</p>
<p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。 </p>
<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Deep copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>                    searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas<br>                    newKeywords.put(e.getKey(), newSearchWord);<br>        &#125;<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>                oldSearchWord.setCount(searchWord.getCount());<br>                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                newKeywords.put(searchWord.getKeyword(), searchWord);<br>            &#125;<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span>&#123;<br>        ByteArrayOutputStream bo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        ObjectOutputStream oo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>        oo.writeObject(object);<br>        ByteArrayInputStream bi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>        ObjectInputStream oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>        <br>        <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这 个应用场景，有没有更快、更省内存的实现方式呢？ </p>
<p>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象， 我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需 要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题 中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Shallow copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) cu<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                newKeywords.remove(searchWord.getKeyword());<br>            &#125;<br>            newKeywords.put(searchWord.getKeyword(), searchWord);<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>1.什么是原型模式？ </p>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模 式，简称原型模式。 </p>
<p>2.原型模式的两种实现方法</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。</p>
<p>浅拷贝只会复制对象中基本数据类型数据和引 用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到 的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空 间。 </p>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来 说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就 变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载 10 万条数据并 构建散列表索引，操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了 一点点的性能提升而使用浅拷贝。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式02-结构型模式</title>
    <url>/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式-上篇"><a href="#结构型模式-上篇" class="headerlink" title="结构型模式 | 上篇"></a>结构型模式 | 上篇</h1><h2 id="结构型模式总览"><a href="#结构型模式总览" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些<strong>类或对象组合在一起</strong>的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>代理模式：新增代理类，控制访问原始类</p>
<p>桥接模式：接口和实现分离，组合优于继承</p>
<p>装饰器模式：不改变原始类，增强原始类</p>
<p>适配器模式：事后补救策略，不兼容的接口转为可兼容</p>
<hr>
<p>代理模式：不改变原始类和接口，为原理类定义代理类，控制访问</p>
<p>桥接模式：将接口和实现部分分离</p>
<p>装饰器模式：不改变原始类和接口，对原始类增强</p>
<p>适配器模式：事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。</p>
<p>我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>静态代理、动态代理（jdk动态代理、cglib动态代理）</p>
<p>Spring中的APO</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>理解一：将抽象和实现解耦，让它们可以独立变化</p>
<p>理解二：一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。类似于“组合优于继承”，通过组合关系来替代继承关系，避免继承层次的指数级爆炸</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时</li>
</ol>
<p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>JDBC数据库连接池：MySQL和Oracle的方便切换</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>不改变原始类和接口，对原始类增强</p>
<p><strong>Q：装饰器模式就是简单的“用组合替代继承”吗？</strong></p>
<p>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。** </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>

<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类<strong>无关的功能</strong>，而在装饰器模式中，装饰器类附加的是跟原始类<strong>相关的增强功 能</strong>。</u></p>
<blockquote>
<p>业务场景</p>
</blockquote>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的IO流</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p><strong>Q：适配器模式有两种实现方式：类适配器和对象适配器。</strong></p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>接口不兼容的场景</p>
<p><strong>Q：那在实际的开发中，什么情况下才会出现接口不兼容呢？</strong></p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的日志框架：Slf4j</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h1 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>它在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<h3 id="代理模式的原理解析"><a href="#代理模式的原理解析" class="headerlink" title="代理模式的原理解析"></a>代理模式的原理解析</h3><p>性能计数器。当时我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略login逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略register逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很明显，上面的写法有两个问题。</p>
<p>第一，性能计数器框架代码侵入到业务代码中，跟业务代 码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。</p>
<p>第二，收集接口请求的 代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处 理。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业 务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。</p>
<p>UserController：核心业务实现类</p>
<p>UserControllerProxy：代理类，通过 委托 的方式（不修改源代码），对核心功能类增强 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span>;<br>    UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略login逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略register逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">private</span> UserController userController;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">(UserController userController)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userController = userController;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>		<span class="hljs-comment">// 委托</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="hljs-comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>())<br></code></pre></td></tr></table></figure>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。</p>
<p>但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个 第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下， 我们该如何实现代理模式呢？ </p>
<p>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承 原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体 代码如下所示：</p>
<p>UserController：别人写的，我们不知道长啥样</p>
<p>UserControllerProxy：我们自己写的，继承了 UserController，重写了里面的方法，方法里面的主要逻辑是对原功能增强，核心逻辑是 super.login() 调用原方法，一般项目开发中这种方式最常用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-comment">//功能增强</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//核心逻辑：通过委托的方式，super.login</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//UserControllerProxy使用举例</span><br>    <span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>();<br></code></pre></td></tr></table></figure>



<h3 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h3><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的 方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的 附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。 </p>
<p>如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项 目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式 的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>
<p>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不 事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后 在系统中用代理类替换掉原始类。那如何实现动态代理呢？ </p>
<p>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已 经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来 看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中， MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创 建代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollectorProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricsCollectorProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();<br>        <span class="hljs-type">DynamicProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(proxiedObject);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), in<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> Object proxiedObject;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>            <span class="hljs-built_in">this</span>.proxiedObject = proxiedObject;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Th<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxiedObject, args);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiName</span> <span class="hljs-operator">=</span> proxiedObject.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + method.getNam<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(apiName, responseTime, startTim<br>        metricsCollector.recordRequest(requestInfo);<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//MetricsCollectorProxy使用举例</span><br>MetricsCollectorProxy proxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollectorProxy</span>();<br>IUserController userController=(IUserController)proxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserC</span><br></code></pre></td></tr></table></figure>

<p>实际上，<strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建 代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。</strong></p>
<p>Spring 为这些类创建动 态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执 行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>
<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在 你的项目开发中。 </p>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类 中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代 理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个 支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数 据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？ </p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的 接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代 码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存 接口）、集中配置（比如配置每个接口缓存过期时间）。 </p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时 候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间） 等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 （比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获 取数据直接返回。</p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。 </p>
<p><strong>代理模式的原理与实现</strong></p>
<p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情 况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原 始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法 来实现代理模式。 </p>
<p><strong>动态代理的原理与实现</strong> </p>
<p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式 的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动 态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类 对应的代理类，然后在系统中用代理类替换掉原始类。 </p>
<p><strong>代理模式的应用场景</strong></p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事 务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只 需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p>
<h1 id="桥接模式-1"><a href="#桥接模式-1" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>最难理解的模式之一，应用场景也比较局限</p>
<p>对于这个模式 有两种不同的理解方式：</p>
<p>在 GoF 的《设计模 式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。” </p>
<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</p>
<h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>JDBC 驱动是桥接模式的经典应用。我们先来看一 下，如何利用 JDBC 驱动来查询数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-comment">//加载及注册JDBC驱动程序</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_pas</span><br><span class="hljs-string">Connection con = DriverManager.getConnection(url);</span><br><span class="hljs-string">Statement stmt = con.createStatement()；</span><br><span class="hljs-string">String query = &quot;</span>select * from test<span class="hljs-string">&quot;;</span><br><span class="hljs-string">ResultSet rs=stmt.executeQuery(query);</span><br><span class="hljs-string">while(rs.next()) &#123;</span><br><span class="hljs-string">    rs.getString(1);</span><br><span class="hljs-string">    rs.getInt(2);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵 活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置 文件就可以了。 </p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很 少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>
<p>源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.jdbc;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException if a database error occurs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-comment">// Required for Class.forName().newInstance()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。 第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代 码，也就是将 MySQL Driver 注册到 DriverManager 类中。 </p>
<p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们 把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后， 后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现 类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>
<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽 象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么 是“抽象”？什么是“实现”呢？ </p>
<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。<u>JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都 委托给 Driver 来执行。</u></p>
<img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130917.png" alt="image-20220110165339220" style="zoom:67%;" />



<h3 id="桥接模式的应用举例"><a href="#桥接模式的应用举例" class="headerlink" title="桥接模式的应用举例"></a>桥接模式的应用举例</h3><p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严 重）级别的消息会通过“自动语音电话”告知相关人员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotificationEmergencyLevel level, String message)</span>&#123;<br>        <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.SEVERE))&#123;<br>			<span class="hljs-comment">//...自动语音电话</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.URGENCY))&#123;<br>			<span class="hljs-comment">//...发微信</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.NORMAL))&#123;	<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.TRIVIAL))&#123;<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际 上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支 判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。 </p>
<p>不过，Notification 的代码显然不符合这个条件。因为<u>每个 if-else 分支中的代码逻辑都比 较复杂</u>，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细 小的类，然后再通过某种更合理的结构组装在一起。 </p>
<p><u>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 （MsgSender 相关类）</u>。其中，Notification 类相当于抽象，MsgSender 类相当于实 现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意 思就是，<u>不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们 可以动态地去指定（比如，通过读取配置来获取对应关系）。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelephoneMsgSender</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>        <span class="hljs-built_in">this</span>.telephones = telephones;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">protected</span> MsgSender msgSender;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.msgSender = msgSender;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SevereNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SevereNotification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">super</span>(msgSender);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>        msgSender.send(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrgencyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrivialNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>总体上来讲，桥接模式的原理比较难理解，但代码实现相对简单。 对于这个模式有两种不同的理解方式。在 GoF 的《设计模式》一书中，桥接模式被定义 为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更 加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式， 让这两个（或多个）维度可以独立进行扩展。” </p>
<p>对于第一种 GoF 的理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关 键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类 库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中 的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实 现”独立开发，通过对象之间的组合关系，组装在一起。</p>
<p>对于第二种理解方式，它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关 系来替代继承关系，避免继承层次的指数级爆炸。</p>
<h1 id="装饰者模式-1"><a href="#装饰者模式-1" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>它的代码结构跟桥接模式非常相似</p>
<blockquote>
<p>以下内容来自 C语言中文网，用于辅助理解</p>
</blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。</p>
<p><strong>Q：装饰器模式包含的角色</strong></p>
<p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130918.png" alt="image-20220110173456399" style="zoom:50%;" />

<p> 装饰器模式的结构图</p>
<h3 id="Java-IO-类的“奇怪”用法"><a href="#Java-IO-类的“奇怪”用法" class="headerlink" title="Java IO 类的“奇怪”用法"></a>Java IO 类的“奇怪”用法</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130919.png" alt="image-20220111094225907"></p>
<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130920.png" alt="image-20220111094255367"></p>
<p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代 码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类， FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓 存功能的数据读取类，可以提高数据读取的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计 一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就 可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读 取数据，用起来岂不是更加简单？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基于继承的设计方案"><a href="#基于继承的设计方案" class="headerlink" title="基于继承的设计方案"></a>基于继承的设计方案</h3><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础 之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还 算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。 </p>
<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(in);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支 持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、 BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩 展，也不好维护。这也是我们在第 10 节中讲的不推荐使用继承的原因。</p>
<h3 id="基于装饰器模式的设计方案"><a href="#基于装饰器模式的设计方案" class="headerlink" title="基于装饰器模式的设计方案"></a>基于装饰器模式的设计方案</h3><p>针对刚刚的 继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示 了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现基于缓存的读数据接口...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DataInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现读取基本类型数据的接口</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>看了上面的代码，你可能会问，那<strong>装饰器模式就是简单的“用组合替代继承”吗？</strong>当然不 是。<strong>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。</strong> </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功 能。</u></p>
<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原 始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器 模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在 设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<h1 id="适配器模式-1"><a href="#适配器模式-1" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？</h2><p>它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类 可以一起工作。</p>
<p>对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式有两种实现方式：类适配器和对象适 配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>具体的代码 实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类适配器: 基于继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.fa();<br>	 &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>     &#125;<br>	 <span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对象适配器：基于组合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有 两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<p>如果 Adaptee 接口并不多，那两种实现方式都可以。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推 荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方 式，Adaptor 的代码量要少一些。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们 推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p>
<h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？ </p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式 算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。 前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情 况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结</p>
<p><strong>1、封装有缺陷的接口设计</strong></p>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影 响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进 行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CD</span> &#123; <span class="hljs-comment">//这个类来自外部sdk，我们无权修改它的代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uglyNamingFunction2</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tooManyParamsFunction3</span> <span class="hljs-params">( <span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB, ...)</span>&#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPerformanceFunction4</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fucntion3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.staticFunction1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.uglyNamingFucntion2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;<br>        <span class="hljs-built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">//...reimplement it...</span><br>    &#125;<br>&#125;        <br>        <br></code></pre></td></tr></table></figure>

<p><strong>2、统一多个类的接口设计</strong></p>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统 一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解 释一下。 </p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入 了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感 词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用 各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定 义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilter</span> &#123; <span class="hljs-comment">// A敏感词过滤系统提供的接口</span><br>    <span class="hljs-comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSexyWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterPoliticalWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// B敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// C敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text, String mask)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ASensitiveWordsFilter</span> <span class="hljs-variable">aFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">BSensitiveWordsFilter</span> <span class="hljs-variable">bFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CSensitiveWordsFilter</span> <span class="hljs-variable">cFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        maskedText = bFilter.filter(maskedText);<br>        maskedText = cFilter.filter(maskedText, <span class="hljs-string">&quot;***&quot;</span>);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行改造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123; <span class="hljs-comment">// 统一接口定义</span><br>    String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilterAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> ASensitiveWordsFilter aFilter;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="hljs-comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="hljs-comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSensitiveWordsFilter</span><span class="hljs-params">(ISensitiveWordsFilter filter)</span> &#123;<br>        filters.add(filter);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> text;<br>        <span class="hljs-keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;<br>            maskedText = filter.filter(maskedText);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3\替换依赖的外部系统</p>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以 减少对代码的改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部系统A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    &#125;<br>    <span class="hljs-comment">// 在我们的项目中，外部系统A的使用示例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>        <span class="hljs-keyword">private</span> IA a;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(IA a)</span> &#123;<br>            <span class="hljs-built_in">this</span>.a = a;<br>        &#125;<br>	<span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>    <span class="hljs-comment">// 将外部系统A替换成外部系统B</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdaptor</span> implemnts IA &#123;<br>        <span class="hljs-keyword">private</span> B b;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdaptor</span><span class="hljs-params">(B b)</span> &#123;<br>            <span class="hljs-built_in">this</span>.b= b;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>            b.fb();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br>	<span class="hljs-comment">// 只需要将BAdaptor如下注入到Demo即可。</span><br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdaptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>()));<br></code></pre></td></tr></table></figure>

<p>4\兼容老版本接口</p>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且 标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用 场景。同样，我还是通过一个例子，来进一步解释一下。 </p>
<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它 改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接 从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为 了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使 用 Iterator 才行。 </p>
<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发 的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是 不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码， 我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下 所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Emueration <span class="hljs-title function_">emumeration</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Collection c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>() &#123;<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator();<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMoreElments</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.hashNext();<br>            &#125;<br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nextElement</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.next():<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5\适配不同格式的数据 </p>
<p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之 间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方 便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类 型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="剖析适配器模式在-Java-日志中的应用"><a href="#剖析适配器模式在-Java-日志中的应用" class="headerlink" title="剖析适配器模式在 Java 日志中的应用"></a>剖析适配器模式在 Java 日志中的应用</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常 用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。 </p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、 erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不 像 JDBC 那样，一开始就制定了数据库操作的接口规范。 </p>
<p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选 一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框 架的选择就没那么随意了。 </p>
<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志 框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比 如，日志存储的文件地址、打印日志的格式）。</p>
<p>如果引入多个组件，每个组件使用的日志框 架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要 统一日志打印框架。 如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范， 提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需 要配合其他日志框架（log4j、logback……）来使用。 </p>
<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能 牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所 以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框 架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// slf4j统一的接口定义</span><br><span class="hljs-keyword">package</span> org.slf4j;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable t)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span>;<br><span class="hljs-comment">//...省略info、warn、error等一堆接口</span><br>&#125;<br><span class="hljs-comment">// log4j日志框架的适配器</span><br><span class="hljs-comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="hljs-comment">// 其中LocationAwareLogger继承自Logger接口，</span><br><span class="hljs-comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="hljs-keyword">package</span> org.slf4j.impl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4jLoggerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarkerIgnoringBase</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocationAwareLogger</span>, Serializable &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> org.apache.log4j.Logger logger; <span class="hljs-comment">// log4j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg1, arg2);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.arrayFormat(format, argArray);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, t);<br>    &#125;<br><span class="hljs-comment">//...省略一堆接口的实现...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写 打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定 的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导 入到项目中即可。 </p>
<p>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日 志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提 供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志 框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配 器的转换，我们能就成功将 log4j 切换为了 logback。</p>
<h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结 构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封 装原始类。 </p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场 景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。 </p>
<p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是 控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 </p>
<p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相 对独立地加以改变。</p>
<p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持 多个装饰器的嵌套使用。 </p>
<p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理 模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>适配器模式有两种实现方式：类适配器和对象适配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样 5 种场景：</p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<h1 id="结构型模式-下篇"><a href="#结构型模式-下篇" class="headerlink" title="结构型模式 | 下篇"></a>结构型模式 | 下篇</h1><h2 id="结构型模式总览-1"><a href="#结构型模式总览-1" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率-1"><a href="#设计模式使用频率-1" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易 用。</p>
<p>让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>1、解决易用性问题</p>
<p>Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p>
<p>2、解决性能问题</p>
<p>通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度</p>
<p>3、解决分布式事务问题</p>
<p>在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<p>场景举例一：</p>
<p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。</p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>应用举例一：开发一个棋牌游戏</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。</p>
<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间。</p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p>
<p>应用举例二：在文本编辑器中的应用</p>
<p>我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。</p>
<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java Integer 缓冲池</p>
<p>Java String 字符串常量池</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>享元模式 vs 单例、缓存、对象池</strong></p>
<p>应用单例模式是为了保证对象全局唯一。</p>
<p>应用享元模式是为了实现对象复用，节省内存。</p>
<p>缓存是为了提高访问效率，而非复用。 </p>
<p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h1 id="门面模式-1"><a href="#门面模式-1" class="headerlink" title="门面模式"></a>门面模式</h1><h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？</h2><p>原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。 </p>
<p>如果你平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？ </p>
<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需 要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>
<p>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口 不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开 发不同的接口来满足，这就会导致系统的接口无限膨胀。</p>
<h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>这个定义很简洁，我再进一步解释一下。 </p>
<p>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。 </p>
<p>不知道你会不会有这样的疑问，让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么 还要提供一个包裹 a、b、d 的接口 x 呢？关于这个问题，我通过一个具体的例子来解释一 下。 </p>
<p>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过 后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信 的，<u>网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之 间的网络通信次数</u>。 </p>
<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接 口，因自身业务的特点，不支持并发调用这三个接口。</p>
<p>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用 过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。 </p>
<p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应 用场景下，使用门面模式的意图也不同。</p>
<h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><p>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性 问题之外，还能解决其他很多方面的问题。关于这一点，我总结罗列了 3 个常用的应用场 景，你可以参考一下，举一反三地借鉴到自己的项目中。 </p>
<p>除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种 理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</p>
<p>1、解决易用性问题</p>
<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高 层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。 </p>
<p>我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表 述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲 到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要 的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接 口，封装底层实现细节。</p>
<p>2、解决性能问题</p>
<p>关于利用门面模式解决性能问题这一点，刚刚我们已经讲过了。我们通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。所以，关于这 点，我就不再举例说明了。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何 组织门面接口和非门面接口？ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普 通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专 门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很 多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p>
<p>3、解决分布式事务问题</p>
<p>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。 </p>
<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了 一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景： 在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱 包（在数据库的 Wallet 表中）。 </p>
<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来 完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成 功，要么都失败，不能一个成功、一个失败。 </p>
<p><u>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。</u>虽然我 们可以通过引入<u>分布式事务框架或者事后补偿的机制</u>来解决，但代码实现都比较复杂。而最 简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的 话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。 </p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的 好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经 常说，完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不 到哪里去。 </p>
<p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在 实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基 本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口， 来提供更易用的接口。 </p>
<p>门面模式除了解决接口易用性问题之外，我们今天还讲到了其他 2 个应用场景，用它来解 决性能问题和分布式事务问题。</p>
<h1 id="组合模式-1"><a href="#组合模式-1" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全 是两码事。</p>
<p>这里讲的“组合模式”，主要是用来处理树形结构数据。</p>
<p>这里的“数据”，你可 以简单理解为一组对象集合，待会我们会详细讲解。 正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项 目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作 用，能让代码变得非常简洁。</p>
<h3 id="组合模式的原理与实现"><a href="#组合模式的原理与实现" class="headerlink" title="组合模式的原理与实现"></a>组合模式的原理与实现</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功 能： </p>
<p>动态地添加、删除某个目录下的子目录或文件； </p>
<p>统计指定目录下的文件个数； </p>
<p>统计指定目录下的文件总大小。</p>
<p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去 补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isFile;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isFile)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>        <span class="hljs-built_in">this</span>.isFile = isFile;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>            <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> file.length();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果 我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模 （文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对 业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。 按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">protected</span> String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        java.io.<span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(path);<br>        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> file.length();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具 体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> * /wz/</span><br><span class="hljs-comment"> * /wz/a.txt</span><br><span class="hljs-comment"> * /wz/b.txt</span><br><span class="hljs-comment"> * /wz/movies/</span><br><span class="hljs-comment"> * /wz/movies/c.avi</span><br><span class="hljs-comment"> * /xzg/</span><br><span class="hljs-comment"> * /xzg/docs/</span><br><span class="hljs-comment"> * /xzg/docs/d.txt</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">fileSystemTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/&quot;</span>);<br>        fileSystemTree.addSubNode(node_wz);<br>        fileSystemTree.addSubNode(node_xzg);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/a.txt&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/b.txt&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz_movies</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/movies/&quot;</span>);<br>        node_wz.addSubNode(node_wz_a);<br>        node_wz.addSubNode(node_wz_b);<br>        node_wz.addSubNode(node_wz_movies);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_movies_c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/movies/c.avi&quot;</span>);<br>        node_wz_movies.addSubNode(node_wz_movies_c);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg_docs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/docs/&quot;</span>);<br>        node_xzg.addSubNode(node_xzg_docs);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_xzg_docs_d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/xzg/docs/d.txt&quot;</span>);<br>        node_xzg_docs.addSubNode(node_xzg_docs_d);<br>        System.out.println(<span class="hljs-string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());<br>        System.out.println(<span class="hljs-string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场 景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通 过在树上的递归遍历算法来实现。 </p>
<h3 id="组合模式的应用场景举例"><a href="#组合模式的应用场景举例" class="headerlink" title="组合模式的应用场景举例"></a>组合模式的应用场景举例</h3><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子， 你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场 景，你只要“照葫芦画瓢”去设计就可以了。 假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131024.png" alt="image-20220112152058414"></p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。 </p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。 </p>
<p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看 一下。其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出 来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在 内存中构建组织架构图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> id;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HumanResource</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Department</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (HumanResource hr : subNodes) &#123;<br>            totalSalary += hr.calculateSalary();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.salary = totalSalary;<br>        <span class="hljs-keyword">return</span> totalSalary;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(HumanResource hr)</span> &#123;<br>        subNodes.add(hr);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建组织架构的代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ORGANIZATION_ROOT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    <span class="hljs-keyword">private</span> DepartmentRepo departmentRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> EmployeeRepo employeeRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Department</span> <span class="hljs-variable">rootDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(ORGANIZATION_ROOT_ID);<br>        buildOrganization(rootDepartment);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">(Department department)</span> &#123;<br>        List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long subDepartmentId : subDepartmentIds)</span> &#123;<br>            <span class="hljs-type">Department</span> <span class="hljs-variable">subDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(subDepartmentId);<br>            department.addSubNode(subDepartment);<br>            buildOrganization(subDepartment);<br>        &#125;<br>        List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.g<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long employeeId : employeeIds)</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> employeeRepo.getEmployeeSalary(employeeId);<br>            department.addSubNode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(employeeId, salary));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结 构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客 户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<h1 id="享元模式-1"><a href="#享元模式-1" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h2><h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。 </p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。 </p>
<p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之 后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露 任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代 码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。 </p>
<p>接下来，我们通过一个简单的例子解释一下享元模式。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一 个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<span class="hljs-comment">//棋子</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">String</span> text, Color color, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positi</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.id = id;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.text = text;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.color = color;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionX = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionY = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> Color &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        RED, BLACK</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// ...省略其他属性和getter/setter方法...</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ChessBoard &#123;<span class="hljs-comment">//棋局</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> ChessBoard() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        init();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> init() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略摆放其他棋子的代码...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> move(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多）， 那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？ </p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如 下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPieceUnit</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.text = text;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>        RED, BLACK<br>    &#125;<br><span class="hljs-comment">// ...省略其他属性和getter方法...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnitFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        pieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));<br>        pieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessPieceUnit <span class="hljs-title function_">getChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId)</span> &#123;<br>        <span class="hljs-keyword">return</span> pieces.get(chessPieceId);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<br>    <span class="hljs-keyword">private</span> ChessPieceUnit chessPieceUnit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(ChessPieceUnit unit, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.chessPieceUnit = unit;<br>        <span class="hljs-built_in">this</span>.positionX = positionX;<br>        <span class="hljs-built_in">this</span>.positionY = positionY;<br>    &#125;<br><span class="hljs-comment">// 省略getter、setter方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>        <span class="hljs-comment">//...省略...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、 color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享 这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记 录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元 模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。 </p>
<p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简 单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来 达到复用的目的。 </p>
<h3 id="享元模式在文本编辑器中的应用"><a href="#享元模式在文本编辑器中的应用" class="headerlink" title="享元模式在文本编辑器中的应用"></a>享元模式在文本编辑器中的应用</h3><p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的： 如何利用享元模式来优化文本编辑器的内存占用？ 你可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。 </p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的 代码示例如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<span class="hljs-comment">//文字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>        <span class="hljs-keyword">this</span>.font = font;<br>        <span class="hljs-keyword">this</span>.size = size;<br>        <span class="hljs-keyword">this</span>.colorRGB = colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        Character character = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Character</span>(c, font, size, colorRGB);<br>        chars.<span class="hljs-built_in">add</span>(character);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyle</span> &#123;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharacterStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.font = font;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">otherStyle</span> <span class="hljs-operator">=</span> (CharacterStyle) o;<br>        <span class="hljs-keyword">return</span> font.equals(otherStyle.font)<br>                &amp;&amp; size == otherStyle.size<br>                &amp;&amp; colorRGB == otherStyle.colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyleFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharacterStyle <span class="hljs-title function_">getStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">newStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterStyle</span>(font, size, colorRGB);<br>        <span class="hljs-keyword">for</span> (CharacterStyle style : styles) &#123;<br>            <span class="hljs-keyword">if</span> (style.equals(newStyle)) &#123;<br>                <span class="hljs-keyword">return</span> style;<br>            &#125;<br>        &#125;<br>        styles.add(newStyle);<br>        <span class="hljs-keyword">return</span> newStyle;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> CharacterStyle style;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, CharacterStyle style)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>        <span class="hljs-built_in">this</span>.style = style;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, CharacterStyleFactory.getStyle(font<br>                chars.add(character);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h3><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、 对象池这些概念有什么区别呢？我们来简单对比一下。 </p>
<p><strong>我们先来看享元模式跟单例的区别。</strong></p>
<p><u>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每 个对象被多处代码引用共享。</u>实际上，享元模式有点类似于之前讲到的单例的变体：多例。 </p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上 来看，它们是完全不同的。<u>应用享元模式是为了对象复用，节省内存，而应用多例模式是为 了限制对象的个数。</u> </p>
<p><strong>我们再来看享元模式跟缓存的区别。</strong> </p>
<p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际 上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓 存”是两回事。我们平时所讲的缓存，<u>主要是为了提高访问效率，而非复用。</u> </p>
<p><strong>最后我们来看享元模式跟对象池的区别。</strong> </p>
<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么 区别呢？ </p>
<p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象 池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。 每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。 </p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一 抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中 的“复用”实际上是不同的概念。 </p>
<p><u>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中 取一个连接，不需要重新创建）</u>。在任意时刻，每一个对象、连接、线程，并不会被多处使 用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。<u>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享 的，主要目的是节省空间。</u></p>
<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p><strong>享元模式的原理</strong></p>
<p><u>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以 利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以 减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享 元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元， 让这些大量相似对象引用这些享元。</u> </p>
<p><strong>享元模式的实现</strong> </p>
<p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。 </p>
<p><strong>享元模式 VS 单例、缓存、对象池</strong></p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。这里的区别也不例外。 </p>
<p>我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯 一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。 池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h2 id="享元模式（下）：剖析享元模式在Java-Integer、String中-的应用"><a href="#享元模式（下）：剖析享元模式在Java-Integer、String中-的应用" class="headerlink" title="享元模式（下）：剖析享元模式在Java Integer、String中 的应用"></a>享元模式（下）：剖析享元模式在Java Integer、String中 的应用</h2><h3 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>System.out.println(i1 == i2);<br>System.out.println(i3 == i4);<br></code></pre></td></tr></table></figure>

<p>如何判定两个 Java 对象是否相等（也就代码中的“==”操作符的含义）？ </p>
<p>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131025.png" alt="image-20220112155026935"></p>
<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自 动将包装器类型转化为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>; <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure>

<p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱 操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语 句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">59</span>；底层执行了：<span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">59</span>);<br></code></pre></td></tr></table></figure>

<p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操 作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; 底层执行了：<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure>

<p>Q：Java 对象在内存中是如何存储的。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span> a = new User(<span class="hljs-number">123</span>, <span class="hljs-number">23</span>); // id=<span class="hljs-number">123</span>, age=<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>

<p>针对这条语句，我画了一张内存存储结构图，如下所示。a 存储的值是 User 对象的内存地 址，在图中就表现为 a 指向 User 对象。 </p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131026.png" alt="image-20220112155226847"></p>
<p>当我们通过“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的 地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p>
<p>了解了 Java 的这几个语法之后，我们重新看一下开头的那段代码。</p>
<p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、 i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不 同的 Integer 对象，所以通过“==”来判定是否相同的时候，会返回 false。同理， i3==i4 判定语句也会返回 false。 </p>
<p>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这 里，你可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才 导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象 的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函 数的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>	<span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>		<span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，这里的 IntegerCache 相当于，我们上一节课中讲的生成享元对象的工厂类，只不 过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类， 你也可以自行查看 JDK 源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cache to support the object identity semantics of autoboxing for values betw</span><br><span class="hljs-comment"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The cache is initialized on first usage. The size of the cache</span><br><span class="hljs-comment"> * may be controlled by the &#123;<span class="hljs-doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="hljs-comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="hljs-comment"> * may be set and saved in the private system properties in the</span><br><span class="hljs-comment"> * sun.misc.VM class.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>)<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？ </p>
<p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性 创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值， 这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存 对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数 据）。 </p>
<p>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你 通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，你 就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没 有提供设置最小值的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br>-Djava.lang.Integer.IntegerCache.high=<span class="hljs-number">255</span><br><span class="hljs-comment">//方法二：</span><br>-XX:AutoBoxCacheMax=<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure>

<p>现在，让我们再回到最开始的问题，因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同 的享元对象，所以 i1==i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一 个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3==i4 返回 false。 </p>
<p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利 用了享元模式来缓存 -128 到 127 之间的数据。比如，Long 类型对应的 LongCache 享元 工厂类及 valueOf() 函数代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LongCache</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long cache[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[-(-<span class="hljs-number">128</span>) + <span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>            cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(i - <span class="hljs-number">128</span>);<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>            <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子， 假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们 需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。 </p>
<h3 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h3><p>刚刚我们讲了享元模式在 Java Integer 类中的应用，现在，我们再来看下，享元模式在 Java String 类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是 什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小争哥&quot;</span>);<br>System.out.println(s1 == s2);<br>System.out.println(s1 == s3);<br></code></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类 利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存 储结构如下所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131027.png" alt="image-20220112155710422"></p>
<p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对 象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知 道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的 时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需 要再重新创建了。 </p>
<h3 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>在 Java Integer 的实现中，-128 到 127 之间的整型对象会被事先创建好，缓存在 IntegerCache 类中。当我们使用自动装箱或者 valueOf() 来创建这个数值区间的整型对象 时，会复用 IntegerCache 类事先创建好的对象。这里的 IntegerCache 类就是享元工厂 类，事先创建好的整型对象就是享元对象。 </p>
<p>在 Java String 类的实现中，JVM 开辟一块存储区专门存储字符串常量，这块存储区叫作 字符串常量池，类似于 Integer 中的 IntegerCache。不过，跟 IntegerCache 不同的是，它并非事先创建好需要共享的对象，而是在程序的运行期间，根据需要来创建和缓存字符串 常量。 </p>
<p>除此之外，这里我再补充强调一下。 </p>
<p>实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的 引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自 动回收掉。因此，<u>在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元 模式反倒可能会浪费更多的内存。</u>所以，除非经过线上验证，利用享元模式真的可以大大节 省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模 式，得不偿失啊。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL百科全书</title>
    <url>/kygeng.github.io/2022/03/23/%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%9AMySQL%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Linux下的安装与使用"><a href="#一、Linux下的安装与使用" class="headerlink" title="一、Linux下的安装与使用"></a>一、Linux下的安装与使用</h1><h2 id="常用命令行"><a href="#常用命令行" class="headerlink" title="常用命令行"></a>常用命令行</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查看MySQL版本</span><br>mysql --version<br><br><span class="hljs-section"># 查看是否安装成功</span><br>rpm -qa|grep -i mysql<br><br><span class="hljs-section"># 启动MySQL，查看状态</span><br>启动：systemctl start mysqld.service<br>关闭：systemctl stop mysqld.service<br>重启：systemctl restart mysqld.service<br>查看状态：systemctl status mysqld.service<br><br><span class="hljs-section"># 重新启动MySQL服务</span><br>systemctl restart mysqld<br><br><span class="hljs-section"># 设置MySQL服务自启动</span><br>systemctl enable mysqld.service<br><br><span class="hljs-section"># 修改已创建数据库的字符集</span><br>alter database dbtest1 character set &#x27;utf8&#x27;;<br><br><span class="hljs-section"># 修改已创建数据表的字符集</span><br>alter table t<span class="hljs-emphasis">_emp convert to character set &#x27;utf8&#x27;;</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure>



<p>登录MySQL服务器 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下： </p>
<p>下面详细介绍命令中的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql –h hostname<span class="hljs-operator">|</span>hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>hlocalhost <span class="hljs-operator">-</span>P3306 mysql <span class="hljs-operator">-</span>e &quot;select host,user from user&quot;<br></code></pre></td></tr></table></figure>

<p>-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </p>
<p>-P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306， 不使用该参数时自动连接到3306端口，port为连接的端口号。 </p>
<p>-u参数 后面接用户名，username为用户名。 </p>
<p>-p参数 会提示输入密码。 </p>
<p>DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库 中，然后可以使用USE命令来选择数据库。 </p>
<p>-e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL 服务器。</p>
<h2 id="SQL大小写规范"><a href="#SQL大小写规范" class="headerlink" title="SQL大小写规范"></a>SQL大小写规范</h2><p>不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大 小写问题。 windows系统默认大小写不敏感 ，但是 linux系统是大小写敏感的 。 </p>
<p>通过如下命令查看：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%lower_case_table_names%&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210154.png" alt="image-20220121150030248"></p>
<p>lower_case_table_names参数值的设置： </p>
<ul>
<li><p>默认为0，大小写敏感 。 </p>
</li>
<li><p>设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转 换为小写对表和数据库进行查找。 </p>
</li>
<li><p>设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。 </p>
</li>
</ul>
<p><strong>两个平台上SQL大小写的区别具体来说：</strong></p>
<p>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的： </p>
<p>1、数据库名、表名、表的别名、变量名是严格区分大小写的； </p>
<p>2、关键字、函数名称在 SQL 中不区分大小写； </p>
<p>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的； </p>
<p>MySQL在Windows的环境下全部不区分大小写</p>
<h2 id="sql-mode的合理设置"><a href="#sql-mode的合理设置" class="headerlink" title="sql_mode的合理设置"></a>sql_mode的合理设置</h2><p>sql_mode 会影响MySQL支持的SQL语法以及它执行的<code>数据验证检查</code>。通过设置sql_mode，可以完成不同严格程度的数据校验，有效地保障数据准确性。</p>
<p>MySQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于sql_mode系统变量的值。</p>
<p>MySQL5.6和MySQL5.7默认的sql_mode模式参数是不一样的:</p>
<ul>
<li><p>5.6的mode默认值为空(即: NO_ENGINE_SUBSTITUTION )，其实表示的是一个空值，相当于没有什么模式设置，可以理解为<code>宽松模式</code>。在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。</p>
</li>
<li><p>5.7的mode是 STRICT_TRANS_TABLES，也就是<code>严格模式</code>。用于进行数据的严格校验，错误数据不能插入，报error(错误)，并且事务回滚。</p>
</li>
</ul>
<hr>
<p><strong>宽松模式：</strong> </p>
<p>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受， 并且不报错。 </p>
<p><strong>举例 ：</strong>我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时 char(10) ，如果我 在插入数据的时候，其中name这个字段对应的有一条数据的 长度超过了10 ，例如’1234567890abc’，超 过了设定的字段长度10，那么不会报错，并且取前10个字符存上，也就是说你这个数据被存为 了’1234567890’，而’abc’就没有了。但是，我们给的这条数据是错误的，因为超过了字段长度，但是并没 有报错，并且mysql自行处理并接受了，这就是宽松模式的效果。 </p>
<p><strong>应用场景 ：</strong>通过设置sql mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据 库之间进行 迁移 时，则不需要对业务sql 进行较大的修改。 </p>
<p><strong>严格模式：</strong> </p>
<p>出现上面宽松模式的错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式。所 以在 生产等环境 中，我们必须采用的是严格模式，进而 开发、测试环境 的数据库也必须要设置，这样在 开发测试阶段就可以发现问题。并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式。 </p>
<p><strong>开发经验 ：</strong>MySQL等数据库总想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实开发 中，我们应该在自己 开发的项目程序级别将这些校验给做了 ，虽然写项目的时候麻烦了一些步骤，但是这 样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。 </p>
<p><strong>改为严格模式后可能会存在的问题：</strong></p>
<p>若设置模式中包含了 NO_ZERO_DATE ，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而 不是警告。例如，表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配 DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这显然是不满足sql_mode中的NO_ZERO_DATE而报错。</p>
<h1 id="二、MySQL的数据目录"><a href="#二、MySQL的数据目录" class="headerlink" title="二、MySQL的数据目录"></a>二、MySQL的数据目录</h1><h2 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">find / -name mysql<br></code></pre></td></tr></table></figure>

<p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>
<p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和 /usr/sbin</p>
<p>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</p>
<h2 id="MySQL自带的系统数据库"><a href="#MySQL自带的系统数据库" class="headerlink" title="MySQL自带的系统数据库"></a>MySQL自带的系统数据库</h2><p>SHOW DATABASES;</p>
<p>可以看到有4个数据库是属于MySQL自带的系统数据库。 </p>
<p><strong>mysql</strong></p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定 义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 </p>
<p><strong>information_schema</strong> </p>
<p>MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有 哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些 描述性信息，有时候也称之为 元数据 。在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表，用于表示内部系统表。</p>
<p><strong>performance_schema</strong></p>
<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以 用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。 </p>
<p><strong>sys</strong></p>
<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
<h2 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h2><h3 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a>InnoDB存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：<code>表名.frm</code></p>
<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>
<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件 的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的。</p>
<p><strong>2、表中数据和索引</strong></p>
<p><strong>① 系统表空间（system tablespace）</strong> </p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自 己增加文件大小。 </p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名 难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置 文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_data_file_path</span>=data1:<span class="hljs-number">512</span>M<span class="hljs-comment">;data2:512M:autoextend</span><br></code></pre></td></tr></table></figure>

<p><strong>② 独立表空间(file-per-table tablespace)</strong></p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来 存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表 名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：<code>表名.ibd</code></p>
<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应 的 atguigu 目录下会为 test 表创建这两个文件：<code>test.frm</code>  <code>test.ibd</code></p>
<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>
<p><strong>③ 系统表空间与独立表空间的设置</strong> </p>
<p>我们可以自己指定使用 <code>系统表空间</code> 还是 <code>独立表空间</code> 来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动 MySQL服务器的时候这样配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span> <span class="hljs-comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></code></pre></td></tr></table></figure>

<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| innodb_file_per_table | ON    |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>



<p><strong>④ 其他类型的表空间</strong> </p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用 表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h3 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专 门用于描述表结构的文件：<code>表名.frm</code></p>
<p><strong>2、表中数据和索引</strong> </p>
<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test 表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文 件：</p>
<p><code>test.frm 存储表结构 </code></p>
<p><code>test.MYD 存储数据 (MYData) </code></p>
<p><code>test.MYI 存储索引 (MYIndex)</code></p>
<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student_myisam` (<br>`id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`sex` <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>)ENGINE=MYISAM AUTO_INCREMENT=<span class="hljs-number">0</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>举例： <code>数据库a ， 表b </code>。 </p>
<p><strong>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</strong> </p>
<p><code>b.frm </code>：描述表结构文件，字段长度等 </p>
<p>如果采用 <code>系统表空间</code> 模式的，数据信息和索引信息都存储在 <code>ibdata1</code> 中 </p>
<p>如果采用 <code>独立表空间</code> 存储模式，data\a 中还会产生 <code>b.ibd</code> 文件（存储数据信息和索引信息） </p>
<p>此外： </p>
<p>​    ① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较 规则。而MySQL8.0不再提供db.opt文件。 </p>
<p>​    ② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。 </p>
<p><strong>2、如果表b采用 <code>MyISAM</code> ，data\a 中会产生3个文件：</strong> </p>
<p>​    MySQL5.7 中：<code>b.frm</code> ：描述表结构文件，字段长度等。 </p>
<p>​    MySQL8.0 中 <code>b.xxx.sdi </code>：描述表结构文件，字段长度等 </p>
<p>​    <code>b.MYD (MYData)</code>：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>
<p>​    <code>b.MYI (MYIndex)</code>：存放索引信息文件</p>
<h2 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h2><p>我们知道MysQL中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只余存储一个 <code>视图名.frm</code>的文件。如下图中的: emp_details_view.frm</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">[ root<span class="hljs-symbol">@atguigu82</span> mysql]<span class="hljs-meta"># cd ./temp</span><br>[ root<span class="hljs-symbol">@atguigu82</span> temp]<span class="hljs-meta"># ll</span><br></code></pre></td></tr></table></figure>

<h2 id="其他的文件"><a href="#其他的文件" class="headerlink" title="其他的文件"></a>其他的文件</h2><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件:</p>
<p><strong>1、服务器进程文件</strong></p>
<p>我们知道每运行一个MySQL服务器程序，都意味着启动一个进程。MySQL服务器会把自己的进程ID写入到一个文件中。</p>
<p><strong>2、服务器日志文件</strong></p>
<p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等。这些日志各有各的用途，后面讲解。</p>
<p><strong>3、默认/自动生成的SSL和RSA证书和密钥文件</strong></p>
<p>主要是为了客户端和服务器安全通信而创建的一些文件。</p>
<h1 id="三、用户与权限管理"><a href="#三、用户与权限管理" class="headerlink" title="三、用户与权限管理"></a>三、用户与权限管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>MySQL用户可以分为普通用户和root用户。root用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限;普通用户只拥有被授予的各种权限。</p>
<p>MysQL提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出MysQL服务器、创建用户、删除用户、密码管理和权限管理等内容。</p>
<p><strong>MySQL数据库的安全性需要通过账户管理来保证。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210155.png" alt="image-20220120174452352"></p>
<p><strong>可以创建同名的用户，该表中使用 host 和 user 作为联合主键，就算 user相同，只要 host不同就可以</strong></p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>][,用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>]];<br></code></pre></td></tr></table></figure>

<p>用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成； </p>
<p>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户 可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY指定明文密码值。 </p>
<p>CREATE USER语句可以同时创建多个用户。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> zhang3 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123123&#x27;</span>; # 默认host是 %<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户名：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;li4&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;wang5&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>方式1：使用DROP方式删除（推荐） 使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span>[,<span class="hljs-keyword">user</span>]…;<br></code></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">li4</span> ; <span class="hljs-comment"># 默认删除host为%的用户</span><br>DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">&#x27;kangshifu</span>&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure>

<p>方式2：使用DELETE方式删除 </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=’hostname’ <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=’username’;<br></code></pre></td></tr></table></figure>

<p>执行完DELETE命令后要使用FLUSH命令来使用户生效，命令如下： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">FLUSH PRIVILEGES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=<span class="hljs-string">&#x27;Emily&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>

<p>注意：不推荐通过 DELETE FROM USER u WHERE USER=’li4’ 进行删除，系统会有残留信息保 留。而drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表 的相应记录都消失了。</p>
<h3 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h3><p>旧的写法如下 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 修改当前用户的密码：（MySQL5<span class="hljs-number">.7</span>测试有效）<br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-operator">=</span> PASSWORD(<span class="hljs-string">&#x27;123456&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>这里介绍 推荐的写法 ： </p>
<p>1、使用ALTER USER命令来修改当前用户密码 用户可以使用ALTER命令来修改自身密码，如下语句代表修 改当前登录用户的密码。基本语法如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">USER</span>() IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>2、使用SET语句来修改当前用户密码 使用root用户登录MySQL后，可以使用SET语句来修改密码，具体 SQL语句如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">PASSWORD</span>=<span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>该语句会自动将密码加密后再赋给当前用户。</p>
<h3 id="修改其它用户密码"><a href="#修改其它用户密码" class="headerlink" title="修改其它用户密码"></a>修改其它用户密码</h3><p>1、使用ALTER语句来修改普通用户的密码 可以使用ALTER USER语句来修改普通用户的密码。基本语法形 式如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span> [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]<br>[,<span class="hljs-keyword">user</span>[IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]]…;<br></code></pre></td></tr></table></figure>



<p>2、使用SET命令来修改普通用户的密码 使用root用户登录到MySQL服务器后，可以使用SET语句来修改普 通用户的密码。SET语句的代码如下：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-comment">FOR</span> <span class="hljs-comment">&#x27;username&#x27;</span><span class="hljs-comment">@</span><span class="hljs-comment">&#x27;hostname&#x27;</span><span class="hljs-comment">=</span><span class="hljs-comment">&#x27;new_password&#x27;</span>;<br><br></code></pre></td></tr></table></figure>



<p>3、使用UPDATE语句修改普通用户的密码（不推荐）</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> MySQL.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> authentication_string=<span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&quot;123456&quot;</span>)<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">User</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">AND</span> Host = <span class="hljs-string">&quot;hostname&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8密码管理-了解"><a href="#MySQL8密码管理-了解" class="headerlink" title="MySQL8密码管理(了解)"></a>MySQL8密码管理(了解)</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210156.png" alt="image-20220121153526888"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210157.png" alt="image-20220121153540169"></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h3><p>MySQL到底都有哪些权限呢？ </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210158.png" alt="image-20220121075608980"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure>

<p>（1） <code>CREATE和DROP权限</code> ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将 MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 </p>
<p>（2） <code>SELECT、INSERT、UPDATE和DELETE权限</code> 允许在一个数据库现有的表上实施操作。 </p>
<p>（3） <code>SELECT权限</code> 只有在它们真正从一个表中检索行时才被用到。 </p>
<p>（4） <code>INDEX权限</code> 允许创建或删除索引，INDEX适用于已 有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 </p>
<p>（5） <code>ALTER权 限</code> 可以使用ALTER TABLE来更改表的结构和重新命名表。 </p>
<p>（6） <code>CREATE ROUTINE权限</code> 用来创建保存的 程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的 程序。 </p>
<p>（7） <code>GRANT权限</code> 允许授权给其他用户，可用于数据库、表和保存的程序。 </p>
<p>（8） <code>FILE权限</code> 使用 户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权 限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务 器可以访问这些文件）。</p>
<h3 id="授予权限的原则"><a href="#授予权限的原则" class="headerlink" title="授予权限的原则"></a>授予权限的原则</h3><p>权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ： </p>
<p>1、只授予能 满足需要的最小权限 ，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可 以了，不要给用户赋予update、insert或者delete权限。 </p>
<p>2、创建用户的时候 限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。 </p>
<p>3、为每个用户 设置满足密码复杂度的密码 。 </p>
<p>4、 定期清理不需要的用户 ，回收权限或者删除用户。 </p>
<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>给用户授权的方式有 2 种，分别是通过把 角色赋予用户给用户授权 和 直接给用户授权 。用户是数据库的 使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全 隐患。 </p>
<p>授权命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">GRANT 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];<br></code></pre></td></tr></table></figure>

<p>该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>比如： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> atguigudb.* <span class="hljs-keyword">TO</span> li4@localhost ;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为<span class="hljs-number">123</span>。注意这里唯独不包括<span class="hljs-keyword">grant</span>的权限<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> joe@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210159.png" alt="image-20220121080515215"></p>
<p>我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的 分组。 </p>
<p>所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据； </p>
<p>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是 删除。</p>
<p><strong>总结</strong></p>
<p>有一些程序员喜欢使用Root超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。</p>
<p>但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用Root账号。因为Root账号密码放在代码里面不安全，一旦泄露，数据库就会完全<code>失去保护</code>。</p>
<p>而且，MySQL的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p>
<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>查看当前用户权限</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">SHOW</span> GRANTS;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER();<br></code></pre></td></tr></table></figure>

<p>查看某用户的全局权限</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;主机地址&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全 性。MySQL中使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从 db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中 的账户记录使用DROP USER语句）。 </p>
<p>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</p>
<p>收回权限命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">REVOKE</span> 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n <span class="hljs-literal">ON</span> 数据库名称.表名称 FROM 用户名@用户地址;<br></code></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#收回全库全表的所有权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">FROM</span> joe@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br>#收回mysql库下的所有表的插删改查权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> mysql.* <span class="hljs-keyword">FROM</span> joe@localhost;<br></code></pre></td></tr></table></figure>

<p>注意： 须用户重新登录后才能生效</p>
<h2 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h2><p>MySQL服务器通过<code>权限表</code>来控制用户对数据库的访问，权限表存放在<code>my sql数据库</code>中。MySQL数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是<code>user表、db表</code>。除此之外，还有<code>table_priv表</code>、<code>column_priv表</code>和<code>proc_priv表</code>等。在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<h3 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210200.png" alt="image-20220121154742904"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210201.png" alt="image-20220121154629134"></p>
<h3 id="db表"><a href="#db表" class="headerlink" title="db表"></a>db表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210202.png" alt="image-20220123100714323"></p>
<h3 id="tables-priv表和columns-priv表"><a href="#tables-priv表和columns-priv表" class="headerlink" title="tables_priv表和columns_priv表"></a>tables_priv表和columns_priv表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210203.png" alt="image-20220123100703138"></p>
<h3 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210204.png" alt="image-20220121154806757"></p>
<h2 id="访问控制-了解"><a href="#访问控制-了解" class="headerlink" title="访问控制(了解)"></a>访问控制(了解)</h2><p>正常情况下，并不希望每个用户都可以执行所有的数据库操作。当MySQL允许一个用户执行各种操作时，它将首先核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为MySQL中的<code>访问控制过程</code>。MySQL的访问控制分为两个阶段：<code>连接核实阶段</code>和<code>请求核实阶段</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210205.png" alt="image-20220121160707889"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210206.png" alt="image-20220121081848851"></p>
<h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><p>角色是在<code>MySQL 8.0</code>中引入的新功能。在MysQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以拥有授予和撤消的权限。</p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关 重要的。</p>
<h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><p>创建角色使用 CREATE ROLE 语句，语法如下： </p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">CREATE</span> <span class="hljs-symbol">ROLE</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>] [,<span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>]]...<br></code></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为 空。 </p>
<p>练习：我们现在需要创建一个经理的角色，就可以用下面的代码： </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-string">&#x27;manager&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="给角色赋予权限"><a href="#给角色赋予权限" class="headerlink" title="给角色赋予权限"></a>给角色赋予权限</h3><p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>];<br></code></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，图11-43 列出了部分权限列表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">PRIVILEGES</span>\G;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210207.png" alt="image-20220121160914019"></p>
<p>练习1：我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码 来实现：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.settlement <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.goodsmaster <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.invcount <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="查看角色的权限"><a href="#查看角色的权限" class="headerlink" title="查看角色的权限"></a>查看角色的权限</h3><p>赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br><span class="hljs-section">| Grants for manager@% |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br>| GRANT USAGE ON <span class="hljs-strong">*.*</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`goodsmaster`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`invcount`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br><span class="hljs-section">| GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br></code></pre></td></tr></table></figure>

<p><strong>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是 连接登录数据库的权限 。</strong>代码的 最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权 限。 </p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。 </p>
<h3 id="回收角色的权限"><a href="#回收角色的权限" class="headerlink" title="回收角色的权限"></a>回收角色的权限</h3><p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色 授权相同。撤销角色或角色权限使用REVOKE语句。 </p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。 </p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> tablename <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;rolename&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>练习1：撤销school_write角色的权限。 </p>
<p>（1）使用如下语句撤销school_write角色的权限。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> school.* <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后使用SHOW语句查看school_write对应的权限，语句如下。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h3><p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角 色。删除角色的操作很简单，你只要掌握语法结构就行了。 </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">role</span> [,role2]...<br></code></pre></td></tr></table></figure>

<p>注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。 </p>
<p>练习：执行如下SQL删除角色school_read。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">&#x27;school_read</span>&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h3><p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语 法形式如下： </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">GRANT <span class="hljs-keyword">role</span> <span class="hljs-title">[,role2</span>,...] TO <span class="hljs-keyword">user</span> <span class="hljs-title">[,user2</span>,...];<br></code></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。 </p>
<p>练习：给kangshifu用户添加角色school_read权限。 </p>
<p>（1）使用GRANT语句给kangshifu添加school_read权 限，SQL语句如下。 </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（3）使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如 下。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_ROLE</span>();<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210208.png" alt="image-20220121161252761"></p>
<h3 id="激活角色"><a href="#激活角色" class="headerlink" title="激活角色"></a>激活角色</h3><p>方式1：使用set default role 命令激活角色 </p>
<p>举例： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>举例：使用 SET DEFAULT ROLE 为下面4个用户默认激活所有已拥有的角色如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span><br><span class="hljs-string">&#x27;dev1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;rw_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方式2：将activate_all_roles_on_login设置为ON </p>
<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| activate_all_roles_on_login | OFF |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>设置：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> GLOBAL <span class="hljs-attribute">activate_all_roles_on_login</span>=ON;<br></code></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有 权限。 </p>
<h3 id="撤销用户的角色"><a href="#撤销用户的角色" class="headerlink" title="撤销用户的角色"></a>撤销用户的角色</h3><p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure>

<p>练习：撤销kangshifu用户的school_read角色。 </p>
<p>（1）撤销的SQL语句如下 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后，执行如下查询语句，查看kangshifu用户的角色信息 执行发现，用户kangshifu之前的school_read角色已被撤销。 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="设置强制角色-mandatory-role"><a href="#设置强制角色-mandatory-role" class="headerlink" title="设置强制角色(mandatory role)"></a>设置强制角色(mandatory role)</h3><p>方式1：服务启动前设置 </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">mandatory_roles</span>=<span class="hljs-string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></code></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PERSIST <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后仍然<br>有效<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后失效<br></code></pre></td></tr></table></figure>



<h1 id="四、逻辑架构"><a href="#四、逻辑架构" class="headerlink" title="四、逻辑架构"></a>四、逻辑架构</h1><h2 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a>逻辑架构剖析</h2><p>首先MySQL是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的mysqld</p>
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示:</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210209.png" alt="image-20220123095116439"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210210.png" alt="image-20220123095127826"></p>
<h3 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a>第1层：连接层</h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是<code>建立 TCP 连接</code>。 </p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码<code>做身份认证、权限获取</code>。 </p>
<ul>
<li><p>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</p>
</li>
<li><p>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限 </p>
</li>
</ul>
<p>TCP 连接收到请求后，必须要<code>分配给一个线程专门与这个客户端的交互</code>。所以还会有个<code>线程池</code>，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h3 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a>第2层：服务层</h3><p>SQL Interface: SQL接口 </p>
<p><strong>接收用户的SQL命令，并且返回用户需要查询的结果。</strong>比如SELECT … FROM就是调用SQL Interface </p>
<p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口 </p>
<p>Parser: 解析器</p>
<p><strong>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤</strong>，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。 </p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其<strong>创建 语法树</strong> ，并根据数据字 典丰富查询语法树，会 <strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还 会对SQl查询进行<strong>语法上的优化，进行查询重写。</strong> </p>
<p>Optimizer: 查询优化器</p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 <strong>执行计划</strong> 。</p>
<p>这个执行计划表明应该 <strong>使用哪些索引</strong> 进行查询（全表检索还是使用索引检索），<strong>表之间的连 接顺序如何</strong>，最后会<strong>按照执行计划中的步骤调用存储引擎提供的方法</strong>来真正的执行查询，并将 查询结果返回给用户。 </p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> id,<span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> gender = <span class="hljs-string">&#x27;女&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 <strong>投影</strong> ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 <strong>连接</strong> 起来生成最终查询结果。</p>
<p>Caches &amp; Buffers： 查询缓存组件</p>
<p>MySQL内部维持着一些<strong>Cache和Buffer</strong>，比如Query Cache用来缓存一条SELECT语句的执行结 果，<strong>如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</strong> </p>
<p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 </p>
<p>这个查询缓存可以在 <strong>不同客户端之间共享</strong> 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</p>
<h3 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a>第3层：引擎层</h3><p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<code>插件式的存储引擎</code>架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MysQL还允许<code>开发人员设置自己的存储引擎</code>。</p>
<p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况）的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p>
<p><strong>插件式存储引擎层</strong>（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取</strong>，对物理服务器级别 维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。 </p>
<p>MySQL 8.0.25默认支持的存储引擎如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210211.png" alt="image-20220123100149104"></p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 <strong>文件系统</strong> 上，以 <strong>文件</strong> 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210212.png" alt="image-20220123100313025"></p>
<p>简化为三层结构： </p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； </li>
<li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关； </li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><h3 id="MySQL中的SQL执行流程"><a href="#MySQL中的SQL执行流程" class="headerlink" title="MySQL中的SQL执行流程"></a>MySQL中的SQL执行流程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210213.png" alt="image-20220123100934027"></p>
<p>MySQL的查询流程：</p>
<p>1、查询缓存：</p>
<p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能。 </p>
<p>大多数情况查询缓存就是个鸡肋，为什么呢？ </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> employee_id,last_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> employee_id = <span class="hljs-number">101</span>;<br></code></pre></td></tr></table></figure>

<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，<code>不是缓存查询计划，而是查询对应的结果。</code>这就意味着查询匹配的 <code>鲁棒性大大降 低 </code>，只有 <code>相同的查询操作</code>才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、 大小写），都会<code>导致缓存不会命中</code>。因此 MySQL 的 查询缓存命中率不高 。 </p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数 举例，<code>可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW</code> ，每次调用都会产生最新的当前 时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的！ </p>
<p>此外，既然是缓存，那就有它 <code>缓存失效的时候</code> 。MySQL的缓存系统会监测涉及到的每张表，只要该表的 结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高 速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。</p>
<p>2、解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210214.png" alt="image-20220123101152349"></p>
<p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> department_id,job_id,<span class="hljs-keyword">avg</span>(salary) <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> department_id;<br></code></pre></td></tr></table></figure>

<p>如果SQL语句正确，则会生成一个这样的语法树：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210215.png" alt="image-20220123101255802"></p>
<p>3、优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。 </p>
<p>举例：如下语句是执行两个表的 join：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test1 <span class="hljs-keyword">join</span> test2 <span class="hljs-keyword">using</span>(ID)<br><span class="hljs-keyword">where</span> test1.name=<span class="hljs-string">&#x27;zhangwei&#x27;</span> <span class="hljs-keyword">and</span> test2.name=<span class="hljs-string">&#x27;mysql高级课程&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方案1：可以先从表 test1 里面取出 name=’zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 ‘mysql高级课程’。 </p>
<p>方案2：可以先从表 test2 里面取出 name=’mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。 </p>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化 器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 </p>
<p>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p>
<p>在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210216.png" alt="image-20220121091908948"></p>
<p>4、执行器： </p>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210217.png" alt="image-20220123101409028"></p>
<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；<br><br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br><br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。<br></code></pre></td></tr></table></figure>



<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。 SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210218.png" alt="image-20220123101456214"></p>
<h3 id="MySQL8中SQL执行原理"><a href="#MySQL8中SQL执行原理" class="headerlink" title="MySQL8中SQL执行原理"></a>MySQL8中SQL执行原理</h3><p>前面的结构图很复杂，我们需要抓取最核心的部分: SQL的执行原理。不同的DBMS的sQL的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条SQL语句会经历不同的模块，那我们就来看下，在不同的模块中，SQL执行所使用的资源（时间)是怎样的。如何在 MysQL中对一条sQL语句的执行时间进行分析。</p>
<p>了解查询语句底层执行的过程: <code>select @@profiling;</code> 或者 <code>show variables like ‘%profiling%&#39;</code> 查看是否开启计划。开启它可以让MySQL收集在SQL执行时所使用的资源情况，命令如下:</p>
<p>1、确认profiling 是否开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@profiling</span>; <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;profiling&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210219.png" alt="image-20220123101555370"></p>
<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>2、多次执行相同SQL查询 </p>
<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employees;<br></code></pre></td></tr></table></figure>

<p>3、查看profiles </p>
<p>查看当前会话所产生的所有 profiles：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">mysql&gt; <span class="hljs-keyword">show</span> profiles; <span class="hljs-meta"># 显示最近的几次查询</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210220.png" alt="image-20220123101707949"></p>
<p>4、查看profile</p>
<p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210221.png" alt="image-20220123101731882"></p>
<p>当然你也可以查询指定的 Query ID，比如： </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">mysql&gt; <span class="hljs-keyword">show </span>profile<span class="hljs-comment">; mysql&gt; show profile for query 7;</span><br></code></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。 </p>
<p>此外，还可以查询更丰富的内容： </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210222.png" alt="image-20220123101814969"></p>
<p>继续：  </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210223.png" alt="image-20220123101830053"></p>
<h3 id="MySQL5-7中SQL执行原理"><a href="#MySQL5-7中SQL执行原理" class="headerlink" title="MySQL5.7中SQL执行原理"></a>MySQL5.7中SQL执行原理</h3><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用 缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置： </p>
<p>1、配置文件中开启查询缓存 </p>
<p>在 /etc/my.cnf 中新增一行：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>重启mysql服务 </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart mysqld</span><br></code></pre></td></tr></table></figure>

<p>3、开启查询执行计划 </p>
<p>由于重启过服务，需要重新执行如下指令，开启profiling。 </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>4、执行语句两次： </p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br></code></pre></td></tr></table></figure>

<p>5、查看profiles</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210224.png" alt="image-20220123102149177"></p>
<p>6、查看profile </p>
<p>显示执行计划，查看程序的执行步骤：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210225.png" alt="image-20220123102228217"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile for query <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210226.png" alt="image-20220123102256808"></p>
<p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中 获取数据。 </p>
<h3 id="SQL语法顺序"><a href="#SQL语法顺序" class="headerlink" title="SQL语法顺序"></a>SQL语法顺序</h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同 而动态调整执行顺序。 </p>
<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 下面是经常出现的查询顺序：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210227.png" alt="image-20220123102323930"></p>
<h3 id="Oracle中的SQL执行流程-了解"><a href="#Oracle中的SQL执行流程-了解" class="headerlink" title="Oracle中的SQL执行流程(了解)"></a>Oracle中的SQL执行流程(了解)</h3><p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用 硬解析还是软解析。 </p>
<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210228.png" alt="image-20220123102353539"></p>
<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。 </p>
<p>1.语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。 </p>
<p>2.语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统 就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。 </p>
<p>3.权限检查：看用户是否具备访问该数据的权限。</p>
<p>4.共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计 划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析 和硬解析又该怎么理解呢？ </p>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中 查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。 </p>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器” 这个步骤，这就是 硬解析 。 </p>
<p>5.优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。 </p>
<p>6.执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执 行语句了。</p>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要 缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对 象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。 </p>
<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量 避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。 </p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量 就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解 析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况 而定。 </p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br></code></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> :player_id;<br></code></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变 量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。 </p>
<p>因此，我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点， 使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。 </p>
<p>Oracle的架构图：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210229.png" alt="image-20220123102535032"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210230.png" alt="image-20220123102542352"></p>
<p>小结： </p>
<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享 池来判断是进行软解析，还是硬解析。</p>
<h2 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池(buffer pool)"></a>数据库缓冲池(buffer pool)</h2><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访 问。 </p>
<p>这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="缓冲池-vs-查询缓存"><a href="#缓冲池-vs-查询缓存" class="headerlink" title="缓冲池 vs 查询缓存"></a>缓冲池 vs 查询缓存</h3><p>缓冲池和查询缓存是一个东西吗？不是。 </p>
<h4 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h4><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。 </p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种 数据的缓存，如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210231.png" alt="image-20220123102701116"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典 信息等。 </p>
<p><strong>缓存池的重要性：</strong> </p>
<p><strong>缓存原则：</strong> </p>
<p>“ 位置 * 频次 ”这个原则，可以帮我们对 I/O 访问效率进行优化。 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲 池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。 </p>
<p><strong>缓冲池的预读特性：</strong></p>
<p>了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<code>预读</code>。</p>
<p>缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<code>大概率还会使用它周围的一些数据</code>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p>
<p><strong>如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?</strong></p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<code>以一定的频率刷新</code>到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做<code>checkpoint</code>的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirty page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>那么什么是查询缓存呢？ </p>
<p>查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。 </p>
<h3 id="什么时候使用查询缓存"><a href="#什么时候使用查询缓存" class="headerlink" title="什么时候使用查询缓存"></a>什么时候使用查询缓存</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210232.png" alt="image-20220121090932464"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210233.png" alt="image-20220123103753070"></p>
<h3 id="缓冲池如何读取数据"><a href="#缓冲池如何读取数据" class="headerlink" title="缓冲池如何读取数据"></a>缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进 行读取。 </p>
<p>缓存在数据库中的结构和作用如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210234.png" alt="image-20220123102818823"></p>
<h3 id="查看-设置缓冲池的大小"><a href="#查看-设置缓冲池的大小" class="headerlink" title="查看/设置缓冲池的大小"></a>查看/设置缓冲池的大小</h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大 小。命令如下： </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_size&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210235.png" alt="image-20220123102902971"></p>
<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">set global innodb_buffer_pool_size <span class="hljs-operator">=</span> <span class="hljs-number">268435456</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210236.png" alt="image-20220123102927306"></p>
<p>或者： </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">268435456</span><br></code></pre></td></tr></table></figure>

<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210237.png" alt="image-20220123102947321"></p>
<h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>Buffer Pool本质是InnoDB向操作系统申请的一块<code>连续的内存空间</code>，在多线程环境下，访问Buffer Pool中的数据都需要<code>加锁</code>处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<code>拆分成若干个小的Buffer Pool</code>，每个Buffer Pool都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code>的值来修改Buffer Pool实例的个数，比方说这样:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_instances</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p> 这样就表明我们要创建2个 Buffer Pool 实例。 </p>
<p>我们看下如何查看缓冲池的个数，使用命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_instances&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210238.png" alt="image-20220123103042487"></p>
<p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<h3 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>
<p>黑盒下的更新数据流程</p>
<p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于BufferPool，同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MysQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MysQL宕机了，这部分数据将会永久地丢失;</p>
<p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办?连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复?</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210239.png" alt="image-20220123103120290"></p>
<h1 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h1><h2 id="存储引擎先关配置"><a href="#存储引擎先关配置" class="headerlink" title="存储引擎先关配置"></a>存储引擎先关配置</h2><p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为MysQL server的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。所以在MySQL server完成了<code>查询优化</code>后，只需按照生成的<code>执行计划</code>调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MySQL中提到了存储引擎的概念。简而言之，<code>存储引擎就是指表的类型</code>。其实存储引擎以前叫做<code>表处理器</code>，后来改名为存储引擎，它的功能就是<code>接收上层传下来的指令</code>，<code>然后对表中的数据进行提取或写入操作</code>。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><p>查看mysql提供什么存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">show engines<span class="hljs-comment">;</span><br>show engines \G<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>引擎、是否支持、描述、事务、分布式事务、savepointer</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210240.png" alt="image-20220123104311188"></p>
<p>显式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: InnoDB<br>Support: DEFAULT<br>Comment: Supports transactions, row-level locking, and foreign keys<br>Transactions: YES<br>XA: YES<br>Savepoints: YES<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 2. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: MRG<span class="hljs-emphasis">_MYISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Collection of identical MyISAM tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 3. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MEMORY</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Hash based, stored in memory, useful for temporary tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 4. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: BLACKHOLE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: /dev/null storage engine (anything you write to it disappears)</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">2. 设置系统默认的存储引擎</span><br><span class="hljs-emphasis">查看默认的存储引擎：</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 5. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MyISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: MyISAM storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 6. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: CSV</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: CSV storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 7. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: ARCHIVE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Archive storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 8. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: PERFORMANCE_</span>SCHEMA<br>Support: YES<br>Comment: Performance Schema<br>Transactions: NO<br>XA: NO<br>Savepoints: NO<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 9. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: FEDERATED<br>Support: NO<br>Comment: Federated MySQL storage engine<br>Transactions: NULL<br>XA: NULL<br>Savepoints: NULL<br></code></pre></td></tr></table></figure>

<h3 id="设置系统默认的存储引擎"><a href="#设置系统默认的存储引擎" class="headerlink" title="设置系统默认的存储引擎"></a>设置系统默认的存储引擎</h3><p>查看默认的存储引擎：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">show</span> variables like <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br><span class="hljs-comment">#或</span><br><span class="hljs-attribute">SELECT</span> @<span class="hljs-variable">@default_storage_engine</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210241.png" alt="image-20220123104407947"></p>
<p>修改默认的存储引擎 </p>
<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">DEFAULT_STORAGE_ENGINE</span>=MyISAM;<br></code></pre></td></tr></table></figure>

<p>或者修改 my.cnf 文件：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=MyISAM<br># 重启服务<br>systemctl <span class="hljs-keyword">restart</span> mysqld.service<br></code></pre></td></tr></table></figure>

<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式。 </p>
<h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">CREATE TABLE 表名(<br>建表语句<span class="hljs-comment">;</span><br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h3><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">ALTER TABLE 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>比如我们修改一下 engine_demo_table 表的存储引擎： </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span> Duplicates: <span class="hljs-number">0</span> Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>这时我们再查看一下 engine_demo_table 的表结构：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">mysql&gt; SHOW CREATE TABLE engine<span class="hljs-emphasis">_demo_</span>table\G<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Table: engine<span class="hljs-emphasis">_demo_</span>table<br>Create Table: CREATE TABLE <span class="hljs-code">`engine_demo_table`</span> (<br><span class="hljs-code">`i`</span> int(11) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>

<h2 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h2><h3 id="InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>InnoDB 引擎：具备外键支持功能的事务存储引擎</h3><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 </p>
<p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务 的完整提交(Commit)和回滚(Rollback)。 </p>
<p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 </p>
<p>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） </p>
</li>
<li><p>表名.ibd 存储数据和索引 </p>
</li>
</ul>
<p>InnoDB是 为处理巨大数据量的最大性能设计 。 </p>
<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。 </li>
</ul>
<p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和 索引。 </p>
<p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p>
<h3 id="MyISAM-引擎：主要的非事务处理存储引擎"><a href="#MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="MyISAM 引擎：主要的非事务处理存储引擎"></a>MyISAM 引擎：主要的非事务处理存储引擎</h3><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 </p>
<p>5.5之前默认的存储引擎 </p>
<p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用 </p>
<p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构 </p>
</li>
<li><p>表名.MYD 存储数据 (MYData) </p>
</li>
<li><p>表名.MYI 存储索引 (MYIndex) </p>
</li>
</ul>
<p>应用场景：只读应用或者以读为主的业务</p>
<h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210242.png" alt="image-20220121102140263"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210243.png" alt="image-20220123105832462"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210244.png" alt="image-20220121102353775"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210245.png" alt="image-20220121103116264"></p>
<h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p>
<p>其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功 能。 </p>
<p>其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存 储引擎。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210246.png" alt="image-20220123110038734"></p>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？ </p>
<p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210247.png" alt="image-20220123110144759"></p>
<h3 id="阿里巴巴、淘宝用哪个"><a href="#阿里巴巴、淘宝用哪个" class="headerlink" title=".阿里巴巴、淘宝用哪个"></a>.阿里巴巴、淘宝用哪个</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210248.png" alt="image-20220123110239707"></p>
<p>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。 </p>
<p>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外 有更多的参数和命令来控制服务器行为。 </p>
<p>该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好 </p>
<p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p>
<h2 id="课外补充："><a href="#课外补充：" class="headerlink" title="课外补充："></a>课外补充：</h2><h3 id="1、InnoDB表的优势"><a href="#1、InnoDB表的优势" class="headerlink" title="1、InnoDB表的优势"></a>1、InnoDB表的优势</h3><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如<code>操作便利、提高了数据库的性能、维护成本低</code>等。如 果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。<code>InnoDB崩溃 恢复功能</code>自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。 </p>
<p>InnoDB存储引擎在主内存中<code>维护缓冲池</code>，高频率使用的数据将在内存中直接被处理。这种缓存方式应用 于多种信息，加速了处理进程。 </p>
<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以 设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插 入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃， 在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被 自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 <code>InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘</code> 。 </p>
<p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高 查询的速度。使用InnoDB可以压缩表和相关的索引，可以 <code>在不影响性能和可用性的情况下创建或删除索 引 </code>。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他 存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 <code>当处理大数据量时， InnoDB兼顾CPU，以达到最大性能</code> 。 </p>
<h3 id="2、InnoDB和ACID模型"><a href="#2、InnoDB和ACID模型" class="headerlink" title="2、InnoDB和ACID模型"></a>2、InnoDB和ACID模型</h3><p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应 用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不 会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的 软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只 依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p>
<p>1、原子方面 </p>
<p>ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>COMMIT语句。 </p>
<p>ROLLBACK语句。 </p>
<p>操作INFORMATION_SCHEMA库中的表数据。 </p>
<p>2、一致性方面 </p>
<p>ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性 主要包括： </p>
<p>InnoDB双写缓存。 </p>
<p>InnoDB崩溃恢复。 </p>
<p>3、隔离方面 </p>
<p>隔离是应用于事务的级别，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>SET ISOLATION LEVEL语句。 </p>
<p>InnoDB锁的低级别信息。 </p>
<p>4、耐久性方面 </p>
<p>ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样 化，耐久性方面没有具体的规则可循。与MySQL相关的特性有： </p>
<p>InnoDB双写缓存，通过innodb_doublewrite配置项配置。 </p>
<p>配置项innodb_flush_log_at_trx_commit。 </p>
<p>配置项sync_binlog。 </p>
<p>配置项innodb_file_per_table。 </p>
<p>存储设备的写入缓存。 </p>
<p>存储设备的备用电池缓存。 </p>
<p>运行MySQL的操作系统。 </p>
<p>持续的电力供应。 </p>
<p>备份策略。 </p>
<p>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</p>
<h3 id="3、InnoDB架构"><a href="#3、InnoDB架构" class="headerlink" title="3、InnoDB架构"></a>3、InnoDB架构</h3><p><strong>1.缓冲池</strong> </p>
<p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的 数据能够直接在内存中获得，从而提高速度。 </p>
<p><strong>2.更改缓存</strong> </p>
<p>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索 引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索 引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。 在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管 理。 </p>
<p><strong>3.自适应哈希索引</strong></p>
<p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行， 不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。 </p>
<p><strong>4.重做日志缓存</strong> </p>
<p>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。 </p>
<p><strong>5.系统表空间</strong> </p>
<p>系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引 数据。多表共享，系统表空间被视为共享表空间。 </p>
<p><strong>6.双写缓存</strong></p>
<p>双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存 后，InnoDB才会将数据页写入合适的位置。 </p>
<p><strong>7.撤销日志</strong> </p>
<p>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他 事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这 些片段包含于回滚片段中。 </p>
<p><strong>8.每个表一个文件的表空间</strong> </p>
<p>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数 据文件代表，该文件默认被创建在数据库目录中。 </p>
<p><strong>9.通用表空间</strong> </p>
<p>使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数 据目录之外能够管理多个表并支持所有行格式的表。 </p>
<p><strong>10.撤销表空间</strong> </p>
<p>撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces配置项配置。 </p>
<p><strong>11.临时表空间</strong></p>
<p>用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。 </p>
<p><strong>12.重做日志</strong></p>
<p>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自 动在初始化期间重新进行。</p>
<h1 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h1><h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找相关数据</code>，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个<code>索引的数据结构</code>，即这个二叉搜索树。二叉搜索树的每个结点存储的是<code>（K，V) 结构</code>，key是Col2，value是该<code>key 所在行的文件指针(地址)</code>。比如：该二叉搜索树的根节点就是（34，0x07）。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34；继续右侧数据，读89到内存，89 == 89；找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了<code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210249.png" alt="image-20220123195051911"></p>
<p><code>索引是在存储引擎中实现的</code>，因此<code>每种存储引擎的索引不一定完全相同</code>，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。所有存储引擎支持每个表<code>至少16个索引</code>，总索引长度<code>至少为256字节</code>。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<p>提示：</p>
<p>索引可以提高查询的速度，但是<code>会影响插入记录的速度</code>。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
<h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong> </p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。 </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主 要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<p> （1）创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加。</p>
<p> （2）索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 </p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<h2 id="Innode中的索引"><a href="#Innode中的索引" class="headerlink" title="Innode中的索引"></a>Innode中的索引</h2><h3 id="目录项记录页的目录页"><a href="#目录项记录页的目录页" class="headerlink" title="目录项记录页的目录页"></a>目录项记录页的目录页</h3><p>树的层次越低，加载的 页越少（页读取到内存之后，使用二分进一步查找），IO次数越少</p>
<p>一个数据页，默认 16kb</p>
<p>B+ 树：叶子节点之间用双向链表，非叶子节点之间单向链表</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210250.png" alt="image-20220123195650125"></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么： </p>
<p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。 </p>
<p>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 </p>
<p>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记 录！！！ </p>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们 通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又 因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。</p>
<h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。 </p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>（所有的用户记录都存储在了叶子节点)，也就是所谓的<code>索引即数据，数据即索引</code>。</p>
<p>术语”聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内 的记录是按照主键的大小顺序排成一个 单向链表 。 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MysQL语句中显式的使用INDEX语句去创建，<code>InnoDB</code>存储引擎会<code>自动</code>的为我们创建聚簇索引。</p>
<p><strong>特点：</strong> </p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<p>页内 的记录是按照主键的大小顺序排成一个 单向链表 。 </p>
<p>各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 </p>
<p>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p>
<p><strong>优点：</strong> </p>
<p>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 </p>
<p>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 </p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。 </p>
<p><strong>缺点：</strong> </p>
<p>1、插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 </p>
<p>2、更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新 </p>
<p>3、二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据 </p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<p><strong>限制：</strong></p>
<p>1、对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。</p>
<p>2、由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>3、如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。|</p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><blockquote>
<p>二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。</p>
</blockquote>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210251.png" alt="image-20220123091747335"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210252.png" alt="image-20220123091441479"></p>
<p><strong>概念：回表</strong> </p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！ </p>
<p><strong>问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</strong></p>
<p><strong>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</strong></p>
<p>1、聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</p>
<p>2、一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</p>
<p>3、使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<p>1、先把各个记录和页按照c2列进行排序。 </p>
<p>2、在记录的c2列相同的情况下，采用c3列进行排序</p>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p>
<p>1、建立 联合索引 只会建立如上图一样的1棵B+树。 </p>
<p>2、为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210253.png" alt="image-20220123094039750"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210254.png" alt="image-20220123094343764"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210255.png" alt="image-20220123094446434"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210256.png" alt="image-20220123094744274"></p>
<h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根页面位置万年不动"><a href="#根页面位置万年不动" class="headerlink" title="根页面位置万年不动"></a>根页面位置万年不动</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210257.png" alt="image-20220123202403635"></p>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210258.png" alt="image-20220123202445109"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210259.png" alt="image-20220123202455155"></p>
<h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210300.png" alt="image-20220123202415852"></p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>B树索引适用存储引擎如表所示： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210301.png" alt="image-20220123202552912"></p>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。</p>
<p>Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。 </p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，<strong>叶子节点的data域存放的是 数据记录的地址 。</strong></p>
<h3 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210302.png" alt="image-20220123202626492"></p>
<p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210303.png" alt="image-20220123202831722"></p>
<h3 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区 别：</strong> </p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。 </p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。 </p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。 </p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： </p>
<p><strong>空间上的代价</strong> </p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。 </p>
<p><strong>时间上的代价</strong> </p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h2><p>从MysQL的角度讲，不得不考虑一个现实问题就是磁盘I0。如果我们能让索引的数据结构尽量<code>减少硬盘的I/O操作</code>，所消耗的时间也就越小。可以说，磁盘的I/O操作次数对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘上的。</strong>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MysQL衡量查询效率的标准就是磁盘I/O次数。</p>
<h3 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h3><p>略</p>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210304.png" alt="image-20220123203956171"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210305.png" alt="image-20220123204007505"></p>
<h3 id="自适应式哈希"><a href="#自适应式哈希" class="headerlink" title="自适应式哈希"></a>自适应式哈希</h3><p>InnoDB会监控对表上各索引页的查询，如果观察该数据被访问的频次符合规则，那么就建立哈希索引来加快数据访问的速度，这个哈希索引称之为”<strong>Adaptive Hash Index,AHI</strong>“,AHI是通过缓冲池的B+树页构建的，建立的速度很快，而且不对整颗树都建立哈希索引。(可以理解成热点的数据才会进入这个哈希表)</p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。 </p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如： </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">mysql&gt; show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%adaptive_hash_index&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210306.png" alt="image-20220123203315740"></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210307.png" alt="image-20220123204105287"></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210308.png" alt="image-20220123204147288"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210309.png" alt="image-20220123204206739"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210310.png" alt="image-20220123204216682"></p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210311.png" alt="image-20220123204230149"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210312.png" alt="image-20220123204313188"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210313.png" alt="image-20220123204325576"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210314.png" alt="image-20220123204335710"></p>
<h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210315.png" alt="image-20220123204353865"></p>
<h2 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h2><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210316.png" alt="image-20220123204424866"></p>
<h1 id="七、InnoDB数据存储结构"><a href="#七、InnoDB数据存储结构" class="headerlink" title="七、InnoDB数据存储结构"></a>七、InnoDB数据存储结构</h1><h2 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p>
<h3 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210317.png" alt="image-20220123171731077"></p>
<h3 id="页结构概述-页的大小"><a href="#页结构概述-页的大小" class="headerlink" title="页结构概述/页的大小"></a>页结构概述/页的大小</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210318.png" alt="image-20220123171810345"></p>
<h3 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210319.png" alt="image-20220123171900691"></p>
<h2 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210320.png" alt="image-20220123171932421"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210321.png" alt="image-20220123172018972"></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="FileHeader（文件头部）"><a href="#FileHeader（文件头部）" class="headerlink" title="FileHeader（文件头部）"></a>FileHeader（文件头部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210322.png" alt="image-20220123172224825"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210323.png" alt="image-20220123172540410"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210324.png" alt="image-20220123172556371"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210325.png" alt="image-20220123172609036"></p>
<h4 id="File-Trailer（文件尾部）"><a href="#File-Trailer（文件尾部）" class="headerlink" title="File Trailer（文件尾部）"></a>File Trailer（文件尾部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210326.png" alt="image-20220123172719823"></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210327.png" alt="image-20220123172831136"></p>
<h4 id="FreeSpace（空闲空间）"><a href="#FreeSpace（空闲空间）" class="headerlink" title="FreeSpace（空闲空间）"></a>FreeSpace（空闲空间）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210328.png" alt="image-20220123172859640"></p>
<h4 id="UserRecords（用户记录）"><a href="#UserRecords（用户记录）" class="headerlink" title="UserRecords（用户记录）"></a>UserRecords（用户记录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210329.png" alt="image-20220123172911774"></p>
<h4 id="Infimum-Supremum（最小最大记录）"><a href="#Infimum-Supremum（最小最大记录）" class="headerlink" title="Infimum+Supremum（最小最大记录）"></a>Infimum+Supremum（最小最大记录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210330.png" alt="image-20220123172946473"></p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><h4 id="PageDirectory（页目录）"><a href="#PageDirectory（页目录）" class="headerlink" title="PageDirectory（页目录）"></a>PageDirectory（页目录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210331.png" alt="image-20220123173407883"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210332.png" alt="image-20220123173452062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210333.png" alt="image-20220123173512149"></p>
<h5 id="页目录分组的个数如何确定"><a href="#页目录分组的个数如何确定" class="headerlink" title="页目录分组的个数如何确定?"></a>页目录分组的个数如何确定?</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210334.png" alt="image-20220123173533141"></p>
<h5 id="页目录结构下如何快速查找记录"><a href="#页目录结构下如何快速查找记录" class="headerlink" title="页目录结构下如何快速查找记录?"></a>页目录结构下如何快速查找记录?</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210335.png" alt="image-20220123173658766"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210336.png" alt="image-20220123173707547"></p>
<h4 id="PageHeader（页面头部）"><a href="#PageHeader（页面头部）" class="headerlink" title="PageHeader（页面头部）"></a>PageHeader（页面头部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210337.png" alt="image-20220123173858788"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210338.png" alt="image-20220123173940900"></p>
<h2 id="InnoDB行格式（或记录格式）"><a href="#InnoDB行格式（或记录格式）" class="headerlink" title="InnoDB行格式（或记录格式）"></a>InnoDB行格式（或记录格式）</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210339.png" alt="image-20220123174014918"></p>
<h1 id="八、索引的创建与设计原则"><a href="#八、索引的创建与设计原则" class="headerlink" title="八、索引的创建与设计原则"></a>八、索引的创建与设计原则</h1><h2 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a>索引的声明与使用</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 </p>
<p>从 <code>功能逻辑</code> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p>
<p>按照 <code>物理实现方式</code> ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p>
<p>按照 <code>作用字段个数</code> 进行划分，分成单列索引和联合索引。</p>
<p>1.普通索引</p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表<br>student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p>2.唯一性索引</p>
<p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯—量可以更快速地确定某条记录。</p>
<p>3.主键索引</p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE 一张表里最多只有一个主键索引。</p>
<p>Why?这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p>4.单列索引</p>
<p>在表中的单个字段上创建索引。单列索引央根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<p>5.多列(组合、联合)索引</p>
<p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<p>6.全文索引</p>
<p>全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。</p>
<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、ElasticSearch等专门的搜索引擎所替代。</p>
<p>7.补充：空间索引</p>
<p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p>小结：不同的存储引擎支持的索引类型也不一样</p>
<p>nnoDB：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>MylSAM：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>Memory：支持B-tree、Hash等索引，不支持Full-text索引;</p>
<p>NDB：支持Hash索引，不支持 B-tree、Full-text等索引;</p>
<p>Archive：不支持B-tree、Hash、Full-text等索引;</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span>,<br>dept_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> emp_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY(dept_id) <span class="hljs-keyword">REFERENCES</span> dept(dept_id)<br>);<br></code></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name [col_name data_type]<br>[<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY] [index_name] (col_name [length]) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span><br><span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </p>
<p>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </p>
<p>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </p>
<p>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </p>
<p>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </p>
<p>ASC 或 DESC 指定升序或者降序的索引值存储。 </p>
<h5 id="1-创建普通索引"><a href="#1-创建普通索引" class="headerlink" title="1.创建普通索引"></a>1.创建普通索引</h5><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> book(<br>book_id <span class="hljs-type">INT</span> ,<br>book_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>authors <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) ,<br>comment <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>year_publication <span class="hljs-keyword">YEAR</span>,<br>INDEX(year_publication)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="2-创建唯一索引"><a href="#2-创建唯一索引" class="headerlink" title="2.创建唯一索引"></a>2.创建唯一索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test1(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX uk_idx_id(id)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> test1 \G<br></code></pre></td></tr></table></figure>

<h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法： </p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT ,<br>student_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>student_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY(id)<br>);<br></code></pre></td></tr></table></figure>

<p>删除主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">PRIMARY</span> KEY ;<br></code></pre></td></tr></table></figure>

<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引 </p>
<h5 id="4-创建单列索引"><a href="#4-创建单列索引" class="headerlink" title="4.创建单列索引"></a>4.创建单列索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test2(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span>,<br>INDEX single_idx_name(name(<span class="hljs-number">20</span>))<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test2 \G<br></code></pre></td></tr></table></figure>

<h5 id="5-创建组合索引"><a href="#5-创建组合索引" class="headerlink" title="5.创建组合索引"></a>5.创建组合索引</h5><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test3(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>INDEX multi_idx(id,name,age)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW INDEX 查看： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test3 \G<br></code></pre></td></tr></table></figure>

<h5 id="6-创建全文索引"><a href="#6-创建全文索引" class="headerlink" title="6.创建全文索引"></a>6.创建全文索引</h5><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test4(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>FULLTEXT INDEX futxt_idx_info(info)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
<p>举例2： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> articles (<br>id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>title <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">200</span>),<br>body TEXT,<br>FULLTEXT index (title, body)<br>) ENGINE <span class="hljs-operator">=</span> INNODB ;<br></code></pre></td></tr></table></figure>

<p>创建了一个给title和body字段添加全文索引的表。 </p>
<p>举例3：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `papers` (<br>`id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`title` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>FULLTEXT KEY `title` (`title`,`content`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure>

<p>不同于like方式的的查询： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> content <span class="hljs-keyword">LIKE</span> ‘<span class="hljs-operator">%</span>查询字符串<span class="hljs-operator">%</span>’;<br></code></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);<br></code></pre></td></tr></table></figure>

<p><strong>注意点</strong> </p>
<p>1.使用全文索引前，搞清楚版本支持情况； </p>
<p>2.全文索引比 like + % 快 N 倍，但是可能存在精度问题； </p>
<p>3.如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</p>
<h5 id="7-创建空间索引"><a href="#7-创建空间索引" class="headerlink" title="7.创建空间索引"></a>7.创建空间索引</h5><p>空间索引创建中，要求空间类型的字段必须为 <code>非空 </code>。 </p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test5(<br>geo GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>SPATIAL INDEX spa_idx_geo(geo)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<h4 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。 </p>
<p><strong>1.使用ALTER TABLE语句创建索引</strong> </p>
<p>ALTER TABLE语句创建索引的基本语法如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY]<br>[index_name] (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p><strong>2.使用CREATE INDEX创建索引</strong> </p>
<p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><strong>1.使用ALTER TABLE删除索引</strong> </p>
<p>ALTER TABLE删除索引的基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure>

<p><strong>2.使用DROP INDEX语句删除索引</strong> </p>
<p>DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>

<p>提示：</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成 索引的所有列都被删除，则整个索引将被删除。</p>
<h2 id="MySQL8索引新特性"><a href="#MySQL8索引新特性" class="headerlink" title="MySQL8索引新特性"></a>MySQL8索引新特性</h2><h3 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h3><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ts1(a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span>,index idx_a_b(a,b <span class="hljs-keyword">desc</span>));<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210340.png" alt="image-20220124093009807"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210341.png" alt="image-20220124093056738"></p>
<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。 </p>
<blockquote>
<p>提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员 可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。 </p>
</blockquote>
<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用 Using filesort。 </p>
<blockquote>
<p>注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述 查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。 </p>
</blockquote>
<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本 中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a <span class="hljs-keyword">DESC</span>,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>在MySQL 8.0版本中查看数据表ts1的执行计划。 </p>
<p>从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210342.png" alt="image-20220124092321533"></p>
<h1 id="十三、事务基础知识"><a href="#十三、事务基础知识" class="headerlink" title="十三、事务基础知识"></a>十三、事务基础知识</h1><h2 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持<code>一致性</code>，同时我们还能通过事务的机制<code>恢复到某个时间点</code>，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h3 id="存储引擎支持情况"><a href="#存储引擎支持情况" class="headerlink" title="存储引擎支持情况"></a>存储引擎支持情况</h3><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。 </p>
<p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210343.png" alt="image-20220125165016772"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。 </p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210344.png" alt="image-20220125165049411"></p>
<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><h4 id="原子性（atomicity）："><a href="#原子性（atomicity）：" class="headerlink" title="原子性（atomicity）："></a>原子性（atomicity）：</h4><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 </p>
<h4 id="一致性（consistency）："><a href="#一致性（consistency）：" class="headerlink" title="一致性（consistency）："></a>一致性（consistency）：</h4><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述） </p>
<p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态 是 语义上 的而不是语法上的，跟具体的业务有关。 </p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己 来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。 </p>
<p>举例1：A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;=0。</p>
<p>举例2：A账户2o0元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。</p>
<p>举例3：在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</p>
<h4 id="隔离型（isolation）："><a href="#隔离型（isolation）：" class="headerlink" title="隔离型（isolation）："></a>隔离型（isolation）：</h4><p>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 </p>
<p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210345.png" alt="image-20220125165436801"></p>
<h4 id="持久性（durability）："><a href="#持久性（durability）：" class="headerlink" title="持久性（durability）："></a>持久性（durability）：</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。 </p>
<p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 事务 大致划分成几个状态： </p>
<h4 id="活动的（active）"><a href="#活动的（active）" class="headerlink" title="活动的（active）"></a>活动的（active）</h4><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。 </p>
<h4 id="部分提交的（partially-committed）"><a href="#部分提交的（partially-committed）" class="headerlink" title="部分提交的（partially committed）"></a>部分提交的（partially committed）</h4><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘 时，我们就说该事务处在 部分提交的 状态。 </p>
<h4 id="失败的（failed）"><a href="#失败的（failed）" class="headerlink" title="失败的（failed）"></a>失败的（failed）</h4><p>当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。 </p>
<h4 id="中止的（aborted）"><a href="#中止的（aborted）" class="headerlink" title="中止的（aborted）"></a>中止的（aborted）</h4><p>如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称 之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 中止的 状态。 </p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money - <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;AA&#x27;</span>;<br>UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money + <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BB&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="提交的（committed）"><a href="#提交的（committed）" class="headerlink" title="提交的（committed）"></a>提交的（committed）</h4><p>当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处 在了 提交的 状态。 一个基本的状态转换图如下所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210346.png" alt="image-20220125165704463"></p>
<h2 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h2><p>使用事务有两种方式，分别为 <code>显式事务</code> 和<code> 隐式事务</code> 。 </p>
<h3 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h3><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>#或者<br>mysql&gt; START TRANSACTION;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>后面可以跟: <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span> / <span class="hljs-keyword">read</span> <span class="hljs-keyword">write</span>(默认) / <span class="hljs-keyword">with</span> consistent <span class="hljs-keyword">snapshot</span><br></code></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：</p>
<p>① READ ONLY ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不 能修改数据。 </p>
<p>② READ WRITE ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。 </p>
<p>③ WITH CONSISTENT SNAPSHOT ：启动一致性读。 </p>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL） </p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 回滚事务。即撤销正在进行的所有没有提交的修改<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br># 将事务回滚到某个保存点。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> [<span class="hljs-keyword">SAVEPOINT</span>]<br></code></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。<br><span class="hljs-keyword">SAVEPOINT</span> 保存点名称;<br><br># 删除某个保存点。<br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名称:<br></code></pre></td></tr></table></figure>



<h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>每条DML语句都是一条独立的事务。</p>
<p>针对于DML操作是有效的，对DDL操作是无效的。</p>
<p>关闭了自动提交之后，写语句要自己 commit，否则会<code>锁表</code></p>
<p>MySQL中有一个系统变量 autocommit ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> autocommit <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种 自动提交 的功能，可以使用下边两种方法之一： </p>
<p>显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回 滚前会暂时关闭掉自动提交的功能。 </p>
<p>把系统变量 autocommit 的值设置为 OFF ，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> OFF;<br>#或<br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210347.png" alt="image-20220125172112442"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210348.png" alt="image-20220125172120904"></p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。 </p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个<code>会话（ Session ）</code>。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理 多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影响太大 ，我们既想保持 事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取 舍了。</p>
<h3 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题： </p>
<p><strong>脏写（ Dirty Write ）</strong> </p>
<p>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数 据，那就意味着发生了 脏写</p>
<p><strong>脏读（ Dirty Read ）</strong></p>
<p>对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。 之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。 </p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象 就称之为 脏读 。 </p>
<p><strong>不可重复读（ Non-Repeatable Read ）</strong> </p>
<p>对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后 Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。 </p>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看 到最新的值，这种现象也被称之为 不可重复读 。 </p>
<p><strong>幻读（ Phantom ）</strong> </p>
<p>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。 </p>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 幻影记录 。</p>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序： </p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并 发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ： </p>
<p>READ UNCOMMITTED ：</p>
<p>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。 </p>
<p>READ COMMITTED ：</p>
<p>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。 </p>
<p>REPEATABLE READ ：</p>
<p>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。 </p>
<p>SERIALIZABLE ：</p>
<p>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。 </p>
<p>SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210349.png" alt="image-20220125173629691"></p>
<p>脏写 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。 不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210350.png" alt="image-20220125173641123"></p>
<h3 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h3><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本之前：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;tx_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> tx_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br># MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation<br><br># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本及之后：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;transaction_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> transaction_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.02</span> sec)<br><br>#或者不同MySQL版本中都可以使用的：<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><br></code></pre></td></tr></table></figure>

<h3 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h3><p><strong>通过下面的语句修改事务的隔离级别：</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;<br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>或者： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;隔离级别&#x27;</span><br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE<span class="hljs-operator">-</span>READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响： </p>
<p>使用 GLOBAL 关键字（在全局范围影响）： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>当前已经存在的会话无效 </p>
</li>
<li><p>只对执行完该语句之后产生的会话起作用 </p>
</li>
</ul>
<p>使用 SESSION 关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>对当前会话的所有后续的事务有效 </p>
</li>
<li><p>如果在事务之间执行，则对后续的事务有效 </p>
</li>
<li><p>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</p>
</li>
</ul>
<blockquote>
<p>小结： </p>
<p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性 就越好，但并发性越弱。</p>
</blockquote>
<h2 id="事务的常见分类"><a href="#事务的常见分类" class="headerlink" title="事务的常见分类"></a>事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型： </p>
<p>扁平事务（Flat Transactions） </p>
<p>带有保存点的扁平事务（Flat Transactions with Savepoints） </p>
<p>链事务（Chained Transactions） </p>
<p>嵌套事务（Nested Transactions） </p>
<p>分布式事务（Distributed Transactions）</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210351.png" alt="image-20220125174041369"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210352.png" alt="image-20220125174109035"></p>
<h1 id="十四、MySQL事务日志"><a href="#十四、MySQL事务日志" class="headerlink" title="十四、MySQL事务日志"></a>十四、MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？ </p>
<p>事务的隔离性由 <code>锁机制</code> 实现。 </p>
<p>而事务的原子性、一致性和持久性由<code>事务的 redo 日志</code>和<code>undo 日志</code>来保证。 </p>
<p>REDO LOG 称为 <code>重做日志</code> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。 </p>
<p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。 </p>
<p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。</p>
<table>
<thead>
<tr>
<th></th>
<th>undo日志</th>
<th>redo日志</th>
</tr>
</thead>
<tbody><tr>
<td>用来保证</td>
<td>持久性</td>
<td>原子性、一致性</td>
</tr>
<tr>
<td>记录的是</td>
<td>物理级别上页的修改操作</td>
<td>逻辑日志</td>
</tr>
<tr>
<td>主要作用</td>
<td>保证数据的可靠性</td>
<td>事务回滚、MVCC</td>
</tr>
<tr>
<td>产生位置</td>
<td>存储引擎层</td>
<td>数据库层</td>
</tr>
<tr>
<td>产生时机</td>
<td>事务执行过程中</td>
<td>事务提交时</td>
</tr>
<tr>
<td>组成部分</td>
<td>redo log buffer 、redo log file</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到<code>内存中的Buffer Pool</code>之后才可以访问。所有的变更都必须先<code>更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘（ <code>checkPoint机制</code>），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h3 id="为什么需要REDO日志"><a href="#为什么需要REDO日志" class="headerlink" title="为什么需要REDO日志"></a>为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发 </code>的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。 </p>
<p>另一方面，事务包含 <code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩 溃，这个事务对数据库中所做的更改也不能丢失。 </p>
<p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题：</p>
<p>1、修改量与刷新磁盘工作量严重不成比例</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在innoDB中是以页为单位来进行磁盘lo的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p>
<p>2、随机IO刷新较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机Io比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
<p><code>另一个解决的思路 ：</code>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2 。</p>
<p>InnoDB引擎的事务采用了WAL技术(（Write-Ahead Logging )，这种技术的思想就是<code>先写日志，再写磁盘</code>，<code>只有日志写入成功，才算事务提交成功</code>，这里的日志就是<code>redo log</code>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210353.png" alt="image-20220126163216220"></p>
<h3 id="REDO日志的好处、特点"><a href="#REDO日志的好处、特点" class="headerlink" title="REDO日志的好处、特点"></a>REDO日志的好处、特点</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>redo日志降低了刷盘频率 </p>
<p>redo日志占用的空间非常小</p>
<ul>
<li>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>redo日志是顺序写入磁盘的</strong></p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快。</p>
<p><strong>事务执行过程中，redo log不断记录</strong></p>
<p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<h3 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h3><p>Redo log可以简单分为以下两个部分： </p>
<p>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。 </p>
<p>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210354.png" alt="image-20220126164106278"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210355.png" alt="image-20220126164116794"></p>
<h3 id="redo的整体流程"><a href="#redo的整体流程" class="headerlink" title="redo的整体流程"></a>redo的整体流程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210356.png" alt="image-20220126164250628"></p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<h3 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一 定的频率 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210357.png" alt="image-20220126164334492"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存 （page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系 统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。 </p>
<p>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略： </p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） </p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210358.png" alt="image-20220126164459943"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210359.png" alt="image-20220126164511633"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210400.png" alt="image-20220126164523067"></p>
<h3 id="不同刷盘策略演示"><a href="#不同刷盘策略演示" class="headerlink" title="不同刷盘策略演示"></a>不同刷盘策略演示</h3><p>流程图</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210401.png" alt="image-20220126164550158"></p>
<p>小结: innodb_flush_log_at_trx_commit=1</p>
<p>为1时,只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失,但是<code>效率最差</code>的。</p>
<p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210402.png" alt="image-20220126164557233"></p>
<p>小结：innodb_flush_log_at_trx_commit=2</p>
<p>为2时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存（page cache )。</p>
<p>如果仅仅只是MySQL挂了不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210403.png" alt="image-20220126164603143"></p>
<p>小结: innodb_flush_log_at_trx_commit=0</p>
<p>为0时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p>
<p>数值o的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，也无法保证D。</p>
<h3 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h3><h4 id="补充概念：Mini-Transaction"><a href="#补充概念：Mini-Transaction" class="headerlink" title="补充概念：Mini-Transaction"></a>补充概念：Mini-Transaction</h4><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210404.png" alt="image-20220126164811826"></p>
<h4 id="redo-日志写入log-buffer"><a href="#redo-日志写入log-buffer" class="headerlink" title="redo 日志写入log buffer"></a>redo 日志写入log buffer</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210405.png" alt="image-20220126164841075"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210406.png" alt="image-20220126164849968"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210407.png" alt="image-20220126164900488"></p>
<h4 id="redo-log-block的结构图"><a href="#redo-log-block的结构图" class="headerlink" title="redo log block的结构图"></a>redo log block的结构图</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210408.png" alt="image-20220126165004100"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210409.png" alt="image-20220126165019180"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210410.png" alt="image-20220126165025786"></p>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><h4 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210411.png" alt="image-20220126165107986"></p>
<h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210412.png" alt="image-20220126165125652"></p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210413.png" alt="image-20220126165156959"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210414.png" alt="image-20220126165204252"></p>
<h3 id="redolog小结"><a href="#redolog小结" class="headerlink" title="redolog小结"></a>redolog小结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210415.png" alt="image-20220126165229526"></p>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要 先写入一个 undo log 。 </p>
<h3 id="如何理解undo日志"><a href="#如何理解undo日志" class="headerlink" title="如何理解undo日志"></a>如何理解undo日志</h3><p>事务需要保证 原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半 会出现一些情况，比如： </p>
<p>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突 然 断电 导致的错误。 </p>
<p>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行。 以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 回滚 ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 原子性 要求。</p>
<p>每当我们要对一条记录做<code>改动</code>时(这里的改动可以指INSERT、DELETE、UPDATE)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p>
<p>你<code>插入一条记录时</code>，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</p>
<p>你<code>删除了一条记录</code>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</p>
<p>你<code>修改了一条记录</code>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,I将修改前的行放回去)</p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即undo log )。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log 会<code>产生 redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h3 id="undo日志的作用"><a href="#undo日志的作用" class="headerlink" title="undo日志的作用"></a>undo日志的作用</h3><p><strong>作用1：回滚数据</strong></p>
<p>用户对undo日志可能<code>有误解</code>：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p><strong>作用2: MVCC</strong></p>
<p>undo的另一个作用是MVcd，即在InnoDB存储引擎中MVcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
<h3 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h3><h4 id="回滚段与undo页"><a href="#回滚段与undo页" class="headerlink" title="回滚段与undo页"></a>回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了 1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。 </p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务 限制为 1024 。虽然对绝大多数的应用来说都已经够用。 </p>
<p>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到 了 128*1024 。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_undo_logs&#x27;;</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| innodb_undo_logs | 128 |</span><br><span class="hljs-section">+------------------+-------+</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210416.png" alt="image-20220126165928819"></p>
<h4 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h4><p>1、每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。 </p>
<p>2、当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 据会被复制到回滚段。 </p>
<p>3、在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。 </p>
<p>4、回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210417.png" alt="image-20220126170027157"></p>
<p>5、当事务提交时，InnoDB存储引擎会做以下两件事情： </p>
<ul>
<li><p>将undo log放入列表中，以供之后的purge操作 </p>
</li>
<li><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
</li>
</ul>
<h4 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h4><p>1.未提交的回滚数据(uncommitted undo information) ∶该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p>
<p>2.已经提交但未过期的回滚数据(committed undo information) : 该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</p>
<p>3.事务已经提交并过期的数据(expired undo information)：事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</p>
<p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>
<h3 id="undo的类型"><a href="#undo的类型" class="headerlink" title="undo的类型"></a>undo的类型</h3><p>在InnoDB存储引擎中，undo log分为： </p>
<p>insert undo log </p>
<p>update undo log</p>
<p>insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
<p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h3 id="undo-log的生命周期"><a href="#undo-log的生命周期" class="headerlink" title="undo log的生命周期"></a>undo log的生命周期</h3><h4 id="简要生成过程"><a href="#简要生成过程" class="headerlink" title="简要生成过程"></a>简要生成过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210418.png" alt="image-20220126170334099"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210419.png" alt="image-20220126170342843"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210420.png" alt="image-20220126170351424"></p>
<p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p>
<h4 id="详细生成过程"><a href="#详细生成过程" class="headerlink" title="详细生成过程"></a>详细生成过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210421.png" alt="image-20220126170435107"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210422.png" alt="image-20220126170446833"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210423.png" alt="image-20220126170457631"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210424.png" alt="image-20220126170506463"></p>
<h4 id="undo-log是如何回滚的"><a href="#undo-log是如何回滚的" class="headerlink" title="undo log是如何回滚的"></a>undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样： </p>
<p>1.通过undo no=3的日志把id=2的数据删除 </p>
<p>2.通过undo no=2的日志把id=1的数据的deletemark还原成0 </p>
<p>3.通过undo no=1的日志把id=1的数据的name还原成Tom </p>
<p>4.通过undo no=0的日志把id=1的数据删除 </p>
<h4 id="undo-log的删除"><a href="#undo-log的删除" class="headerlink" title="undo log的删除"></a>undo log的删除</h4><p><strong>针对于insert undo log</strong> </p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删 除，不需要进行purge操作。 </p>
<p><strong>针对于update undo log</strong> </p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等 待purge线程进行最后的删除。</p>
<p>补充:</p>
<p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清除page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种”假删除”;只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210425.png" alt="image-20220126170656837"></p>
<h1 id="十五、锁"><a href="#十五、锁" class="headerlink" title="十五、锁"></a>十五、锁</h1><p>事务的<code> 隔离性</code> 由这章讲述的 <code>锁</code> 来实现。 </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>锁是计算机协调多个进程或线程<code>并发访问莱一资源</code>的机制。在程序开发中会存在<code>多线程同步</code>的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了<code>保证数据的一致性</code>，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。  </p>
<h2 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种： </p>
<h3 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h3><p>读-读 情况，即并发事务相继 <code>读取相同的记录</code> 。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。 </p>
<h3 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。 </p>
<p>在这种情况下<code>会发生 脏写 </code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓 的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210426.png" alt="image-20220128085542663"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构 </code>，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210427.png" alt="image-20220128085549070"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210428.png" alt="image-20220128085615584"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210429.png" alt="image-20220128085624956"></p>
<p>小结几种说法： </p>
<p><strong>不加锁</strong> </p>
<p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。 </p>
<p><strong>获取锁成功，或者加锁成功</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。 </p>
<p><strong>获取锁失败，或者加锁失败，或者没有获取到锁</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 需要等待，不可以继续执行操作。</p>
<h3 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重 复读 、 幻读 的问题。 </p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经 解决了 幻读 问题。 </p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决 <code>脏读</code> 、 <code>不可重复读</code> 、 <code>幻读</code> 这些问题呢？其实有两种可选的解决方案： </p>
<p><strong>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。</strong> </p>
<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到<code>符合条件的记录版本</code>（历史版本由<code>undo日志</code>构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadVview之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写操作并不冲突</code>。</p>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。 </p>
<ul>
<li><p>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就 是避免了脏读现象； </p>
</li>
<li><p>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会 生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读 和幻读的问题。 </p>
</li>
</ul>
<p><strong>方案二：读、写操作都采用 加锁 的方式。</strong> </p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p>
<p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p>
<p><strong>小结对比发现：</strong> </p>
<p>采用 <code>MVCC</code> 方式的话， <code>读-写</code> 操作彼此并不冲突， 性能更高 。 </p>
<p>采用 <code>加锁</code> 方式的话， <code>读-写</code> 操作彼此需要 排队执行 ，影响性能。 </p>
<p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
<h2 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210430.png" alt="image-20220128090524948"></p>
<h3 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写 或 写-读 这些情况可能会引起一些问题，需要使用WVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于<code>既要允许读-读情况不受影响</code>，<code>又要使写-写、读-写或写-读情况中的操作相互阻塞</code>，所以MysSQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁(Shared Lock，SLock)和排他锁(Exclusive Lock，XLock),也叫读锁（readlock)和写锁(write lock)。</p>
<p><code>读锁</code> ：也称为<code> 共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。 </p>
<p><code>写锁</code> ：也称为<code> 排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。 </p>
<p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210431.png" alt="image-20220128090725535"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210432.png" alt="image-20220128090742089"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210433.png" alt="image-20220128090753730"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210434.png" alt="image-20220128090812907"></p>
<h3 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h3><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h4><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 S锁 或者 X锁 的。在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 <code>MDL</code> ）结构来实现的。 </p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 <code>崩溃恢复 </code>过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取 InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写： </p>
<ul>
<li><p>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 </p>
</li>
<li><p>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。 </p>
</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 行锁 ，关于 InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210435.png" alt="image-20220128091028657"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210436.png" alt="image-20220128091036865"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210437.png" alt="image-20220128091053120"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210438.png" alt="image-20220128091104143"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210439.png" alt="image-20220128091119368"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210440.png" alt="image-20220128091133594"></p>
<h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p><strong>意向锁的出现是为了协调行锁和表锁的关系，支持多粒度的表锁。</strong></p>
<p>在没有意向锁的时候，如果事务A对表中的数据加了行锁，此时事务B想要对这个表加页锁，那么事务B就首先需要通过遍历的方式判断这个表中的每一行数据是不是有表锁，当数据量比较大的时候，浪费时间</p>
<p>为了解决此问题，使用了意向锁。如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<p>InnoDB 支持 <code>多粒度锁</code>（multiple granularity locking） ，它<code>允许 行级锁 与 表级锁 共存</code>，而意向 锁就是其中的一种 <code>表锁</code> 。 </p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存。</p>
<p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p>
<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p><strong>意向锁分为两种：</strong> </p>
<p>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br></code></pre></td></tr></table></figure>

<p>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p><strong>1.意向锁要解决的问题</strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p>
<p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<ul>
<li><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</p>
</li>
<li><p>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</p>
</li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210441.png" alt="image-20220128091708393"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210442.png" alt="image-20220128091716562"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210443.png" alt="image-20220128091731490"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210444.png" alt="image-20220128091748452"></p>
<p><strong>意向锁的并发性</strong></p>
<p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 他锁时的并发性。（不然我们直接用普通的表锁就行了） </p>
<p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可 能存在多种不同锁，但是这里我们只着重表现意向锁）。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210445.png" alt="image-20220128091812208"></p>
<p><strong>从上面的案例可以得到如下结论：</strong> </p>
<p>1.InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。 </p>
<p>2.意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。 </p>
<p>3.IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </p>
<p>4.意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</p>
<h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `teacher` (<br>`id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `teacher` (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>), (<span class="hljs-string">&#x27;lisi&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> lisi <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。 </p>
<p><strong>1.“Simple inserts” （简单插入）</strong> </p>
<p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行 INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。 </p>
<p><strong>2.“Bulk inserts” （批量插入）</strong> </p>
<p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p>
<p><strong>3.“Mixed-mode inserts” （混合模式插入）</strong> </p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混 合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210446.png" alt="image-20220128092234241"></p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式： </p>
<p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式) </code></p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。 </p>
<p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式) </code></p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。 </p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。 </p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p>
<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式) </code></p>
<p>从 MySQL 8.0 开始，交错锁模式是 默认 设置。 </p>
<p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但 是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能 不是连续的。</p>
<p>如果执行的语句是”simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 </p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</strong></p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210447.png" alt="image-20220128092444808"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210448.png" alt="image-20220128092453945"></p>
<h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2.InnoDB中的行锁"></a>2.InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p>
<p>优点：锁定力度小，发生锁冲突概率低，可以实现的并发度高。</p>
<p>缺点：对于锁的开销比较大，加锁会比较慢容易出现死锁情况。</p>
<p>InnoDB与MyISAM的最大不同有两点:一是支持事务（TRANSACTION);二是采用了行级锁。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210449.png" alt="image-20220214100724739"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210450.png" alt="image-20220214100734982"></p>
<h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210451.png" alt="image-20220214100755360"></p>
<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。 </p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁； </p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。 </p>
</li>
</ul>
<h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h5><p>MySQL 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁</code> 方案解决。</p>
<p>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210452.png" alt="image-20220214100913810"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210453.png" alt="image-20220214100922762"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210454.png" alt="image-20220214100947538"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210455.png" alt="image-20220214101004869"></p>
<h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a>③ 临键锁（Next-Key Locks）</h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 <code>间隙插入新记录</code> ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210456.png" alt="image-20220214101123814"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure>

<h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a>④ 插入意向锁（Insert Intention Locks）</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为:LOCK_INSERT_INTENTION，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间(gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取（4，7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待)。总结来说，插入意向锁的特性可以分成两部分:</p>
<p>(1）插入意向锁是一种特殊的间隙锁—一间隙锁可以锁定开区间内的部分记录。</p>
<p>(2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p>
<p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<code>行锁</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210457.png" alt="image-20220214101429289"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210458.png" alt="image-20220214101451957"></p>
<h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h4><p>页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong> </p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h3 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 数据并发的思维方式 。需要注意的是，乐观锁和悲观锁并不是锁，而是<code>锁的 设计思想 </code>。 </p>
<h4 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身 的锁机制来实现，从而保证数据操作的排它性。 </p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上 锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<code>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</code>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当 其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是 悲观锁思想的实现。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210459.png" alt="image-20220214102010016"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210500.png" alt="image-20220214102029742"></p>
<h4 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过 程序来实现。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。 </p>
<h5 id="乐观锁的版本号机制"><a href="#乐观锁的版本号机制" class="headerlink" title="乐观锁的版本号机制"></a>乐观锁的版本号机制</h5><p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更 新或删除操作时，会执行 UPDATE … SET version=version+1 WHERE version=version 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。 </p>
<h5 id="乐观锁的时间戳机制"><a href="#乐观锁的时间戳机制" class="headerlink" title="乐观锁的时间戳机制"></a>乐观锁的时间戳机制</h5><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。 你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210501.png" alt="image-20220214102106002"></p>
<h4 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景： </p>
<ol>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。 </li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。 </li>
</ol>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210502.png" alt="image-20220214102124473"></p>
<h3 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210503.png" alt="image-20220214102149966"></p>
<p>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。 </p>
<p>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210504.png" alt="image-20220214102216873"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210505.png" alt="image-20220214102240974"></p>
<h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210506.png" alt="image-20220214102319698"></p>
<h3 id="其它锁之：全局锁"><a href="#其它锁之：全局锁" class="headerlink" title="其它锁之：全局锁"></a>其它锁之：全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>

<h3 id="其它锁之：死锁"><a href="#其它锁之：死锁" class="headerlink" title="其它锁之：死锁"></a>其它锁之：死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死 锁示例：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210507.png" alt="image-20220214102454938"></p>
<p>第二种策略的成本分析 </p>
<p>方法1：如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有 一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后 通过业务重试一般就没问题了，这是 业务无损 的。而关掉死锁检测意味着可能会出现大量的超时，这是 业务有损 的。 </p>
<p>方法2：控制并发度。如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测 的成本很低，就不会出现这个问题。 这个并发控制要做在 数据库服务端 。如果你有中间件，可以考虑在 中间件实现 ；甚至有能力修改MySQL 源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队，这样在 InnoDB内部就不会有大量的死锁检测工作了。</p>
<h1 id="十六、多版本并发控制"><a href="#十六、多版本并发控制" class="headerlink" title="十六、多版本并发控制"></a>十六、多版本并发控制</h1><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210508.png" alt="image-20220214102633787"></p>
<h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><p> MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版 本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保 证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。 </p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到 即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。 </p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞 读；比如这样： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。 </p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 </p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student LOCK <span class="hljs-keyword">IN</span> SHARE MODE; # 共享锁<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; # 排他锁<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">values</span> ... # 排他锁<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> ... # 排他锁<br><span class="hljs-keyword">UPDATE</span> student <span class="hljs-keyword">SET</span> ... # 排他锁<br></code></pre></td></tr></table></figure>

<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210509.png" alt="image-20220214103021784"></p>
<p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p>
<p>MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210510.png" alt="image-20220214103029537"></p>
<h3 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必 要的隐藏列。</p>
<p>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。 </p>
<p>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210511.png" alt="image-20220214103110105"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210512.png" alt="image-20220214103124895"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210513.png" alt="image-20220214103144338"></p>
<h2 id="MVCC实现原理之ReadView"><a href="#MVCC实现原理之ReadView" class="headerlink" title="MVCC实现原理之ReadView"></a>MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</p>
<h3 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h3><p>在MCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID(“”活跃”指的就是，启动了但还没提交)。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了。 </p>
<p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。 </p>
<p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问 题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210514.png" alt="image-20220214103336220"></p>
<h3 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。 </p>
<p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前 事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p>
<p> 如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判 断一下trx_id属性值是不是在 trx_ids 列表中。 </p>
<ul>
<li><p>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </p>
</li>
<li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p>
</li>
</ul>
<h3 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它： </p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。 在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。 如表所示：</li>
</ol>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210515.png" alt="image-20220214103536185"></p>
<h1 id="十七、其他数据库日志"><a href="#十七、其他数据库日志" class="headerlink" title="十七、其他数据库日志"></a>十七、其他数据库日志</h1><p>我们在讲解数据库事务时，讲过两种日志:重做日志、回滚日志。</p>
<p>对于线上数据库应用系统，突然遭遇数据库宕机怎么办?在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的sQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p>
<p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。 </p>
<p>MySQL8.0 官网日志地址：“ <a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a> ”</p>
<h2 id="MySQL支持的日志"><a href="#MySQL支持的日志" class="headerlink" title="MySQL支持的日志"></a>MySQL支持的日志</h2><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志 和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。 </p>
<p><strong>这6类日志分别为：</strong> </p>
<p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。 </p>
<p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。 </p>
<p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。 </p>
<p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。 </p>
<p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。 </p>
<p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。 </p>
<p>除二进制日志外，其他日志都是 文本文件 。默认情况下，所有日志创建于 MySQL数据目录 中。 </p>
<h3 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h3><p>日志功能会 降低MySQL数据库的性能 。 </p>
<p>日志会 占用大量的磁盘空间 。</p>
<h2 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志(slow query log)"></a>慢查询日志(slow query log)</h2><p>前面章节《第09章_性能分析工具的使用》已经详细讲述。 </p>
<h2 id="通用查询日志-general-query-log"><a href="#通用查询日志-general-query-log" class="headerlink" title="通用查询日志(general query log)"></a>通用查询日志(general query log)</h2><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志， 还原操作时的具体场景，可以帮助我们准确定位问题。</p>
<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p>
<p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p>
<p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点so，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p>
<p>由于网络的原因导致了重复支付。至于解决问题的方案就很多了，这里省略。</p>
<p>可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。</p>
<h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> general_log <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span> #通用查询日志处于关闭状态<br><span class="hljs-operator">|</span> general_log_file <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu01.log <span class="hljs-operator">|</span> #通用查询日志文件的名称是atguigu01.log<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>

<p>说明1：系统变量general_log 的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的默认值是关闭的。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。</p>
<p>说明2：通用查询日志文件的名称是atguiguo1.log。存储路径是/var/ib/mysql/，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了。</p>
<h3 id="启动日志"><a href="#启动日志" class="headerlink" title="启动日志"></a>启动日志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210516.png" alt="image-20220214104404634"></p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>通用查询日志是以 文本文件 的形式存储在文件系统中的，可以使用 文本编辑器 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。 </p>
<p>在Windows操作系统中，使用文本文件查看器； </p>
<p>在Linux系统中，可以使用vi工具或者gedit工具查看； </p>
<p>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。 </p>
<p>从 SHOW VARIABLES LIKE ‘general_log%’; 结果中可以看到通用查询日志的位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>sbin<span class="hljs-operator">/</span>mysqld, Version: <span class="hljs-number">8.0</span><span class="hljs-number">.26</span> (MySQL Community Server <span class="hljs-operator">-</span> GPL). started <span class="hljs-keyword">with</span>:<br>Tcp port: <span class="hljs-number">3306</span> Unix socket: <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>mysql.sock<br><span class="hljs-type">Time</span> Id Command Argument<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">44</span>:<span class="hljs-number">58.052890</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">15.666672</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;general_log%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">28.970765</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.706804</span>Z <span class="hljs-number">11</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@localhost</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> Socket<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.707435</span>Z <span class="hljs-number">11</span> Query <span class="hljs-keyword">select</span> @<span class="hljs-variable">@version</span>_comment limit <span class="hljs-number">1</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.384886</span>Z <span class="hljs-number">12</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385253</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385640</span>Z <span class="hljs-number">12</span> Query USE `atguigu12`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.386179</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.901778</span>Z <span class="hljs-number">13</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.902128</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905179</span>Z <span class="hljs-number">13</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905825</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.163833</span>Z <span class="hljs-number">14</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164451</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164840</span>Z <span class="hljs-number">14</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">40.006687</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account<br></code></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什 么 SQL 操作，针对的是哪个数据表等信息。</p>
<h3 id="停止日志"><a href="#停止日志" class="headerlink" title="停止日志"></a>停止日志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210517.png" alt="image-20220214104540183"></p>
<h4 id="删除-刷新日志"><a href="#删除-刷新日志" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很 长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210518.png" alt="image-20220214104610167"></p>
<h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h2><h3 id="启动日志-1"><a href="#启动日志-1" class="headerlink" title="启动日志"></a>启动日志</h3><p>在MySQL数据库中，错误日志功能是 默认开启 的。而且，错误日志 无法被禁止 。 默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或 hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>error<span class="hljs-operator">=</span>[path<span class="hljs-operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名<br></code></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。 </p>
<h3 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。 查询错误日志的存储路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_err%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> log_error <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysqld.log <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_services <span class="hljs-operator">|</span> log_filter_internal; log_sink_internal <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_suppression_list <span class="hljs-operator">|</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_verbosity <span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210519.png" alt="image-20220214104745940"></p>
<h3 id="删除-刷新日志-1"><a href="#删除-刷新日志-1" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 直接删除 。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210520.png" alt="image-20220214104805353"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210521.png" alt="image-20220214104814508"></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">install -omysql -gmysql -m0644 <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> <span class="hljs-regexp">/var/</span>log/mysqld.log<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8-0新特性"><a href="#MySQL8-0新特性" class="headerlink" title="MySQL8.0新特性"></a>MySQL8.0新特性</h3><p>MySQL8.0里对错误日志的改进。MySQL8.o的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。</p>
<p><strong>下面这些是来自社区的意见:</strong></p>
<p>默认情况下内容过于冗长·遗漏了有用的信息</p>
<p>难以过滤某些信息</p>
<p>没有标识错误信息的子系统源</p>
<p>没有错误代码，解析消息需要识别错误。引导消息可能会丢失</p>
<p>固定格式</p>
<p><strong>针对这些意见，MySQL做了如下改变:</strong></p>
<p>采用组件架构，通过不同的组件执行日志的写入和过滤功能。写入错误日志的全部信息都具有唯一的错误代码从10000开始</p>
<p>增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息。增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等</p>
<p>两种过滤方式，Internal和Dragnet</p>
<p>三种写入形式，经典、JSON和syseventlog</p>
<p>小结:</p>
<p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p>
<h2 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较 重要 的日志了，在日常开发及运维过程中，经常会遇到。 binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。 </p>
<p>binlog主要应用场景： </p>
<p>一是用于 数据恢复 </p>
<p>二是用于 数据复制</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210522.png" alt="image-20220214104854289"></p>
<h3 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210523.png" alt="image-20220214105109857"></p>
<h3 id="日志参数设置"><a href="#日志参数设置" class="headerlink" title="日志参数设置"></a>日志参数设置</h3><p><strong>方式1：永久性方式</strong> </p>
<p>修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>#启用二进制日志<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>atguigu<span class="hljs-operator">-</span>bin<br>binlog_expire_logs_seconds<span class="hljs-operator">=</span><span class="hljs-number">600</span><br>max_binlog_size<span class="hljs-operator">=</span><span class="hljs-number">100</span>M<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210524.png" alt="image-20220214105507715"></p>
<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong> </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;<br><br></code></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">chown <span class="hljs-operator">-</span>R <span class="hljs-operator">-</span>v mysql:mysql binlog<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210525.png" alt="image-20220214105548184"></p>
<p><strong>方式2：临时性方式</strong> </p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 会话级别 的设置，没有了global级别的设置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">global</span> 级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>ERROR <span class="hljs-number">1228</span> (HY000): Variable <span class="hljs-string">&#x27;sql_log_bin&#x27;</span> <span class="hljs-keyword">is</span> a SESSION variable <span class="hljs-keyword">and</span> can`t be used<br><span class="hljs-keyword">with</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span><br># session级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> 秒)<br></code></pre></td></tr></table></figure>

<h3 id="查看日志-2"><a href="#查看日志-2" class="headerlink" title="查看日志"></a>查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。 </p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就 会创建一个新的日志文件。 </p>
<p>查看当前的二进制日志文件列表及大小。指令如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-type">BINARY</span> LOGS;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> Log_name <span class="hljs-operator">|</span> File_size <span class="hljs-operator">|</span> Encrypted <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> atguigu<span class="hljs-operator">-</span>bin<span class="hljs-number">.000001</span> <span class="hljs-operator">|</span> <span class="hljs-number">156</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">No</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-number">1</span> 行于数据集 (<span class="hljs-number">0.02</span> 秒)<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210526.png" alt="image-20220214105635944"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210527.png" alt="image-20220214105656266"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210528.png" alt="image-20220214105719614"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210529.png" alt="image-20220214105729486"></p>
<h3 id="使用日志恢复数据"><a href="#使用日志恢复数据" class="headerlink" title="使用日志恢复数据"></a>使用日志恢复数据</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210530.png" alt="image-20220214105832031"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210531.png" alt="image-20220214105954967"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210532.png" alt="image-20220214110004021"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210533.png" alt="image-20220214110046092"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210534.png" alt="image-20220214110056135"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210535.png" alt="image-20220214110106530"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210536.png" alt="image-20220214110115454"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210537.png" alt="image-20220214110124763"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210538.png" alt="image-20220214110136968"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210539.png" alt="image-20220214110147324"></p>
<h3 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 PURGE MASTER LOGS 只删除指定部分的二进制日志文件， RESET MASTER 删除所有的二进制日志文 件。具体如下： </p>
<p>PURGE MASTER LOGS：删除指定日志文件 PURGE MASTER LOGS语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS <span class="hljs-keyword">TO</span> ‘指定日志文件名’<br>PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’<br></code></pre></td></tr></table></figure>

<h3 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h3><p>二进制日志可以通过数据库的 全量备份 和二进制日志中保存的 增量信息 ，完成数据库的 无损失恢复 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数 据恢复，是很有挑战性的，因为起止位置不容易管理。 </p>
<p>在这种情况下，一个有效的解决办法是 配置主从数据库服务器 ，甚至是 一主多从 的架构，把二进制日志 文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常 等问题。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式03-行为型模式</title>
    <url>/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E03_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="行为型模式-上篇"><a href="#行为型模式-上篇" class="headerlink" title="行为型模式 | 上篇"></a>行为型模式 | 上篇</h1><h2 id="行为型模式总览"><a href="#行为型模式总览" class="headerlink" title="行为型模式总览"></a>行为型模式总览</h2><p>创建型设计模式：主要解决“对象的创建”问题</p>
<p>结构型设计模式：主要解决“类或对象的组合或组装”问题</p>
<p>行为型设计模式：主要解决“类或对象之间的交互”问题</p>
<hr>
<p>创建型模式：将创建和使用代码解耦</p>
<p>结构型模式：将不同的功能代码解耦</p>
<p>行为型模式：将不同的行为代码解耦</p>
<hr>
<p>观察者模式：发布订阅模式，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>
<p>模板方法模式：让子类在不改变业务逻辑整体结构的情况下，重新定义其中的某些步骤</p>
<p>策略模式：解耦策略的定义、创建和使用，控制代码的复杂度</p>
<p>职责链模式：多个处理器依次处理同一个请求</p>
<p>迭代器模式：遍历集合对象</p>
<p>状态模式：将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</p>
<hr>
<p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</p>
<p>备忘录模式：存储副本以便后期恢复</p>
<p>命令模式：将函数封装成对象，把函数像对象一样使用</p>
<p>解释器模式：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</p>
<p>中介模式：一组对象之间的交互关系从多对多（网状关系）转换为一对多（星状关系）</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131102.png" alt="image-20220112162840676"></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式</p>
<p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依 赖的对象都会自动收到通知。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现 方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<hr>
<p>实战案例一：P2P 投资理财系统</p>
<p>用户注册成功之后，我们会给用户发放投资体验金</p>
<p>如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠 券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地 修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操 作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维 护性。</p>
<p>用户注册成功之后，推送用户注册信息给大数据 征信系统</p>
<p>当我们把发送体验金替换为发送优惠券的时候</p>
<hr>
<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能 短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。</p>
<p>如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信 系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者 模式呢？</p>
<p>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现 思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优 雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。</p>
<p>模板模式主要是用来解决<strong>复用和扩展</strong>两个问题</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>模板模式作用一：复用</p>
<p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变 的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。 所有的子类都可以复用父类中模板方法定义的流程代码。</p>
<p>模板模式作用二：扩展</p>
<p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转。基于这个 作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化 框架的功能。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>模板模式作用一：复用</p>
<p>Java InputStream、Java AbstractList</p>
<p>模板模式作用二：扩展</p>
<p>Java Servlet、JUnit TestCase</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的 方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现 比较灵活，以上两点都不是必须的。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：什么是回调？</strong></p>
<p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>
<p>通 过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果 返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统， 等三方支付系统执行完成之后，将结果通过回调接口返回给用户。 </p>
<p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调 函数；异步回调指的是在函数返回之后执行回调函数。</p>
<p><strong>应用举例一：JdbcTemplate</strong> </p>
<p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于 回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以， 在命名上，这些类使用 Template（模板）这个单词作为后缀。</p>
<p><strong>应用举例二：setClickListener(）</strong> </p>
<p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<p><strong>应用举例三：addShutdownHook()</strong> </p>
<p>Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？ 网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉 得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用 场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能 认识，遇到场景会用就可以了。</p>
<p><strong>Q：模板模式 vs 回调</strong></p>
<p>从应用场景上来看同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。 </p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。 </p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点。</p>
<p>1、像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。 </p>
<p>2、回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。 </p>
<p>3、如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略 模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部 分。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<p><strong>个人理解：</strong> </p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过， 它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p>
<p>实战案例一：利用策略模式避免分支判断</p>
<p>实战案例二：实现一个支持给不同大小文件排序的小程序</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>1、策略的定义</p>
<p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略 类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策 略。</p>
<p>2、策略的创建 </p>
<p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建 哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根 据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的 都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实 现策略工厂类。</p>
<p>3、策略的使用</p>
<p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见 的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它 为止。</p>
<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再 传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职 责，所以叫作职责链模式。</p>
<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往 下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一 遍，不存在中途终止的情况。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说， 用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、 反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。 </p>
<p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打 马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链 模式的定义，第二种处理方式是职责链模式的变体。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p><strong>Servlet Filter</strong></p>
<p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规 范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支 持过滤器功能。</p>
<p><strong>Spring Interceptor</strong> </p>
<p>刚刚讲了 Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上 可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。 </p>
<p>它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处 理器，后面一种实现方式更加简单。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>状态模式是状 态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动 作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须 的，也可能只转移状态，不执行任何动作。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>状态机实现方式一：分支逻辑法</p>
<p>参照状态转移 图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为 分支逻辑法。</p>
<p>状态机实现方式二：查表法</p>
<p>除了用状态转移图来表示之外，状态机还可以用二维表来表示，在这个 二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到 的新状态及其执行的动作。</p>
<p>状态机实现方式三：状态模式</p>
<p>如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能 发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的 实现方式有一定局限性。</p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断 逻辑。</p>
<hr>
<p>像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状 态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种 类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业 务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p>
<hr>
<p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移 图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简 单、最直接，是首选。 </p>
<p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合 适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。 </p>
<p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动 作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）</p>
<p>用来遍历集合对象，这里说的“集合对象”也可以叫“容器”“聚合 对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将 集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>迭代器模式。它用来遍历集合对象。不过，很多 编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开 发，我们直接使用即可，很少会自己去实现一个迭代器。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的迭代器类</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非 实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实 现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代 器类中。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：使用迭代器的优势</strong></p>
<p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一 种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p>
<p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器 提供的迭代器即可； </p>
<p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职 责更加单一； </p>
<p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都 实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<p><strong>Q：遍历集合元素的同时，增加或者删除集合中的元素？</strong></p>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出 错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。 </p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候 不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很 难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解 决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<p><strong>Q：如何实现一个支持“快照”功能的迭代器？</strong></p>
<p>1、创建副本，迭代过程中在副本集上遍历</p>
<p>2、为每个元素添加 创建时间createTime，删除时间deleteTime，删除元素时，更新删除时间，在迭代的过程中，只迭代当前时间 currentTime &lt; 删除时间 deleteTime</p>
<h1 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式（上）：详解各种应用场景下观察者模式的不同实现-方式"><a href="#观察者模式（上）：详解各种应用场景下观察者模式的不同实现-方式" class="headerlink" title="观察者模式（上）：详解各种应用场景下观察者模式的不同实现 方式"></a>观察者模式（上）：详解各种应用场景下观察者模式的不同实现 方式</h2><p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：</p>
<p>有同步阻塞的实现 方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h3 id="原理及应用场景剖析"><a href="#原理及应用场景剖析" class="headerlink" title="原理及应用场景剖析"></a>原理及应用场景剖析</h3><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。 一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者 （Observer）。</p>
<p>不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不 同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、 EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合 刚刚给出的定义，都可以看作观察者模式。</p>
<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实 现方式</p>
<p>现在，我们先来看其中最经典的一种实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.remove(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>        System.out.println(<span class="hljs-string">&quot;ConcreteObserverOne is notified.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>        System.out.println(<span class="hljs-string">&quot;ConcreteObserverTwo is notified.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverOne</span>());<br>        subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverTwo</span>());<br>        subject.notifyObservers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。</p>
<p>观察者模式的实现方法各式各样，函数、类的 命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach， remove 函数还可以叫作 detach 等等。不过，万变不离其宗</p>
<hr>
<p>P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验 金。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br><span class="hljs-comment">//省略输入参数的校验代码</span><br><span class="hljs-comment">//省略userService.register()异常的try-catch代码</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>        promotionService.issueNewUserExperienceCash(userId);<br>        <span class="hljs-keyword">return</span> userId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展 和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的 类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠 券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地 修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操 作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维 护性。</p>
<p>这个时候，观察者模式就能派上用场了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点：setRegObservers</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 一次性设置好，之后也不可能动态的修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRegObservers</span><span class="hljs-params">(List&lt;RegObserver&gt; observers)</span> &#123;<br>        regObservers.addAll(observers);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>		<span class="hljs-comment">//省略输入参数的校验代码</span><br>		<span class="hljs-comment">//省略userService.register()异常的try-catch代码</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>        <span class="hljs-keyword">for</span> (RegObserver observer : regObservers) &#123;<br>            observer.handleRegSuccess(userId);<br>        &#125;<br>        <span class="hljs-keyword">return</span> userId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点：interface RegObserver</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegPromotionObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>        promotionService.issueNewUserExperienceCash(userId);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegNotificationObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">private</span> NotificationService notificationService;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>        notificationService.sendInboxMessage(userId, <span class="hljs-string">&quot;Welcome...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据 征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要 修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。 </p>
<p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改 RegPromotionObserver 类中 handleRegSuccess() 函数的代码，这还是违反开闭原则 呀？你说得没错，不过，相对于 register() 函数来说，handleRegSuccess() 函数的逻辑要 简单很多，修改更不容易出错，引入 bug 的风险更低。</p>
<p>实际上，<strong>设计模式要干的事情就 是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型 模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借 助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足 开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<h3 id="基于不同应用场景的不同实现方式"><a href="#基于不同应用场景的不同实现方式" class="headerlink" title="基于不同应用场景的不同实现方式"></a>基于不同应用场景的不同实现方式</h3><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。 </p>
<p>不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有 同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实 现方式。 </p>
<p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。<strong>观察者和 被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成 之后，才执行后续的代码。</strong>对照上面讲到的用户注册的例子，register() 函数依次调用执行 每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户 端。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能 短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。 具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所 有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。 </p>
<p>userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。</p>
<p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实 现方式，那就是基于 EventBus 来实现。今天，我们就不展开讲解了。</p>
<p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实 现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信 系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者 模式呢？ </p>
<p>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现 思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优 雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</p>
<p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成 本。不过，<u>它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被 观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解 耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知 被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相 应的逻辑。</u></p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同 功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单 一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提 高代码的可扩展性。 </p>
<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实 现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h2 id="观察者模式（下）：如何实现一个异步非阻塞的EventBus框-架？"><a href="#观察者模式（下）：如何实现一个异步非阻塞的EventBus框-架？" class="headerlink" title="观察者模式（下）：如何实现一个异步非阻塞的EventBus框 架？"></a>观察者模式（下）：如何实现一个异步非阻塞的EventBus框 架？</h2><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；</p>
<p>异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；</p>
<p>进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<h3 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h3><h3 id="EventBus-框架功能需求介绍"><a href="#EventBus-框架功能需求介绍" class="headerlink" title="EventBus 框架功能需求介绍"></a>EventBus 框架功能需求介绍</h3><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框 架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p>
<p>其中， Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞 模式，同时也支持同步阻塞模式</p>
<h3 id="手把手实现一个-EventBus-框"><a href="#手把手实现一个-EventBus-框" class="headerlink" title="手把手实现一个 EventBus 框"></a>手把手实现一个 EventBus 框</h3><h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让 程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样 的效果，而这个框架就是我们这节课讲的 EventBus。EventBus 翻译为“事件总线”，它 提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中 实现观察者模式，不需要从零开始开发。 </p>
<p>很多人觉得做业务开发没有技术挑战，实际上，做业务开发也会涉及很多非业务功能的开 发，比如今天讲到的 EventBus。在平时的业务开发中，我们要善于抽象这些非业务的、可 复用的功能，并积极地把它们实现成通用的框架。</p>
<h1 id="模板模式-1"><a href="#模板模式-1" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中-的应用"><a href="#模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中-的应用" class="headerlink" title="模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中 的应用"></a>模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中 的应用</h2><p>模板模式主要是用来解决<strong>复用和扩展</strong>两个问题。</p>
<p>我们今天会结合 Java Servlet、 JUnit TestCase、Java InputStream、Java AbstractList 四个例子来具体讲解这两个作 用。</p>
<h3 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h3><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。 </p>
<p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中 的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也 是模板方法模式名字的由来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>        method1();<br><span class="hljs-comment">//...</span><br>        method2();<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> ConcreteClass1();<br>demo.templateMethod();<br></code></pre></td></tr></table></figure>

<h3 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h3><p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。 </p>
<p>模板模式<u>把一个算法中不变的流程抽象到父类的模板方法</u> templateMethod() 中，<u>将可变 的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现</u>。 所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体 会一下。</p>
<h4 id="1-Java-InputStream"><a href="#1-Java-InputStream" class="headerlink" title="1.Java InputStream"></a>1.Java InputStream</h4><p>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、 Reader、Writer。我们拿 InputStream 来举例说明一下。 </p>
<p>我把 InputStream 部分相关代码贴在了下面。在代码中，read() 函数是一个模板方法，定 义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br>    <span class="hljs-comment">//重点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <br>    <span class="hljs-comment">//...省略其他代码...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> read();<br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-type">byte</span>)c;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-type">byte</span>)c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteArrayInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="hljs-number">0xff</span>) : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-Java-AbstractList"><a href="#2-Java-AbstractList" class="headerlink" title="2.Java AbstractList"></a>2.Java AbstractList</h4><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方 法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index,Collection&lt;?extends E&gt; c)</span>&#123;<br>        rangeCheckForAdd(index);<br>        <span class="hljs-type">boolean</span> modified=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(E e:c)&#123;<br>            <span class="hljs-comment">//重点：在这里调用add</span><br>            add(index++,e);<br>            modified=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> modified;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h3><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转，你可以结合第 19 节来一块理解。</p>
<p>基于这个 作用，模板模式常用在框架的开发中，让框架用户可以<u>在不修改框架源码的情况下，定制化 框架的功能</u>。我们通过 Junit TestCase、Java Servlet 两个例子来解释一下。</p>
<h4 id="1-Java-Servlet"><a href="#1-Java-Servlet" class="headerlink" title="1.Java Servlet"></a>1.Java Servlet</h4><p>对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注 业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不 难。我们只需要<strong>定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求。</strong></p>
<p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容 器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p>
<p>我们现在来看，HttpServlet 的 service() 函数长什么样子。</p>
<p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。</p>
<p>实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架 用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>
<h4 id="2-JUnit-TestCase"><a href="#2-JUnit-TestCase" class="headerlink" title="2.JUnit TestCase"></a>2.JUnit TestCase</h4><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、 tearDown() 等），让框架用户可以在这些扩展点上扩展功能。 </p>
<p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的 整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后 执行 tearDown() 做扫尾工作。</p>
<p>TestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了 默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模 板模式的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Assert</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        setUp();<br>        <span class="hljs-keyword">try</span> &#123;<br>            runTest();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable running) &#123;<br>            exception = running;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tearDown();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable tearingDown) &#123;<br>                <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) exception = tearingDown;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> exception;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets up the fixture, for example, open a network connection.</span><br><span class="hljs-comment">     * This method is called before a test is executed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tears down the fixture, for example, close a network connection.</span><br><span class="hljs-comment">     * This method is called after a test is executed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法 模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算 法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这 里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式 名字的由来。 </p>
<p><strong>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的 方法定义为 abstract，可以强迫子类去实现。</strong>不过，在实际项目开发中，模板模式的实现 比较灵活，以上两点都不是必须的。</p>
<p>模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的 模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修 改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h2 id="模板模式（下）：模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式（下）：模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式（下）：模板模式与Callback回调函数有何区别和联系？"></a>模板模式（下）：模板模式与Callback回调函数有何区别和联系？</h2><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式 相同的作用，那就是回调（Callback）。</p>
<h3 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h3><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。<strong>A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</strong> </p>
<p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使 用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。这里我用 Java 语言举例说明一下。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICallback</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodToCallback</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(ICallback callback)</span> &#123;<br><span class="hljs-comment">//...</span><br>        callback.methodToCallback();<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BClass</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BClass</span>();<br>        b.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ICallback</span>() &#123; <span class="hljs-comment">//回调对象</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodToCallback</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Call back me.&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是 Java 语言中回调的典型代码实现。从代码实现中，我们可以看出，回调跟模板模 式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的 逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代 码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能 力。</p>
<p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通 过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果 返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统， 等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>
<p><strong>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调 函数；异步回调指的是在函数返回之后执行回调函数。</strong>上面的代码实际上是同步回调的实现 方式，在 process() 函数返回之前，执行完回调函数 methodToCallback()。而上面支付的 例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。<strong>从应用 场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</strong></p>
<h3 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h3><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于 回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以， 在命名上，这些类使用 Template（模板）这个单词作为后缀。 </p>
<p>这些 Template 类的设计思路都很相近，所以，我们只拿其中的 JdbcTemplate 来举例分 析一下。对于其他 Template 类，你可以阅读源码自行分析。 </p>
<p>在前面的章节中，我们也多次提到，Java 提供了 JDBC 类库来封装不同类型的数据库操 作。不过，直接使用 JDBC 来编写操作数据库的代码，还是有点复杂的。比如，下面这段 是使用 JDBC 来查询用户信息的代码。</p>
<p>queryUser() 函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连 接、创建 statement、关闭连接、关闭 statement、处理异常。针对不同的 SQL 执行请 求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。 </p>
<p>针对这个问题，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来简化数据库编 程。使用 JdbcTemplate 查询用户信息，我们只需要编写跟这个业务有关的代码，其中包 括，查询用户的 SQL 语句、查询结果与 User 对象之间的映射关系。其他流程性质的代码 都封装在了 JdbcTemplate 类中，不需要我们每次都重新编写。我用 JdbcTemplate 重写 了上面的例子，代码简单了很多，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">queryUser</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where id=&quot;</span>+id;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRowMapper</span>()).get(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRowMapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RowMapper</span>&lt;User&gt; &#123;<br>        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setId(rs.getLong(<span class="hljs-string">&quot;id&quot;</span>));<br>            user.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            user.setTelephone(rs.getString(<span class="hljs-string">&quot;telephone&quot;</span>));<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那 JdbcTemplate 底层具体是如何实现的呢？我们来看一下它的源码。</p>
<p>其中， JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。</p>
<h3 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h3><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> (Button)findViewById(R.id.button);<br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;I am clicked.&quot;</span>);<br>	&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象 给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者 （OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。 </p>
<p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证 了我们前面讲的，异步回调比较像观察者模式。</p>
<h3 id="应用举例三：addShutdownHook"><a href="#应用举例三：addShutdownHook" class="headerlink" title="应用举例三：addShutdownHook()"></a>应用举例三：addShutdownHook()</h3><p>Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？ </p>
<p>网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉 得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用 场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能 认识，遇到场景会用就可以了。</p>
<p>Hook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。接下来，我们拿 JVM 来举例说明一下。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以 注册一个 JVM 关闭的 Hook。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代 码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownHookDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownHook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I am called during shutting down.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShutdownHook</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看 addShutdownHook() 的代码实现，如下所示。这里我只给出了部分相关代 码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShutdownHook</span><span class="hljs-params">(Thread hook)</span> &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            sm.checkPermission(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;shutdownHooks&quot;</span>));<br>        &#125;<br>        ApplicationShutdownHooks.add(hook);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationShutdownHooks</span> &#123;<br>    <span class="hljs-comment">/* The set of registered hooks */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;<br>    <span class="hljs-keyword">static</span> &#123;<br>        hooks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;<br>        hooks = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Thread hook)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Shutdown in progress&quot;</span>);<br>        <span class="hljs-keyword">if</span> (hook.isAlive())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook already running&quot;</span>);<br>        <span class="hljs-keyword">if</span> (hooks.containsKey(hook))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook previously registered&quot;</span>);<br>        hooks.put(hook, hook);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runHooks</span><span class="hljs-params">()</span> &#123;<br>        Collection&lt;Thread&gt; threads;<br>        <span class="hljs-keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;<br>            threads = hooks.keySet();<br>            hooks = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            hook.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    hook.join();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中我们可以发现，有关 Hook 的逻辑都被封装到 ApplicationShutdownHooks 类 中了。当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程， 并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所 以，这也算是一种异步回调。 </p>
<h3 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h3><p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度， 来对比一下模板模式和回调。</p>
<p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。 </p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。 </p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点。</p>
<p>1、像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。 </p>
<p>2、回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。 </p>
<p>3、如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可</p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>今天，我们重点介绍了回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框 架、类库、组件等的设计中经常会用到。 </p>
<p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就 是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。 </p>
<p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式， 异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加 灵活。</p>
<h1 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="策略模式（上）：如何避免冗长的if-else-switch分支判断代-码？"><a href="#策略模式（上）：如何避免冗长的if-else-switch分支判断代-码？" class="headerlink" title="策略模式（上）：如何避免冗长的if-else/switch分支判断代 码？"></a>策略模式（上）：如何避免冗长的if-else/switch分支判断代 码？</h2><p>最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过， 它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p>
<h3 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h3><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。 </p>
<p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略 模式跟两者类似，也能起到解耦的作用，不过，它<strong>解耦的是策略的定义、创建、使用这三部 分</strong>。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<h3 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h3><p>策略类的定义比较简单，<strong>包含一个策略接口和一组实现这个接口的策略类。</strong>因为所有的策略 类都实现相同的接口，所以，<strong>客户端代码基于接口而非实现编程，可以灵活地替换不同的策 略。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//具体的算法...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//具体的算法...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建 哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根 据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        strategies.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>());<br>        strategies.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Strategy <span class="hljs-title function_">getStrategy</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> strategies.get(type);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对 象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对 象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象， 缓存到工厂类中，用的时候直接返回。 </p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的 都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实 现策略工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Strategy <span class="hljs-title function_">getStrategy</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.策略的使用</p>
<p>刚刚讲了策略的定义和创建，现在，我们再来看一下，策略的使用。 </p>
<p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见 的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。 </p>
<p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间， 根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们 通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略接口：EvictionStrategy</span><br><span class="hljs-comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span><br><span class="hljs-comment">// 策略工厂：EvictionStrategyFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> EvictionStrategy eviction;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserCache</span><span class="hljs-params">(EvictionStrategy eviction)</span> &#123;<br>        <span class="hljs-built_in">this</span>.eviction = eviction;<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EvictionStrategy</span> <span class="hljs-variable">evictionStrategy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./config.properties&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;eviction_type&quot;</span>);<br>        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);<br>        <span class="hljs-type">UserCache</span> <span class="hljs-variable">userCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserCache</span>(evictionStrategy);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非运行时动态确定，在代码中指定使用哪种策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-type">EvictionStrategy</span> <span class="hljs-variable">evictionStrategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruEvictionStrategy</span>();<br>        <span class="hljs-type">UserCache</span> <span class="hljs-variable">userCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserCache</span>(evictionStrategy);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个 Application  中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成 了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>
<h3 id="如何利用策略模式避免分支判断？"><a href="#如何利用策略模式避免分支判断？" class="headerlink" title="如何利用策略模式避免分支判断？"></a>如何利用策略模式避免分支判断？</h3><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可 以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型待动 态，决定使用哪种策略这样一种应用场景。 </p>
<p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。具体的 代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直 接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">discount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">OrderType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> order.getType();<br>        <span class="hljs-keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="hljs-comment">// 普通订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="hljs-comment">// 团购订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="hljs-comment">// 促销订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> discount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码 重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的 代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">calDiscount</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br><span class="hljs-comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg</span><br><span class="hljs-comment">// 策略的创建</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        strategies.put(OrderType.NORMAL, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalDiscountStrategy</span>());<br>        strategies.put(OrderType.GROUPON, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrouponDiscountStrategy</span>());<br>        strategies.put(OrderType.PROMOTION, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromotionDiscountStrategy</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiscountStrategy <span class="hljs-title function_">getDiscountStrategy</span><span class="hljs-params">(OrderType type)</span> &#123;<br>        <span class="hljs-keyword">return</span> strategies.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 策略的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-type">OrderType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> order.getType();<br>        <span class="hljs-type">DiscountStrategy</span> <span class="hljs-variable">discountStrategy</span> <span class="hljs-operator">=</span> DiscountStrategyFactory.getDiscountStra<br>        <span class="hljs-keyword">return</span> discountStrategy.calDiscount(order);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂 类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 ifelse 分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据 type 查表（代码中的 strategies 就是表）替代根据 type 分支判断。 </p>
<p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方 式了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiscountStrategy <span class="hljs-title function_">getDiscountStrategy</span><span class="hljs-params">(OrderType type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Type should not be null.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type.equals(OrderType.NORMAL)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalDiscountStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.GROUPON)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrouponDiscountStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromotionDiscountStrategy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类 中，实际上并没有真正将它移除。关于这个问题如何解决，我今天先暂时卖个关子。你可以 在留言区说说你的想法，我在下一节课中再讲解。</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以 使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。 </p>
<p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部 分组成的。</p>
<p>1、策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。 </p>
<p>2、策略的创建由工厂类来完成，封装策略创建的细节。</p>
<p>3、策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编 译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应 用场景。</p>
<p>除此之外，我们还可以通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂 类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
<h2 id="策略模式（下）：如何实现一个支持给不同大小文件排序的小程-序？"><a href="#策略模式（下）：如何实现一个支持给不同大小文件排序的小程-序？" class="headerlink" title="策略模式（下）：如何实现一个支持给不同大小文件排序的小程 序？"></a>策略模式（下）：如何实现一个支持给不同大小文件排序的小程 序？</h2><p>设计原则和思想其实比设计模式更加普 适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。</p>
<p>问题与解决思路</p>
<p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含 整型数，并且，相邻的数字通过逗号来区隔。如果由你来编写这样一个小程序，你会如何来 实现呢？你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。 </p>
<p>你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个 一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语 言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。 </p>
<p>但是，如果文件很大呢？比如有 10GB 大小，因为内存有限（比如只有 8GB 大小），我们 没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法（具 体怎么做，可以参看我的另一个专栏《数据结构与算法之美》中的“排序”相关章节）了。 </p>
<p>如果文件更大，比如有 100GB 大小，我们为了利用 CPU 多核的优势，可以在外部排序的 基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的 MapReduce。 </p>
<p>如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了。这个时候， 我们可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。</p>
<h3 id="代码实现与分析"><a href="#代码实现与分析" class="headerlink" title="代码实现与分析"></a>代码实现与分析</h3><p>解决思路讲完了，不难理解。接下来，我们看一下，如何将解决思路翻译成代码实现。 </p>
<p>我先用最简单直接的方式实现将它实现出来。具体代码我贴在下面了，你可以先看一下。因 为我们是在讲设计模式，不是讲算法，所以，在下面的代码实现中，我只给出了跟设计模式 相关的骨架代码，并没有给出每种排序算法的具体代码实现。感兴趣的话，你可以自行实现 一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            quickSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            externalSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            concurrentExternalSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            mapreduceSort(filePath);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 快速排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">externalSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 外部排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">concurrentExternalSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 多线程外部排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mapreduceSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 利用MapReduce多机排序</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingTool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sorter</span> <span class="hljs-variable">sorter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sorter</span>();<br>        sorter.sortFile(args[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在“编码规范”那一部分我们讲过，函数的行数不能过多，最好不要超过一屏的大小。所 以，为了避免 sortFile() 函数过长，我们把每种排序算法从 sortFile() 函数中抽离出来，拆 分成 4 个独立的排序函数。</p>
<p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、 扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项 目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫 了。只有每个小的功能模块都写好，整个项目的代码才能不差。</p>
<p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的 话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的 代码实现都堆在 Sorter 一个类中，这就会导致这个类的代码很多。而在“编码规范”那一 部分中，我们也讲到，一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的 排序算法都设计成 Sorter 的私有函数，也会影响代码的可复用性。 </p>
<h3 id="代码优化与重构"><a href="#代码优化与重构" class="headerlink" title="代码优化与重构"></a>代码优化与重构</h3><p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设 计模式来重构，也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独 立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一 个常用手段。按照这个解决思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentExternalSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapReduceSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        ISortAlg sortAlg;<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentExternalSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceSort</span>();<br>        &#125;<br>        sortAlg.sort(filePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可 维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的 if-else 那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一 步，也就是将策略的定义分离出来。 </p>
<p>实际上，上面的代码还可以继续优化。每种排序类都是无状态的，我们没必要在每次使用的 时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装。按 照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortAlgFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, ISortAlg&gt; algs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        algs.put(<span class="hljs-string">&quot;QuickSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>());<br>        algs.put(<span class="hljs-string">&quot;ExternalSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalSort</span>());<br>        algs.put(<span class="hljs-string">&quot;ConcurrentExternalSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentExternalSort</span>());<br>        algs.put(<span class="hljs-string">&quot;MapReduceSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceSort</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ISortAlg <span class="hljs-title function_">getSortAlg</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> algs.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        ISortAlg sortAlg;<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;QuickSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ExternalSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ConcurrentExternalSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;MapReduceSort&quot;</span>);<br>        &#125;<br>        sortAlg.sort(filePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略 模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写 完全没问题。但如果你特别想将 if-else 分支判断移除掉，那也是有办法的。我直接给出代 码，你一看就能明白。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;AlgRange&gt; algs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>*GB, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;QuickSort&quot;</span>)));<br>        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">6</span>*GB, <span class="hljs-number">10</span>*GB, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ExternalSort</span><br><span class="hljs-string">                algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;</span>ConcurrentE<br>                        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;Ma</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    public void sortFile(String filePath) &#123;</span><br><span class="hljs-string">// 省略校验逻辑</span><br><span class="hljs-string">        File file = new File(filePath);</span><br><span class="hljs-string">        long fileSize = file.length();</span><br><span class="hljs-string">        ISortAlg sortAlg = null;</span><br><span class="hljs-string">        for (AlgRange algRange : algs) &#123;</span><br><span class="hljs-string">            if (algRange.inRange(fileSize)) &#123;</span><br><span class="hljs-string">                sortAlg = algRange.getAlg();</span><br><span class="hljs-string">                break;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        sortAlg.sort(filePath);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    private static class AlgRange &#123;</span><br><span class="hljs-string">        private long start;</span><br><span class="hljs-string">        private long end;</span><br><span class="hljs-string">        private ISortAlg alg;</span><br><span class="hljs-string">        public AlgRange(long start, long end, ISortAlg alg) &#123;</span><br><span class="hljs-string">            this.start = start;</span><br><span class="hljs-string">            this.end = end;</span><br><span class="hljs-string">            this.alg = alg;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        public ISortAlg getAlg() &#123;</span><br><span class="hljs-string">            return alg;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        public boolean inRange(long size) &#123;</span><br><span class="hljs-string">            return size &gt;= start &amp;&amp; size &lt; end;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和 Sorter 类中的静 态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静 态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。 </p>
<p>你可能会说，即便这样，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符 合开闭原则。有什么办法让我们完全满足开闭原则呢？ </p>
<p>对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我 们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配 置文件或者搜索被 annotation 标注的策略类，然后通过反射了动态地加载这些策略类、创 建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件 或者用 annotation 标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来 解决。</p>
<p>对于 Sorter 来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法 之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可， 不需要改动代码。 </p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不 多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在 即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。 </p>
<p>一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识 是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度， 让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能 让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风 险。</p>
<p> 实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们 能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式。</p>
<h1 id="职责链模式-1"><a href="#职责链模式-1" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框-架？"><a href="#职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框-架？" class="headerlink" title="职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框 架？"></a>职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框 架？</h2><p>前几节课中，我们学习了模板模式、策略模式，今天，我们来学习职责链模式。<strong>这三种模式 具有相同的作用：复用和扩展</strong>，在实际的项目开发中比较常用，特别是框架开发中，我们可 以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩 展点定制化框架的功能。</p>
<h3 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h3><p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它 为止。</p>
<p>这么说比较抽象，我用更加容易理解的话来进一步解读一下。 </p>
<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再 传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职 责，所以叫作职责链模式。</p>
<p>职责链模式有多种实现方式，我们这里介绍两种比较常用的。</p>
<p>第一种实现方式如下所示。其中，Handler 是所有处理器类的抽象父类，handle() 是抽象 方法。每个具体的处理器类（HandlerA、HandlerB）的 handle() 函数的代码结构类似， 如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也 就是调用 successor.handle()）。HandlerChain 是处理器链，从数据结构的角度来看，它 就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (!handled &amp;&amp; successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (!handled &amp;&amp; successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        handler.setSuccessor(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        tail.setSuccessor(handler);<br>        tail = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，上面的代码实现不够优雅。处理器类的 handle() 函数，不仅包含自己的业务逻 辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()。一个不熟悉这 种代码结构的程序员，在添加新的处理器类的时候，很有可能忘记在 handle() 函数中调用 successor.handle()，这就会导致代码出现 bug。 </p>
<p>针对这个问题，我们对代码进行重构，利用模板模式，将调用 successor.handle() 的逻辑 从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业 务逻辑就可以了。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> doHandle();<br>        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span> &amp;&amp; !handled) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// HandlerChain和Application代码不变</span><br></code></pre></td></tr></table></figure>

<p>我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain 类用 数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次 调用每个处理器的 handle() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;IHandler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(IHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handlers.add(handler);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (IHandler handler : handlers) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> handler.handle();<br>            <span class="hljs-keyword">if</span> (handled) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往 下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一 遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储 处理器，跟上面的两种实现方式类似，只需要稍微修改即可。 </p>
<p>我这里只给出其中一种实现方式，如下所示。另外一种实现方式你对照着上面的实现自行修 改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        doHandle();<br>        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        handler.setSuccessor(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        tail.setSuccessor(handler);<br>        tail = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h3><p>职责链模式的原理和实现讲完了，我们再通过一个实际的例子，来学习一下职责链模式的应 用场景。 </p>
<p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说， 用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、 反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。 </p>
<p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打 马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链 模式的定义，第二种处理方式是职责链模式的变体。 </p>
<p>我们这里只给出第一种实现方式的代码示例，如下所示，并且，我们只给出了代码实现的骨 架，具体的敏感词过滤算法并没有给出，你可以参看我的另一个专栏《数据结构与算法 之美中多模式字符串匹配的相关章节自行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Content content)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SexyWordFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">legal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> legal;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensitiveWordFilterChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(SensitiveWordFilter filter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filters.add(filter);<br>    &#125;<br>    <span class="hljs-comment">// return true if content doesn&#x27;t contain sensitive words.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-keyword">for</span> (SensitiveWordFilter filter : filters) &#123;<br>            <span class="hljs-keyword">if</span> (!filter.doFilter(content)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SensitiveWordFilterChain</span> <span class="hljs-variable">filterChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SensitiveWordFilterChain</span>();<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdsWordFilter</span>());<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SexyWordFilter</span>());<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PoliticalWordFilter</span>());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">legal</span> <span class="hljs-operator">=</span> filterChain.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>());<br>        <span class="hljs-keyword">if</span> (!legal) &#123;<br><span class="hljs-comment">// 不发表</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 发表</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看了上面的实现，你可能会说，我像下面这样也可以实现敏感词过滤功能，而且代码更加简 单，为什么非要使用职责链模式呢？这是不是过度设计呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-comment">// return true if content doesn&#x27;t contain sensitive words.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!filterSexyWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!filterAdsWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!filterPoliticalWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterSexyWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//....</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterAdsWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterPoliticalWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们前面多次讲过，应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高 代码的扩展性。这里应用职责链模式也不例外。实际上，我们在讲解策略模式的时候， 也讲过类似的问题，比如，为什么要用策略模式？当时的给出的理由，与现在应用职责链模 式的理由，几乎是一样的，你可以结合着当时的讲解一块来看下。 </p>
<p>首先，我们来看，职责链模式如何应对代码的复杂性。 </p>
<p>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责 链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。 </p>
<p>其次，我们再来看，职责链模式如何让代码满足开闭原则，提高代码的扩展性。 </p>
<p>当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的 代码实现方式，我们需要修改 SensitiveWordFilter 的代码，违反开闭原则。不过，这样的 修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一 个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不 需要修改。 </p>
<p>不过，你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改 客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。</p>
<p>实际上，细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中， ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外 的代码属于敏感词过滤框架代码。 </p>
<p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展 一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。 换句话说，我们在框架这个代码范围内实现了开闭原则。 </p>
<p>除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤 算法更加灵活，可以只选择使用某几个过滤算法。</p>
<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块儿总结回顾一下，你需要重点掌握的内容。 </p>
<p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后 再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链 条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。 </p>
<p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理 器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递， 而是会被所有的处理器都处理一遍。 </p>
<p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处 理器，后面一种实现方式更加简单。</p>
<h2 id="职责链模式（下）：框架中常用的过滤器、拦截器是如何实现-的？"><a href="#职责链模式（下）：框架中常用的过滤器、拦截器是如何实现-的？" class="headerlink" title="职责链模式（下）：框架中常用的过滤器、拦截器是如何实现 的？"></a>职责链模式（下）：框架中常用的过滤器、拦截器是如何实现 的？</h2><h3 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h3><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规 范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支 持过滤器功能。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131103.png" alt="image-20220119161128367"></p>
<p>在实际项目中，我们该如何使用 Servlet Filter 呢？我写了一个简单的示例代码，如下所 示。添加一个过滤器，我们只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并 且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置， 创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-comment">// 在创建Filter时自动调用，</span><br>        <span class="hljs-comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, Filte </span><br><span class="hljs-params">            System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>)</span>;<br>        chain.doFilter(request,response);<br>        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 在销毁Filter时自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// 在web.xml配置文件中如下配置：<br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xzg.cd.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>从刚刚的示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实 现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。那 Servlet Filter 是如何做到如此好的扩展性的呢？我想你应该已经猜到了，它利用的就是职责链模式。现 在，我们通过剖析它的源码，详细地看看它底层是如何实现的。 </p>
<p>在上一节课中，我们讲到，职责链模式的实现包含处理器接口（IHandler）或抽象类 （Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter， javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。接下来，我们重点来看 FilterChain 是如何实现的。 </p>
<p>不过，我们前面也讲过，Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中 的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提 供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如 下所示。 </p>
<p>为了让代码更易读懂，我对代码进行了简化，只保留了跟设计思路相关的代码片段。完整的 代码你可以自行去 Tomcat 中查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//当前执行到了哪个filter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">//filter的个数</span><br>    <span class="hljs-keyword">private</span> ApplicationFilterConfig[] filters;<br>    <span class="hljs-keyword">private</span> Servlet servlet;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>            <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>            <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>            filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>            servlet.service(request, response);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(ApplicationFilterConfig filterConfig)</span> &#123;<br>        <span class="hljs-keyword">for</span> (ApplicationFilterConfig filter:filters)<br>            <span class="hljs-keyword">if</span> (filter==filterConfig)<br>                <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (n == filters.length) &#123;<span class="hljs-comment">//扩容</span><br>            ApplicationFilterConfig[] newFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterConfig</span>[n + IN<br>            System.arraycopy(filters, <span class="hljs-number">0</span>, newFilters, <span class="hljs-number">0</span>, n);<br>            filters = newFilters;<br>        &#125;<br>        filters[n++] = filterConfig;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调 用。你可以用每个 Filter（比如 LogFilter）的 doFilter() 的代码实现，直接替换 ApplicationFilterChain 的第 12 行代码，一眼就能看出是递归调用了。我替换了一下，如 下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>&#123;<br>        <span class="hljs-keyword">if</span>(pos&lt;n)&#123;<br>        	ApplicationFilterConfig filterConfig=filters[pos++];<br>        	Filter filter=filterConfig.getFilter();<br>			<span class="hljs-comment">//filter.doFilter(request, response, this);</span><br>			<span class="hljs-comment">//把filter.doFilter的代码实现展开替换到这里</span><br>        	System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>        	chain.doFilter(request,response); <span class="hljs-comment">// chain就是this</span><br>        	System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>        	servlet.service(request,response);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请 求，也能拦截发送给客户端的响应，你可以结合着 LogFilter 那个例子，以及对比待会要讲 到的 Spring Interceptor，来自己理解一下。而我们上一节课给出的两种实现方式，都没 法做到在业务逻辑执行的前后，同时添加处理代码。 </p>
<h3 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h3><p>刚刚讲了 Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上 可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。 </p>
<p>它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131104.png" alt="image-20220119161823621"></p>
<p>在项目中，我们该如何使用 Spring Interceptor 呢？我写了一个简单的示例代码，如下所 示。LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区 别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse resp</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>)</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 继续后续的处理</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse respon</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;这里总是被执行.&quot;</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">//在Spring MVC配置文件中配置interceptors<br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*&quot;</span>/&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xzg.cd.LogInterceptor&quot;</span> /&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>同样，我们还是来剖析一下，Spring Interceptor 底层是如何实现的。 </p>
<p>当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中 的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清 晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中 实现。HandlerExecutionChain 的源码如下所示，同样，我对代码也进行了一些简化，只 保留了关键代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExecutionChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object handler;<br>    <span class="hljs-keyword">private</span> HandlerInterceptor[] interceptors;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">(HandlerInterceptor interceptor)</span> &#123;<br>        initInterceptorList().add(interceptor);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse respons</span><br><span class="hljs-params">HandlerInterceptor[]interceptors=getInterceptors()</span>;<br><span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interceptors.length; i++) &#123;<br>            <span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors[i];<br>            <span class="hljs-keyword">if</span> (!interceptor.preHandle(request, response, <span class="hljs-built_in">this</span>.handler)) &#123;<br>                triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response</span><br><span class="hljs-params">HandlerInterceptor[]interceptors=getInterceptors()</span>;<br>	<span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=interceptors.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        	HandlerInterceptor interceptor=interceptors[i];<br>        	interceptor.postHandle(request,response,<span class="hljs-built_in">this</span>.handler,mv);<br>        &#125;<br>     &#125;<br>&#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">triggerAfterCompletion</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse re</span><br><span class="hljs-params">        <span class="hljs-keyword">throws</span> Exception&#123;</span><br><span class="hljs-params">        	HandlerInterceptor[]interceptors=getInterceptors()</span>;<br>       		<span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">this</span>.interceptorIndex;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        			HandlerInterceptor interceptor=interceptors[i];<br>        			<span class="hljs-keyword">try</span>&#123;<br>        				interceptor.afterCompletion(request,response,<span class="hljs-built_in">this</span>.handler,ex);<br>        			&#125;<span class="hljs-keyword">catch</span>(Throwable ex2)&#123;<br>        				logger.error(<span class="hljs-string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>,ex2);<br>        			&#125;<br>        		&#125;<br>        	&#125;<br>        &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业 务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。具体的代码实现很简单，你自己应该能 脑补出来，这里就不罗列了。感兴趣的话，你可以自行去查看.</p>
<h3 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容 </p>
<p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不 需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、 对修改关闭的设计原则。</p>
<p>今天，我们通过 Servlet Filter、Spring Interceptor 两个实际的例子，给你展示了在框架 开发中职责链模式具体是怎么应用的。从源码中，我们还可以发现，尽管上一节课中我们有 给出职责链模式的经典代码实现，但在实际的开发中，我们还是要具体问题具体对待，代码 实现会根据不同的需求有所变化。实际上，这一点对于所有的设计模式都适用。</p>
<p><strong>Q：AOP、Servlet Filter、Spring Interceptor 都可以做访问控制？</strong></p>
<p>Spring AOP 是基于代理模式来实现的。在实际 的项目开发中，我们可以利用 AOP 来实现访问控制功能，比如鉴权、限流、日志等。今 天我们又讲到，Servlet Filter、Spring Interceptor 也可以用来实现访问控制。那在项 目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、 Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</p>
<h1 id="状态模式-1"><a href="#状态模式-1" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"><a href="#状态模式：游戏、工作流引擎中常用的状态机是如何实现的？" class="headerlink" title="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"></a>状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</h2><p>状态模式一般用来实现状态机，而状态机常用在<strong>游戏、工作流引擎</strong>等系统开发中。不过，状 态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。今天，我们 就详细讲讲这几种实现方式，并且对比一下它们的优劣和应用场景。</p>
<h3 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h3><p>有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转 移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必 须的，也可能只转移状态，不执行任何动作。</p>
<p>对于刚刚给出的状态机的定义，我结合一个具体的例子，来进一步解释一下。 </p>
<p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马 里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷 马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减 积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积 分。 </p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状 态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动 作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触 发动作的执行（增加 100 积分）。 </p>
<p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状 态转移如下图所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131105.png" alt="image-20220119162931049"></p>
<p>我们如何编程来实现上面的状态机呢？换句话说，如何将上面的状态转移图翻译成代码呢？ </p>
<p>我写了一个骨架代码，如下所示。其中，obtainMushRoom()、obtainCape()、 obtainFireFlower()、meetMonster() 这几个函数，能够根据当前的状态和事件，更新状 态和增减积分。不过，具体的代码实现我暂时并没有给出。你可以把它当做面试题，试着补 全一下，然后再来看我下面的讲解，这样你的收获会更大。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131106.png" alt="image-20220119163500089"></p>
<h3 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h3><p>对于如何实现状态机，我总结了三种方式。其中，最简单直接的实现方式是，参照状态转移 图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为 分支逻辑法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> State currentState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SUPER;<br>            <span class="hljs-built_in">this</span>.score += <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) )<br>            <span class="hljs-built_in">this</span>.currentState = State.CAPE;<br>        <span class="hljs-built_in">this</span>.score += <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) )<br>            <span class="hljs-built_in">this</span>.currentState = State.FIRE;<br>        <span class="hljs-built_in">this</span>.score += <span class="hljs-number">300</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SUPER)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.CAPE)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">200</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.FIRE)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">300</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>	<span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来 说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 ifelse 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机 中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引 入 bug。</p>
<h3 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h3><p>实际上，上面这种实现方法有点类似 hard code，对于复杂的状态机来说不适用，而状态 机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表 法来补全骨架代码。 </p>
<p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个 二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到 的新状态及其执行的动作。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131107.png" alt="image-20220119163838923"></p>
<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改 状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上， 如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改 任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Event</span> &#123;<br>    GOT_MUSHROOM(<span class="hljs-number">0</span>),<br>    GOT_CAPE(<span class="hljs-number">1</span>),<br>    GOT_FIRE(<span class="hljs-number">2</span>),<br>    MET_MONSTER(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Event</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> State currentState;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> State[][] transitionTable = &#123;<br>            &#123;SUPER, CAPE, FIRE, SMALL&#125;,<br>            &#123;SUPER, CAPE, FIRE, SMALL&#125;,<br>            &#123;CAPE, CAPE, CAPE, SMALL&#125;,<br>            &#123;FIRE, FIRE, FIRE, SMALL&#125;<br>    &#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[][] actionTable = &#123;<br>            &#123;+<span class="hljs-number">100</span>, +<span class="hljs-number">200</span>, +<span class="hljs-number">300</span>, +<span class="hljs-number">0</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">200</span>, +<span class="hljs-number">300</span>, -<span class="hljs-number">100</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, -<span class="hljs-number">200</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, -<span class="hljs-number">300</span>&#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_MUSHROOM);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_CAPE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_FIRE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.MET_MONSTER);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeEvent</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stateValue</span> <span class="hljs-operator">=</span> currentState.getValue();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">eventValue</span> <span class="hljs-operator">=</span> event.getValue();<br>        <span class="hljs-built_in">this</span>.currentState = transitionTable[stateValue][eventValue];<br>        <span class="hljs-built_in">this</span>.score = actionTable[stateValue][eventValue];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h3><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型 的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能 发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的 实现方式有一定局限性。</p>
<p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断 逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们 可以使用状态模式来解决。 </p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断 逻辑。我们还是结合代码来理解这句话。 </p>
<p>利用状态模式，我们来补全 MarioStateMachine 类，补全后的代码如下所示。</p>
<p>其中，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、 CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所 有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代 码逻辑被分散到了这 4 个状态类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMario</span> &#123; <span class="hljs-comment">//所有状态类的接口</span><br>    State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//以下是定义的事件</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> MarioStateMachine stateMachine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmallMario</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SMALL;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CapeMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FireMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do nothing...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> MarioStateMachine stateMachine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SuperMario</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SUPER;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do nothing...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CapeMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FireMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() - <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略CapeMario、FireMario类...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> IMario currentState; <span class="hljs-comment">// 不再使用枚举来表示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainMushRoom();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainCape();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainFireFlower();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.meetMonster();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState.getName();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(IMario currentState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState = currentState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码实现不难看懂，我只强调其中的一点，即 MarioStateMachine 和各个状态类之 间是双向依赖关系。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来， 各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。 </p>
<p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含 任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递 MarioStateMachine 了，而状态类又要依赖 MarioStateMachine，那该如何解决这个问 题呢？ </p>
<p>实际上，在第 42 讲单例模式的讲解中，我们提到过几种解决方法，你可以回过头去再查 看一下。在这里，我们可以通过函数参数将 MarioStateMachine 传递进状态类。根据这个 设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMario</span> &#123;<br>    State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SmallMario</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SmallMario</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SmallMario <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SMALL;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(SuperMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(CapeMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(FireMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br><span class="hljs-comment">// do nothing...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略SuperMario、CapeMario、FireMario类...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> IMario currentState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = SmallMario.getInstance();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainMushRoom(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainCape(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainFireFlower(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.meetMonster(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState.getName();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(IMario currentState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState = currentState;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状 态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种 类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业 务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。 </p>
<h3 id="重点回顾-8"><a href="#重点回顾-8" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>今天我们讲解了状态模式。虽然网上有各种状态模式的定义，但是你只要记住状态模式是状 态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动 作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须 的，也可能只转移状态，不执行任何动作。 </p>
<p>针对状态机，今天我们总结了三种实现方式。 </p>
<p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移 图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简 单、最直接，是首选。 </p>
<p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合 适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。 </p>
<p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动 作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<h1 id="迭代器模式-1"><a href="#迭代器模式-1" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些-优势？"><a href="#迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些-优势？" class="headerlink" title="迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些 优势？"></a>迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些 优势？</h2><p>迭代器模式。它用来遍历集合对象。不过，很多 编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开 发，我们直接使用即可，很少会自己去实现一个迭代器。不过，知其然知其所以然，弄懂原 理能帮助我们更好的使用这些工具类，所以，我觉得还是有必要学习一下这个模式。</p>
<p>我们知道，大部分编程语言都提供了多种遍历集合的方式，比如 for 循环、foreach 循环、 迭代器等。所以，今天我们除了讲解迭代器的原理和实现之外，还会重点讲一下，相对于其 他遍历方式，利用迭代器来遍历集合的优势。</p>
<h3 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h3><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。 </p>
<p>在开篇中我们讲到，它用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合 对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将 集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。 </p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部 分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代 器又包含迭代器接口、迭代器实现类。对于迭代器模式，我画了一张简单的类图，你可以看 一看，先有个大致的印象。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131108.png" alt="image-20220119164813318"></p>
<p>接下来，我们通过一个例子来具体讲，如何实现一个迭代器。</p>
<p>开篇中我们有提到，大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直 接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原 理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我 们从零开始开发。现在，我们一块来看具体该如何去做。 </p>
<p>我们知道，线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种 数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分 别对应 ArrayList 和 LinkedList 两个类。除此之外，我们从两个类中抽象出公共的接口， 定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结 构之间灵活切换。 </p>
<p>现在，我们针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。按照之 前给出的迭代器模式的类图，我们定义一个迭代器接口 Iterator，以及针对两种容器的具体 的迭代器实现类 ArrayIterator 和 ListIterator。</p>
<p>我们先来看下 Iterator 接口的定义。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义方式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 接口定义方式二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Iterator 接口有两种定义方式。 </p>
<p>在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前 游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函 数 next() 中完成。</p>
<p>第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不 移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。 </p>
<p>现在，我们再来看下 ArrayIterator 的代码实现，具体如下所示。代码实现非常简单，不需 要太多解释。你可以结合着我给出的 demo，自己理解一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != arrayList.size(); <span class="hljs-comment">//注意这里，cursor在指向最后一个元素的时候，ha</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        cursor++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br>        Iterator&lt;String&gt; iterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(names);<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.currentItem());<br>            iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际 上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应 的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口 中。具体的代码实现和使用示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//...省略其他接口函数...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...省略其他代码</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.currentItem());<br>            iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 LinkedIterator，它的代码结构跟 ArrayIterator 完全相同，我这里就不给出具体的代 码实现了，你可以参照 ArrayIterator 自己去写一下。 </p>
<p>结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：<strong>迭代器中需要定 义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注 入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。</strong></p>
<p>这里我画了一张类图，如下所示。实际上就是对上面那张类图的细化，你可以结合着一块 看。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131109.png" alt="image-20220119165137583"></p>
<p>迭代器的原理和代码实现讲完了。接下来，我们来一块看一下，使用迭代器遍历集合的优 势。 </p>
<p>一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。对于这 三种方式，我拿 Java 语言来举例说明一下。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br><br><span class="hljs-comment">// 第一种遍历方式：for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.size(); i++) &#123;<br>    System.out.print(names.get(i) + <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 第二种遍历方式：foreach循环</span><br><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    System.out.print(name + <span class="hljs-string">&quot;,&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 第三种遍历方式：迭代器遍历</span><br>Iterator&lt;String&gt; iterator = names.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.print(iterator.next() + <span class="hljs-string">&quot;,&quot;</span>);<span class="hljs-comment">//Java中的迭代器接口是第二种定义方式，next</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面 代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器 遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。 </p>
<p>从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们 为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三 个。 </p>
<p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历 就足够了。但是，<u>对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比 如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。</u>如果由客户端代码来实 现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类 中，也会导致容器类代码的复杂性。 </p>
<p>前面也多次提到，<u>应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比 如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分 别来实现深度优先遍历和广度优先遍历。</u> </p>
<p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这 样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。 </p>
<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实 现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链 表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即 可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器 类，也更符合开闭原则。</p>
<h3 id="重点回顾-9"><a href="#重点回顾-9" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以 叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、 跳表。 </p>
<p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非 实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实 现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代 器类中。 </p>
<p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一 种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势： </p>
<p>1、迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器 提供的迭代器即可； </p>
<p>2、迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职 责更加单一； </p>
<p>3、迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都 实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<h2 id="迭代器模式（中）：遍历集合的同时，为什么不能增删集合元-素？"><a href="#迭代器模式（中）：遍历集合的同时，为什么不能增删集合元-素？" class="headerlink" title="迭代器模式（中）：遍历集合的同时，为什么不能增删集合元 素？"></a>迭代器模式（中）：遍历集合的同时，为什么不能增删集合元 素？</h2><h3 id="在遍历的同时增删集合元素会发生什么？"><a href="#在遍历的同时增删集合元素会发生什么？" class="headerlink" title="在遍历的同时增删集合元素会发生什么？"></a>在遍历的同时增删集合元素会发生什么？</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还 是错，要视情况而定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<span class="hljs-comment">//55</span><br>        iterator.next();<span class="hljs-comment">//56</span><br>        names.remove(<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-comment">//57</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数 组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 56 行代码的时候，游标指向元素 b，到这里都没有问题。</p>
<p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 57 行代码的时候，我们从数组 中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元 素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、 d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到 了。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131110.png" alt="image-20220119165919755"></p>
<p>不过，如果第 57 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素 （元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在 某个元素遍历不到的情况了。 </p>
<p>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删 除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的 是哪个位置的元素），就是这个意思。 </p>
<p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集 合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一 下，把删除元素改为添加元素。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<span class="hljs-comment">//9</span><br>        iterator.next();<span class="hljs-comment">//10</span><br>        names.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;x&quot;</span>);<span class="hljs-comment">//11</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已 经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、 c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重 复指向两次，也就是说，元素 a 存在被重复遍历的情况。 </p>
<p>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的 同时添加集合元素也是一种不可预期行为。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131111.png" alt="image-20220119170023489"></p>
<h3 id="如何应对遍历时改变集合导致的未决行为？"><a href="#如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="如何应对遍历时改变集合导致的未决行为？"></a>如何应对遍历时改变集合导致的未决行为？</h3><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际 上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏 很深、很难 debug 的 bug 就是这么产生的。那我们如何才能避免出现这种不可预期的运 行结果呢？ </p>
<p>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之 后让遍历报错。</p>
<p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时 间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍 历结束的时间点该如何来确定呢？</p>
<p>你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使 用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为 b 的元素就提前结束了遍历。</p>
<p>你可能还会说，那我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容 器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用 完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p>
<p>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后， 让遍历报错。接下来，我们具体来看一下如何实现。 </p>
<p>怎么确定在遍历时候，集合有没有增删元素呢？</p>
<p><u>我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1</u>。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，<u>我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</u> </p>
<p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元 素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我 们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不 正确使用迭代器而产生的 bug。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-keyword">private</span> ArrayList arrayList;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedModCount;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList arrayList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>        <span class="hljs-built_in">this</span>.expectedModCount = arrayList.modCount;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        cursor++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (arrayList.modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        iterator.next();<br>        names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>        iterator.next();<span class="hljs-comment">//抛出ConcurrentModificationException异常</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如何在遍历的同时安全地删除集合元素？ </p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的 是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里 本身就不合适。 </p>
<p>我个人觉得，J<u>ava 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删 除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操 作，多次调用 remove() 操作会报错</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        iterator.next();<br>        iterator.remove();<br>        iterator.remove(); <span class="hljs-comment">//报错，抛出IllegalStateException异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘 密。我们来看下 remove() 函数是如何实现的，代码如下所示。稍微提醒一下，在 Java 实 现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前 的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> cursor; <span class="hljs-comment">// index of next element to return</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>        Itr() &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            checkForComodification();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            checkForComodification();<br>            <span class="hljs-keyword">try</span> &#123;<br>                ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>                cursor = lastRet;<br>                lastRet = -<span class="hljs-number">1</span>;<br>                expectedModCount = modCount;<br>            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，迭代器类新增了一个 <u>lastRet 成员变量，用来记录游标指向的前一个 元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来 保证不会因为删除元素而导致某个元素遍历不到。</u>如果通过容器来删除元素，并且希望更新 迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭 代器是否还在使用等信息，代码实现就变得比较复杂了。</p>
<h3 id="重点回顾-10"><a href="#重点回顾-10" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出 错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。 </p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候 不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很 难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解 决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。 </p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<p><strong>Q：下面代码中的第 13 行的运行结果是什么？</strong></p>
<p>基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器， 一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可 用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator1 = names.iterator();<br>        Iterator&lt;String&gt; iterator2 = names.iterator();<br>        iterator1.next();<br>        iterator1.remove();<br>        iterator2.next(); <span class="hljs-comment">// 运行结果？</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="迭代器模式（下）：如何设计实现一个支持“快照”功能的-iterator？"><a href="#迭代器模式（下）：如何设计实现一个支持“快照”功能的-iterator？" class="headerlink" title="迭代器模式（下）：如何设计实现一个支持“快照”功能的 iterator？"></a>迭代器模式（下）：如何设计实现一个支持“快照”功能的 iterator？</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？ </p>
<p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。 </p>
<p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器 list 中初始存储 了 3、8、2 三个元素。尽管在创建迭代器 iter1 之后，容器 list 删除了元素 3，只剩下 8、 2 两个元素，但是，通过 iter1 遍历的对象是快照，而非容器 list 本身。所以，遍历的结果 仍然是 3、8、2。同理，iter2、iter3 也是在各自的快照上遍历，输出的结果如代码中注释 所示。</p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量 snapshot 来存储快 照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。</p>
<p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快 照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内 存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对 象并非真的拷贝了多份，而只是拷贝了对象的引用而已。关于深拷贝、浅拷贝，我们在 第 47 讲中有详细的讲解，你可以回过头去再看一下。 </p>
<p>那有没有什么方法，既可以支持快照，又不需要拷贝容器呢？</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一 个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素 被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。 </p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。 </p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestampsnapshotTimestamp，说明元素在创建了迭代器之后才加入 的，不属于这个迭代器的快照；如果元素的 delTimestamp&lt;snapshotTimestamp，说明<br>元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑 ArrayList 的扩容问题，感兴趣的话，你可以自己完善一<br>下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层 依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法 支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的 《数据结构与算法之美》专栏，这里我就不展开讲解了。 </p>
<p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？ </p>
<p>解决的方法也不难，我稍微提示一下。我们可以在 ArrayList 中存储两个数组。一个支持标 记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从</p>
<p>数组中移除），用来支持随机访问。对应的代码我这里就不给出了，感兴趣的话你可以自己 实现一下。 </p>
<h3 id="重点回顾-11"><a href="#重点回顾-11" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>今天我们讲了如何实现一个支持“快照”功能的迭代器。其实这个问题本身并不是学习的重 点，因为在真实的项目开发中，我们几乎不会遇到这样的需求。所以，基于今天的内容我不 想做过多的总结。我想和你说一说，为什么我要来讲今天的内容呢？ </p>
<p><u>实际上，学习本节课的内容，如果你只是从前往后看一遍，看懂就觉得 ok 了，那收获几乎 是零。</u>一个好学习方法是，把它当作一个思考题或者面试题，在看我的讲解之前，自己主动 思考如何解决，并且把解决方案用代码实现一遍，然后再来看跟我的讲解有哪些区别。这个 过程对你分析问题、解决问题的能力的锻炼，代码设计能力、编码能力的锻炼，才是最有价 值的，才是我们这篇文章的意义所在。所谓“知识是死的，能力才是活的”就是这个道理。 </p>
<p>其实，不仅仅是这一节的内容，整个专栏的学习都是这样的。</p>
<p><strong>只掌握了知识，没 锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。</strong></p>
<h1 id="行为型模式-下篇"><a href="#行为型模式-下篇" class="headerlink" title="行为型模式 | 下篇"></a>行为型模式 | 下篇</h1><h2 id="行为型模式总览-1"><a href="#行为型模式总览-1" class="headerlink" title="行为型模式总览"></a>行为型模式总览</h2><p>创建型设计模式：主要解决“对象的创建”问题</p>
<p>结构型设计模式：主要解决“类或对象的组合或组装”问题</p>
<p>行为型设计模式：主要解决“类或对象之间的交互”问题</p>
<hr>
<p>观察者模式：发布订阅模式，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>
<p>模板方法模式：让子类在不改变业务逻辑整体结构的情况下，重新定义其中的某些步骤</p>
<p>策略模式：定义一族算法类将每个算法分别封装起来，让它们可以互相替换</p>
<p>职责链模式：多个处理器依次处理同一个请求</p>
<p>迭代器模式：遍历集合对象</p>
<p>状态模式：将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</p>
<hr>
<p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</p>
<p>备忘录模式：存储副本以便后期恢复</p>
<p>命令模式：将函数封装成对象，把函数像对象一样使用</p>
<p>解释器模式：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</p>
<p>中介模式：一组对象之间的交互关系从多对多（网状关系）转换为一对多（星状关系）</p>
<h2 id="设计模式使用频率-1"><a href="#设计模式使用频率-1" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote>
<p>提前说明</p>
</blockquote>
<p>23 种经典设计模式中最难理解的几个之一。因为它难理解、难实 现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很 少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<blockquote>
<p>模式定义</p>
</blockquote>
<p>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保 持类职责单一、满足开闭原则以及应对代码的复杂性。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作 （抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile） 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访 问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类 （Extractor、Compressor）中。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：为什么支持双分派的语言不需要访问者模式？</strong></p>
<p>Single Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>编译时类型</strong>来决定</p>
<p>Double Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>运行时类型</strong>来决定。</p>
<p>当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch</p>
<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函 数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪 个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的 运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我 们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现， 备份更侧重架构设计或产品设计。</p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对 这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的 数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结 合来做恢复。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>应用范围并不广，它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行。</p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主 要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做 命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p><strong>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。</strong></p>
<p>我们知道，C 语 言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函 数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数 封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样 就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：命令模式 vs 工厂模式 vs 策略模式</strong></p>
<p>设计模式之间的主要区别还是在于设计意图，也就是应用场景</p>
<p><strong>策略模式 vs 工厂模式</strong></p>
<p>策略模式包含策略的定义、创建和使用三部分，从代 码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个 特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式 侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是 其他东西。</p>
<p><strong>策略模式 vs 命令模式</strong></p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对 应不同的处理逻辑，并且互相之间不可替换。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法</p>
<p>解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>生活案例：中英文翻译</strong></p>
<p>把英文翻译成中文是有一定 规则的。这个规则就是定义中的“语法”。我们开发一个类似 Google Translate 这样的翻 译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器 模式定义中的“解释器”</p>
<p><strong>实战案例：自定义接口告警规则</strong></p>
<p>自定义一个表达式，来 表示一个告警规则，然后实现这个规则的解释器</p>
<p><strong>其他的重要应用场景</strong></p>
<p>只在一些特定的领域会被用到，比如编译器、规则引擎、正则 表达式。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编 译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生 成机器可以执行的汇编指令。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p><strong>Q：代码实现的核心思想</strong></p>
<p>将语法 解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆 分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p><strong>概念：</strong> 中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。 将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p><strong>设计思想：</strong> 通过引入中介这个中间层，将一组对象之间的 交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。</p>
<p>原来一个 对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关 系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>生活场景：航空管制</strong></p>
<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需 要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引 入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来 负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p><strong>编程相关：UI 控件</strong></p>
<p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。 当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选 择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登 陆相关的控件就会显示在对话框中。</p>
<p>实现方式一：控件和控件之间互相操作、互相依赖。</p>
<p>实现方式二：各个控件只跟中介 对象交互，中介对象负责所有业务逻辑的处理。</p>
<p>好处是简化了控件之间的交互，坏处是中介类有可能会 变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实 际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>现在流行的微服务，注册中心可以理解为广义的中介模式，防止各个服务间错综复 杂的调用</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：观察者模式和中介模式的区别</strong></p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应 用场景上。</p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分 情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具 两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。当维护成本很高的时候，我们 才考虑使用中介模式。</p>
<h1 id="访问者模式-1"><a href="#访问者模式-1" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="访问者模式（上）：手把手带你还原访问者模式诞生的思维过程"><a href="#访问者模式（上）：手把手带你还原访问者模式诞生的思维过程" class="headerlink" title="访问者模式（上）：手把手带你还原访问者模式诞生的思维过程"></a>访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</h2><p>23 种经典设计模式中最难理解的几个之一。因为它难理解、难实 现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很 少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<p>带你“发明”访问者模式 </p>
<p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现 在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的 文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？ </p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其 中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、 WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<h3 id="带你“发明”访问者模式"><a href="#带你“发明”访问者模式" class="headerlink" title="带你“发明”访问者模式"></a>带你“发明”访问者模式</h3><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现 在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的 文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？ </p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其 中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、 WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PPTFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PPTFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...省略一大坨从PPT中抽取文本的代码...</span><br>        <span class="hljs-comment">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 运行结果是：</span><br><span class="hljs-comment">// Extract PDF.</span><br><span class="hljs-comment">// Extract WORD.</span><br><span class="hljs-comment">// Extract PPT.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.extract2txt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文 件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思 路，就会存在这样几个问题：</p>
<p>1、违背开闭原则，添加一个新的功能，所有类的代码都要修改； </p>
<p>2、虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</p>
<p>3、把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的 职责不够单一，变成了大杂烩。</p>
<p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦， 设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后 的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile代码省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重 载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类 中函数名相同、参数不同的一组函数。 </p>
<p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 37 行会报错。这是 为什么呢？ </p>
<p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应 的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明 类型执行声明类型对应的方法。 </p>
<p>在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile， 而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数， 所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。 那如何解决这个问题呢？ </p>
<p>解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span> &#123;<br>        extractor.extract2txt(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-comment">//...Extractor代码不变...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的， 在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函 数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访 问者模式不好理解的原因。 </p>
<p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不 同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类 的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除 此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Compressor compressor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span> &#123;<br>        extractor.extract2txt(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Compressor compressor)</span> &#123;<br>        compressor.compress(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-comment">//...Extractor代码不变</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>        <span class="hljs-type">Compressor</span> <span class="hljs-variable">compressor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compressor</span>();<br>        <span class="hljs-keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(compressor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭 原则。针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我 们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。 </p>
<p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor vistor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pdfFile)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile pdfFile)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compressor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>        <span class="hljs-type">Compressor</span> <span class="hljs-variable">compressor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compressor</span>();<br>        <span class="hljs-keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(compressor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="重新来看访问者模式"><a href="#重新来看访问者模式" class="headerlink" title="重新来看访问者模式"></a>重新来看访问者模式</h3><p>刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这 个模式的原理和代码实现。 访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它 是这么定义的：</p>
<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>
<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。 </p>
<p>定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实 现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现 代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看 一下。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131227.png" alt="image-20220119194824931"></p>
<p>最后，我们再来看下，访问者模式的应用场景。 </p>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，</p>
<h3 id="重点回顾-12"><a href="#重点回顾-12" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保 持类职责单一、满足开闭原则以及应对代码的复杂性。 </p>
<p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重 载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编 译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。 </p>
<p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如 果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得 已，不要使用这种模式。</p>
<h2 id="访问者模式（下）：为什么支持双分派的语言不需要访问者模-式？"><a href="#访问者模式（下）：为什么支持双分派的语言不需要访问者模-式？" class="headerlink" title="访问者模式（下）：为什么支持双分派的语言不需要访问者模 式？"></a>访问者模式（下）：为什么支持双分派的语言不需要访问者模 式？</h2><h3 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h3><p> 实际上，讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为 双分派。虽然学习访问者模式，并不用非得理解这个概念，我们前面的讲解就没有提到它， 但是，为了让你在查看其它书籍或者资料的时候，不会卡在这个概念上，我觉得有必要在这 里讲一下。 </p>
<p>除此之外，我觉得，学习 Double Dispatch 还能加深你对访问者模式的理解，而且能一并 帮你搞清楚今天文章标题中的这个问题：为什么支持双分派的语言就不需要访问者模式？这 个问题在面试中可是会被问到的哦！ </p>
<p>既然有 Double Dispatch，对应的就有 Single Dispatch。所谓 Single Dispatch，指的 是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参 数的编译时类型来决定。所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象 的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 </p>
<p><strong>如何理解“Dispatch”这个单词呢？</strong> </p>
<p>在面向对象编程语言中，我们可以把方法调用理解为 一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发 送一条消息。这条消息起码要包含对象名、方法名、方法参数。 </p>
<p><strong>如何理解“Single”“Double”这两个单词呢？</strong></p>
<p>“Single”“Double”指的是执行哪个 对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有 关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对 象”和“方法参数”两者的运行时类型有关。 </p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直 接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。 接下来，我们拿 Java 语言来举例说明一下。</p>
<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函 数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪 个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的 运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。 </p>
<p>这么说比较抽象，我举个例子来具体说明一下，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am ParentClass&#x27;s f().&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am ChildClass&#x27;s f().&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleDispatchClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">polymorphismFunction</span><span class="hljs-params">(ParentClass p)</span> &#123;<br>        p.f();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">overloadFunction</span><span class="hljs-params">(ParentClass p)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">overloadFunction</span><span class="hljs-params">(ChildClass c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SingleDispatchClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleDispatchClass</span>();<br>        <span class="hljs-type">ParentClass</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildClass</span>();<br>        demo.polymorphismFunction(p);<span class="hljs-comment">//执行哪个对象的方法，由对象的实际类型决定</span><br>        demo.overloadFunction(p);<span class="hljs-comment">//执行对象的哪个方法，由参数对象的声明类型决定</span><br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//代码执行结果:</span><br>    I am ChildClass<span class="hljs-string">&#x27;s f().</span><br><span class="hljs-string">    I am overloadFunction(ParentClass p).</span><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，第 31 行代码的 polymorphismFunction() 函数，执行 p 的实际类型的 f() 函数，也就是 ChildClass 的 f() 函数。第 32 行代码的 overloadFunction() 函数，匹配 的是重载函数中的 overloadFunction(ParentClass p)，也就是根据 p 的声明类型来决定 匹配哪个重载函数。 </p>
<p>假设 Java 语言支持 Double Dispatch，那下面的代码（摘抄自上节课中第二段代码，建议 结合上节课的讲解一块理解）中的第 37 行就不会报错。代码会在运行时，根据参数 （resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用 extract2txt 的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式 了。这也回答了为什么支持 Double Dispatch 的语言不需要访问者模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile代码省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="除了访问者模式，上一节的例子还有其他实现方案吗？"><a href="#除了访问者模式，上一节的例子还有其他实现方案吗？" class="headerlink" title="除了访问者模式，上一节的例子还有其他实现方案吗？"></a>除了访问者模式，上一节的例子还有其他实现方案吗？</h3><p>上节课，我通过一个例子来给你展示了，访问者模式是如何一步一步设计出来的。我们这里 再一块回顾一下那个例子。我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、 PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压 缩资源文件、提取文件元信息等。 </p>
<p>实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选 择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂 模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、 PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数 中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据 不同的文件类型，返回不同的 Extractor。 </p>
<p>这个实现思路其实更加简单，我们直接看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ResourceFileType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ResourceFileType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ResourceFileType.PDF;<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(ResourceFile resourceFile)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfExtractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(ResourceFile resourceFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtractorFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        extractors.put(ResourceFileType.PDF, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfExtractor</span>());<br>        extractors.put(ResourceFileType.PPT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTExtractor</span>());<br>        extractors.put(ResourceFileType.WORD, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WordExtractor</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Extractor <span class="hljs-title function_">getExtractor</span><span class="hljs-params">(ResourceFileType type)</span> &#123;<br>        <span class="hljs-keyword">return</span> extractors.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> ExtractorFactory.getExtractor(resourceFile.getType<br>                    extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们 只需要添加一个 Compressor 接口，PdfCompressor、PPTCompressor、 WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一 需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关 闭”的设计原则。 </p>
<p>对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我 更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的 功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂 模式的实现方式少很多，类太多也会影响到代码的可维护性。 </p>
<h3 id="重点回顾-13"><a href="#重点回顾-13" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>总体上来讲，访问者模式难以理解，应用场景有限，不是特别必需，我不建议在项目中使用 它。所以，对于上节课中的处理资源文件的例子，我更推荐使用工厂模式来设计和实现。 </p>
<p>除此之外，我们今天重点讲解了 Double Dispatch。在面向对象编程语言中，方法调用可 以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发 送一条消息，这条消息起码要包含对象名、方法名和方法参数。 </p>
<p>所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行 对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispatch，指的是执 行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的 运行时类型来决定。</p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直 接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>
<h1 id="备忘录模式-1"><a href="#备忘录模式-1" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的-消耗？"><a href="#备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的-消耗？" class="headerlink" title="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的 消耗？"></a>备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的 消耗？</h2><p>应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等</p>
<h3 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h3><p>备忘录模式，也叫快照（Snapshot）模式：</p>
<p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>在我看来，这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这 一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这 部分不太好理解。接下来，我就结合一个例子来解释一下，特别带你搞清楚这两个问题：</p>
<p>1为什么存储和恢复副本会违背封装原则？ </p>
<p>2备忘录模式是如何做到不违背封装原则的？</p>
<p>假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本 时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的 内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输 入的文本删除掉。</p>
<p>怎么来编程实现呢？你可以打开 IDE 自己先试着编写一下，然后再看我下面的讲解。整体 上来讲，这个小程序实现起来并不复杂。我写了一种实现思路，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputText</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(String input)</span> &#123;<br>        text.append(input);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text.replace(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.text.length(), text);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;InputText&gt; snapshots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> InputText <span class="hljs-title function_">popSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snapshots.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushSnapshot</span><span class="hljs-params">(InputText inputText)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">deepClonedInputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        deepClonedInputText.setText(inputText.getText());<br>        snapshots.push(deepClonedInputText);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">inputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        <span class="hljs-type">SnapshotHolder</span> <span class="hljs-variable">snapshotsHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotHolder</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:list&quot;</span>)) &#123;<br>                System.out.println(inputText.toString());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:undo&quot;</span>)) &#123;<br>                <span class="hljs-type">InputText</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotsHolder.popSnapshot();<br>                inputText.setText(snapshot.getText());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                snapshotsHolder.pushSnapshot(inputText);<br>                inputText.append(input);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编 程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功 能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二 点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一 点，主要体现在下面两方面：</p>
<p>第一，为了能用快照恢复 InputText 对象，我们在 InputText 类中定义了 setText() 函 数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原 则；</p>
<p>第二，快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数， 但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，用 InputText 类来表示快照违 背了封装原则。</p>
<p>针对以上问题，我们对代码做两点修改。其一，定义一个独立的类（Snapshot 类）来表示 快照，而不是复用 InputText 类。这个类只暴露 get() 方法，没有 set() 等任何修改内部状 态的方法。其二，在 InputText 类中，我们把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确，只用来恢复对象。 </p>
<p>按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputText</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(String input)</span> &#123;<br>        text.append(input);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Snapshot <span class="hljs-title function_">createSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(text.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreSnapshot</span><span class="hljs-params">(Snapshot snapshot)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text.replace(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.text.length(), snapshot.getText());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Snapshot</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Snapshot</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.text;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> Snapshot <span class="hljs-title function_">popSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snapshots.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushSnapshot</span><span class="hljs-params">(Snapshot snapshot)</span> &#123;<br>        snapshots.push(snapshot);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">inputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        <span class="hljs-type">SnapshotHolder</span> <span class="hljs-variable">snapshotsHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotHolder</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:list&quot;</span>)) &#123;<br>                System.out.println(inputText.toString());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:undo&quot;</span>)) &#123;<br>                <span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotsHolder.popSnapshot();<br>                inputText.restoreSnapshot(snapshot);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                snapshotsHolder.pushSnapshot(inputText.createSnapshot());<br>                inputText.append(input);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 GoF 的 《设计模式》）中给出的实现方法。 </p>
<p>除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在我们平时的开发中更常听 到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都 应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和 实现，备份更侧重架构设计或产品设计。这个不难理解，这里我就不多说了。</p>
<h3 id="如何优化内存和时间消耗？"><a href="#如何优化内存和时间消耗？" class="headerlink" title="如何优化内存和时间消耗？"></a>如何优化内存和时间消耗？</h3><p>前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要 备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗 时会比较长。这个问题该如何解决呢？ </p>
<p>不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘 录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入， 不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，我们不 需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用 这个值结合 InputText 类对象存储的文本来做撤销操作。 我们再举一个例子。假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果 需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对 时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会采用“低频率全量备 份”和“高频率增量备份”相结合的方法。 </p>
<p>全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下 来。所谓“增量备份”，指的是记录每次操作或数据变动。 </p>
<p>当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来 恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份， 然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的 操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p>
<h3 id="重点回顾-14"><a href="#重点回顾-14" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内 部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义 表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则 的前提下，进行对象的备份和恢复。 </p>
<p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我 们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现， 备份更侧重架构设计或产品设计。 </p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对 这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的 数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结 合来做恢复。</p>
<h1 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="命令模式：如何利用命令模式实现一个手游后端架构？"><a href="#命令模式：如何利用命令模式实现一个手游后端架构？" class="headerlink" title="命令模式：如何利用命令模式实现一个手游后端架构？"></a>命令模式：如何利用命令模式实现一个手游后端架构？</h2><p>命令 模式、解释器模式、中介模式。这 3 个模式使用频率低、理解难度大，只在非常特定的应 用场景下才会用到，所以，不是我们学习的重点，你只需要稍微了解，见了能认识就可以 了。</p>
<p>在学习这个模式的过程中，你可能会遇到的最大的疑 惑是，感觉命令模式没啥用，是一种过度设计，有更加简单的设计思路可以替代。所以，我 今天讲解的重点是这个模式的设计意图，带你搞清楚到底什么情况下才真正需要使用它。</p>
<h3 id="命令模式的原理解读"><a href="#命令模式的原理解读" class="headerlink" title="命令模式的原理解读"></a>命令模式的原理解读</h3><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。 </p>
<p>GoF 给出的定义，我这里再进一步解读一下。 </p>
<p>落实到编码实现，命令模式用的最核心的实现手段，<strong>是将函数封装成对象。</strong>我们知道，C 语 言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函 数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数 封装成对象。具体来说就是，设计<strong>一个包含这个函数的类，实例化一个对象传来传去，这样 就可以实现把函数像对象一样使用。</strong>从实现的角度来说，它类似我们之前讲过的回调。 </p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，<strong>命令模式的主 要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做 命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</strong></p>
<h3 id="命令模式的实战讲解"><a href="#命令模式的实战讲解" class="headerlink" title="命令模式的实战讲解"></a>命令模式的实战讲解</h3><p>上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。 </p>
<p>假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的 复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询， 所以，后端逻辑相对于客户端来说，要简单很多。</p>
<p>考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。 </p>
<p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内 存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低 实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个 玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简 单了很多。 </p>
<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建 立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服 务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据 是执行这个指令所需的数据。 </p>
<p>服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同 的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。 </p>
<p>常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线 程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一 个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。 </p>
<p>另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它 无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切 换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器 开发中比较常见的架构模式了。 </p>
<p>我们接下来就重点讲一下第二种实现方式。</p>
<p>整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求 包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定 数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示， 你可以结合着一块看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GotDiamondCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">// 省略成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GotDiamondCommand</span><span class="hljs-params">(<span class="hljs-comment">/*数据*/</span>)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 执行相应的逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameApplication</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_HANDLED_REQ_COUNT_PER_LOOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> Queue&lt;Command&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mainloop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            List&lt;Request&gt; requests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span><br><span class="hljs-comment">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span><br>            <span class="hljs-keyword">for</span> (Request request : requests) &#123;<br>                <span class="hljs-type">Event</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> request.getEvent();<br>                <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GotDiamondCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.GOT_STAR)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GotStartCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HitObstacleCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.ARCHIVE)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArchiveCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-comment">// ...一堆else if...</span><br>                queue.add(command);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">handledCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;<br>                <span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> queue.poll();<br>                command.execute();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="命令模式-VS-策略模式"><a href="#命令模式-VS-策略模式" class="headerlink" title="命令模式 VS 策略模式"></a>命令模式 VS 策略模式</h3><p>看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区 别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都 很相似。不知道你有没有类似的感觉呢？ </p>
<p>实际上，这个问题我之前简单提到过，可能没有作为重点来说，有些同学印象不是很深刻， 这里我就再跟你讲一讲。 </p>
<p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪 类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现 并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就 会产生大部分模式看起来都很相似的错觉。 </p>
<p>实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路 或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。 </p>
<p>之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代 码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个 特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式 侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是 其他东西。从设计意图上来，这两个模式完全是两回事儿。 </p>
<p>有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的 执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区 别。 </p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对 应不同的处理逻辑，并且互相之间不可替换。</p>
<h3 id="重点回顾-15"><a href="#重点回顾-15" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>命令模式在平时工作中并不常用，你稍微了解一下就可以。今天，我重点讲解了它的设计意 图，也就是能解决什么问题。 </p>
<p><u>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在 大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令 模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</u> </p>
<p><u>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命 令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用 的地方。</u></p>
<h1 id="解释器模式-1"><a href="#解释器模式-1" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="解释器模式：如何设计实现一个自定义接口告警规则功能？"><a href="#解释器模式：如何设计实现一个自定义接口告警规则功能？" class="headerlink" title="解释器模式：如何设计实现一个自定义接口告警规则功能？"></a>解释器模式：如何设计实现一个自定义接口告警规则功能？</h2><p>解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令 模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则 表达式。</p>
<h3 id="解释器模式的原理和实现"><a href="#解释器模式的原理和实现" class="headerlink" title="解释器模式的原理和实现"></a>解释器模式的原理和实现</h3><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解 释器用来处理这个语法。</p>
<p>实际上，这里的“语言”不仅仅指我们平时说的中、英、 日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语 言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。 </p>
<p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据 语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅 读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是 应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的<u>核心思想，就是将语法 解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆 分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</u></p>
<p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。 利用解释器模式，我们把解析的工作拆分到 NumberExpression、AdditionExpression、 SubstractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析 类中。</p>
<h3 id="解释器模式实战举例"><a href="#解释器模式实战举例" class="headerlink" title="解释器模式实战举例"></a>解释器模式实战举例</h3><p>接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一 个自定义接口告警规则功能？ </p>
<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时 将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微 信、邮件等方式发送告警给开发者。 </p>
<p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来 表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调 用数超过 10000 就触发告警。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">api_error_per_minute &gt; <span class="hljs-number">100</span> || api_count_per_minute &gt; <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块 将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块。接下来，我们只 关注告警模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Long&gt; apiStat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>apiStat.put(<span class="hljs-string">&quot;api_error_per_minute&quot;</span>, <span class="hljs-number">103</span>);<br>apiStat.put(<span class="hljs-string">&quot;api_count_per_minute&quot;</span>, <span class="hljs-number">987</span>);<br></code></pre></td></tr></table></figure>

<p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这 五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算 符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可 以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。 </p>
<p>那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给 出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertRuleInterpreter</span> &#123;<br>    <span class="hljs-comment">// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertRuleInterpreter</span><span class="hljs-params">(String ruleExpression)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>由你来完善</span><br>    &#125;<br>    <span class="hljs-comment">//&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();</span><br><span class="hljs-comment">//apiStat.put(&quot;key1&quot;, 103);</span><br><span class="hljs-comment">//apiStat.put(&quot;key2&quot;, 987);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>由你来完善</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;</span>;<br>        <span class="hljs-type">AlertRuleInterpreter</span> <span class="hljs-variable">interpreter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertRuleInterpreter</span>(rule);<br>        Map&lt;String, Long&gt; stats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        stats.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">101l</span>);<br>        stats.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">121l</span>);<br>        stats.put(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-number">88l</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">alert</span> <span class="hljs-operator">=</span> interpreter.interpret(stats);<br>        System.out.println(alert);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个 解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们 把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路， 我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> String key;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GreaterExpression</span><span class="hljs-params">(String strExpression)</span> &#123;<br>        String[] elements = strExpression.trim().split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <span class="hljs-keyword">if</span> (elements.length != <span class="hljs-number">3</span> || !elements[<span class="hljs-number">1</span>].trim().equals(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Expression is invalid: &quot;</span> + strExpression);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.key = elements[<span class="hljs-number">0</span>].trim();<br>        <span class="hljs-built_in">this</span>.value = Long.parseLong(elements[<span class="hljs-number">2</span>].trim());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GreaterExpression</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!stats.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">statValue</span> <span class="hljs-operator">=</span> stats.get(key);<br>        <span class="hljs-keyword">return</span> statValue &gt; value;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(String strAndExpression)</span> &#123;<br>        String[] strExpressions = strAndExpression.split(<span class="hljs-string">&quot;&amp;&amp;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String strExpr : strExpressions) &#123;<br>            <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GreaterExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;&lt;&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LessExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;==&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Expression is invalid: &quot;</span> + strAndExpression<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(List&lt;Expression&gt; expressions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expressions.addAll(expressions);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Expression expr : expressions) &#123;<br>            <span class="hljs-keyword">if</span> (!expr.interpret(stats)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(String strOrExpression)</span> &#123;<br>        String[] andExpressions = strOrExpression.split(<span class="hljs-string">&quot;\\|\\|&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String andExpr : andExpressions) &#123;<br>            expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AndExpression</span>(andExpr));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(List&lt;Expression&gt; expressions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expressions.addAll(expressions);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Expression expr : expressions) &#123;<br>            <span class="hljs-keyword">if</span> (expr.interpret(stats)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertRuleInterpreter</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression expression;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertRuleInterpreter</span><span class="hljs-params">(String ruleExpression)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expression = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(ruleExpression);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">return</span> expression.interpret(stats);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点回顾 </p>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个 语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义 上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、 盲文、哑语、摩斯密码等。 </p>
<p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根 据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅 读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。 </p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应 对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作 拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的 独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<p><strong>Q：什么地方用到了解释器模式？</strong></p>
<p>Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编 译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生 成机器可以执行的汇编指令。</p>
<h1 id="中介模式-1"><a href="#中介模式-1" class="headerlink" title="中介模式"></a>中介模式</h1><h2 id="中介模式：什么时候用中介模式？什么时候用观察者模式？"><a href="#中介模式：什么时候用中介模式？什么时候用观察者模式？" class="headerlink" title="中介模式：什么时候用中介模式？什么时候用观察者模式？"></a>中介模式：什么时候用中介模式？什么时候用观察者模式？</h2><h3 id="中介模式的原理和实现"><a href="#中介模式的原理和实现" class="headerlink" title="中介模式的原理和实现"></a>中介模式的原理和实现</h3><p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。 将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>还记得我们在第 30 节课中讲的“如何给代码解耦”吗？其中一个方法就是引入中间层。 </p>
<p>实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的 交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个 对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关 系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>这里我画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关 系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131228.png" alt="image-20220120083956928"></p>
<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。</p>
<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需 要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引 入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来 负责每架飞机的航线调度。这样就大大简化了通信网络。 </p>
<p>刚刚举的是生活中的例子，我们再举一个跟编程开发相关的例子。这个例子与 UI 控件有 关，算是中介模式比较经典的应用，很多书籍在讲到中介模式的时候，都会拿它来举例。</p>
<p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。 当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选 择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登 陆相关的控件就会显示在对话框中。 </p>
<p>按照通常我们习惯的 UI 界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这 个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIControl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;login_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REG_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;reg_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USERNAME_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pswd_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;repeated_pswd_input</span><br><span class="hljs-string">    private static final String HINT_TEXT_ID = &quot;</span>hint_text<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    private static final String SELECTION_ID = &quot;</span>selection<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="hljs-string">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="hljs-string">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="hljs-string">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="hljs-string">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="hljs-string">        loginButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                String username = usernameInput.text();</span><br><span class="hljs-string">                String password = passwordInput.text();</span><br><span class="hljs-string">        //校验数据...</span><br><span class="hljs-string">        //做业务处理...</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        regButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">        //获取usernameInput、passwordInput、repeatedPswdInput数据...</span><br><span class="hljs-string">        //校验数据...</span><br><span class="hljs-string">        //做业务处理...</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//...省略selection下拉选择框相关代码....</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<p>我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介 对象交互，中介对象负责所有业务逻辑的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(Component component, String event)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LandingPageDialog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">private</span> Button loginButton;<br>    <span class="hljs-keyword">private</span> Button regButton;<br>    <span class="hljs-keyword">private</span> Selection selection;<br>    <span class="hljs-keyword">private</span> Input usernameInput;<br>    <span class="hljs-keyword">private</span> Input passwordInput;<br>    <span class="hljs-keyword">private</span> Input repeatedPswdInput;<br>    <span class="hljs-keyword">private</span> Text hintText;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(Component component, String event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (component.equals(loginButton)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> usernameInput.text();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> passwordInput.text();<br><span class="hljs-comment">//校验数据...</span><br><span class="hljs-comment">//做业务处理...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.equals(regButton)) &#123;<br><span class="hljs-comment">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span><br><span class="hljs-comment">//校验数据...</span><br><span class="hljs-comment">//做业务处理...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.equals(selection)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">selectedItem</span> <span class="hljs-operator">=</span> selection.select();<br>            <span class="hljs-keyword">if</span> (selectedItem.equals(<span class="hljs-string">&quot;login&quot;</span>)) &#123;<br>                usernameInput.show();<br>                passwordInput.show();<br>                repeatedPswdInput.hide();<br>                hintText.hide();<br><span class="hljs-comment">//...省略其他代码</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedItem.equals(<span class="hljs-string">&quot;register&quot;</span>)) &#123;<br><span class="hljs-comment">//....</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIControl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;login_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REG_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;reg_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USERNAME_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pswd_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;repeated_pswd_input</span><br><span class="hljs-string">    private static final String HINT_TEXT_ID = &quot;</span>hint_text<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    private static final String SELECTION_ID = &quot;</span>selection<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="hljs-string">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="hljs-string">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="hljs-string">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="hljs-string">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="hljs-string">        Mediator dialog = new LandingPageDialog();</span><br><span class="hljs-string">        dialog.setLoginButton(loginButton);</span><br><span class="hljs-string">        dialog.setRegButton(regButton);</span><br><span class="hljs-string">        dialog.setUsernameInput(usernameInput);</span><br><span class="hljs-string">        dialog.setPasswordInput(passwordInput);</span><br><span class="hljs-string">        dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class="hljs-string">        dialog.setHintText(hintText);</span><br><span class="hljs-string">        dialog.setSelection(selection);</span><br><span class="hljs-string">        loginButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                dialog.handleEvent(loginButton, &quot;</span>click<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        regButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                dialog.handleEvent(regButton, &quot;</span>click<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//....</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实 际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会 变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实 际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<h3 id="中介模式-VS-观察者模式"><a href="#中介模式-VS-观察者模式" class="headerlink" title="中介模式 VS 观察者模式"></a>中介模式 VS 观察者模式</h3><p>前面讲观察者模式的时候，我们讲到，观察者模式有多种实现方式。虽然经典的实现方式没 法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用 观察者的 update() 方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底 解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被 观察者也完全不知道观察者的存在。 </p>
<p>我们前面提到，中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交 互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察 者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式 的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？ </p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分 情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具 两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。 </p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们 才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能 会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作 有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者 的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。 </p>
<h3 id="重点回顾-16"><a href="#重点回顾-16" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系 （或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代 码的复杂度，提高了代码的可读性和可维护性。 </p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应 用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的， 一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中， 参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
