<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式01-创建型模式</title>
    <url>/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式-创建型模式"><a href="#设计模式-创建型模式" class="headerlink" title="设计模式 | 创建型模式"></a>设计模式 | 创建型模式</h1><h2 id="创建型模式总览"><a href="#创建型模式总览" class="headerlink" title="创建型模式总览"></a>创建型模式总览</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 </p>
<p>单例模式：用来创建全局唯一的对象。</p>
<p>工厂模式：用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式：用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>原型模式：针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>实战案例一：处理资源访问冲突 </p>
<p>实战案例二：表示全局唯一类</p>
<p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>配置信息类：在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。 </p>
<p>唯一递增 ID 号码生成器：（区分：唯一 ID 生成器 和 唯一递增 ID 生成器）如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>SpringIoC中注入的bean，如果没有额外配置，默认是单例</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>饿汉式、懒汉式、双重检测实现方式</p>
<p>静态内部类、枚举</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建不同但是相关类型的对象（继 承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>简单工厂：</strong></p>
<p>我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<p>简单工厂模式的第一种实现方法：</p>
<p>简单工厂模式的第二种实现方法： </p>
<p>如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p>
<p><strong>工厂方法：</strong></p>
<p>简化简单工厂中的 if-else 逻辑，使用多态的方法实现</p>
<p><strong>抽象工厂：</strong></p>
<p>没有前两种常用，在简单工厂和工厂方法中，类只有一种分类方式。</p>
<p>抽象工厂让一个工厂负责创建多个不同类型的对象，而不是只创建一种对象。这样就可以有效地减少工厂类的个数。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Spring中的BeanFactory</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>简单工厂、工厂方法、抽象工厂</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<hr>
<p>当我们创建对象的时候，需要传递的参数很多，构造函数列表冗长，代码的可读性和易用性会变差</p>
<p>使用set方法设置，那么校验这些必填项是否已经填写的逻辑就无处安放</p>
<p>除此之外，假设配置项之间有一定的依赖关系，设置一个属性之后，必须要显示的设置另外几个（例如：更新余额之后，设置最后的更新时间）</p>
<p>或者创建对象时，配置项之间有一定的约束条件（例如：min &lt;= mid &lt;= max）</p>
<p>同时，我们希望创建的类的对象是不可变对象，即不能在这个类中暴露 set 方法</p>
<p>那么，我们可以，把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。</p>
<p>但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。</p>
<p>如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
<p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
<p>把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。</p>
<blockquote>
<p>创建对象的几种方式：</p>
</blockquote>
<p>（1）使用构造函数或者配合 set 方法</p>
<p>（2）使用建造者模式创建对象</p>
<p>（3）使用工厂模式创建对象</p>
<p><strong>Q：使用构造函数或者配合 set 方法就能创建对象，为什么还要用建造者模式</strong></p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p><strong>Q：建造者模式 和 工厂模式 有什么区别</strong></p>
<p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别： </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。</p>
<p><strong>Q：什么是对象创建成本比较大？</strong></p>
<p>从数据库中读取数据创建对象、创建对象时需要经过经过大量的计算</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>浅拷贝：clone</p>
<p>深拷贝：BeanUtils、递归拷贝对象和对象引用、先序列化再反序列化成新的对象</p>
<h2 id="Ex：创建对象的几种方式"><a href="#Ex：创建对象的几种方式" class="headerlink" title="Ex：创建对象的几种方式"></a>Ex：创建对象的几种方式</h2><p>1、使用 new 关键字创建对象：</p>
<p>这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造函数（无参的和有参的）。比如：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Student student <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>2、反射：使用Class类的newInstance方法：</p>
<p>我们也可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：`</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Student student2 = (Student)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;根路径.Student&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;　<br></code></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> Student.class.newInstance();<br></code></pre></td></tr></table></figure>

<p>3、反射：使用Constructor类的newInstance方法</p>
<p>本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。</p>
<p>我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Constructor&lt;Student&gt; constructor = Student.class.getInstance(); <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> constructor.newInstance();　<br></code></pre></td></tr></table></figure>

<p>这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
<p>这也是众多框架Spring、Hibernate、Struts等使用后者的原因。</p>
<p>4、使用Clone的方法：</p>
<p>无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> &lt;Student&gt;stu.clone();<br></code></pre></td></tr></table></figure>

<p>这也是原型模式的应用。</p>
<p>5、使用反序列化：</p>
<p>当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.obj&quot;</span>)); <br><span class="hljs-type">Student</span> <span class="hljs-variable">stu3</span> <span class="hljs-operator">=</span> (Student)in.readObject();<br></code></pre></td></tr></table></figure>



<p>6、另外：两种newInstance方法有没有区别？  </p>
<p>Class类位于java的lang包中，而构造器类是java反射机制的一部分。</p>
<p>Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。</p>
<p>Class类的newInstance需要其构造方法是共有的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。</p>
<p>Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常。</p>
<p>Class类本质上调用了反射包构造器类中无参数的newInstance方法，捕获了InvocationTargetException，将构造器本身的异常抛出。</p>
<h1 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="实战案例一：处理资源访问冲突"><a href="#实战案例一：处理资源访问冲突" class="headerlink" title="实战案例一：处理资源访问冲突"></a>实战案例一：处理资源访问冲突</h3><p>在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        writer.write(mesasge);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Logger类的应用示例：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(username + <span class="hljs-string">&quot; logined!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(OrderVo order)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(<span class="hljs-string">&quot;Created an order: &quot;</span> + order.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>存在的问题：</p>
</blockquote>
<p>所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。</p>
<p>在 UserController 和 OrderController 中，我们分别创 建两个 Logger 对象。</p>
<p>在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时 分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存 在日志信息互相覆盖的情况。</p>
<blockquote>
<p>解决方案1：加对象锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被 强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同 的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p>
<blockquote>
<p>解决方案2：加类锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Logger.class) &#123; <span class="hljs-comment">// 类级别的锁</span><br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之 间同时调用 log() 函数，而导致的日志覆盖问题。</p>
<blockquote>
<p>其他解决方案：</p>
</blockquote>
<p>分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易 的事情。</p>
<p>除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题： 多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志 文件。这种方式实现起来也稍微有点复杂。 </p>
<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁 的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句 柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>
<h3 id="实战案例二：表示全局唯一类"><a href="#实战案例二：表示全局唯一类" class="headerlink" title="实战案例二：表示全局唯一类"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以 对象的形式存在，也理所应当只有一份。 </p>
<p>再比如，唯一递增 ID 号码生成器（区分：唯一 ID 生成器 和 唯一递增 ID 生成器），如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br>	<span class="hljs-comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br>	<span class="hljs-comment">// 比如下面会用到的incrementAndGet().</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-comment">// IdGenerator使用举例</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； </p>
<p>考虑对象创建时的线程安全问题； </p>
<p>考虑是否支持延迟加载； </p>
<p>考虑 getInstance() 性能是否高（是否加锁）。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存 多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行 为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。 </p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化 过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作， 会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作， 提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问 题。 </p>
<p>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程 序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一 段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优势是支持延迟加载</p>
<p>缺点也很明显，我们给 getInstance() 这个方法加了一把大锁 （synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于 串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用 到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低 等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>
<h4 id="双端检索"><a href="#双端检索" class="headerlink" title="双端检索"></a>双端检索</h4><p>既支持延迟 加载、又支持高并发的单例实现方式，也就是双重检测实现方式。 在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(IdGenerator.class) &#123; <span class="hljs-comment">// 此处为类级别的锁</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻 辑），就被另一个线程使用了。 </p>
<p>要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p>
<p>实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作 设计为原子操作，就自然能禁止重排序）。</p>
<p>关于这点的详细解释，跟特定语言有关，我就不 展开讲了，感兴趣的同学可以自行研究一下。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>比双重检测更加简单，利用 Java 的静态内部类，有点 类似饿汉式，但又能做到了延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>









<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p><strong>单例的定义</strong></p>
<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p><strong>单例的用处</strong></p>
<p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p>
<p><strong>单例的实现</strong></p>
<p>单例有下面几种经典的实现方式。</p>
<p><strong>饿汉式</strong></p>
<p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p>
<p><strong>懒汉式</strong></p>
<p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p>
<p><strong>双重检测实现方式</strong></p>
<p>既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<p><strong>静态内部类</strong></p>
<p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p>
<p><strong>枚举</strong></p>
<p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<h2 id="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h2><h3 id="单例存在哪些问题"><a href="#单例存在哪些问题" class="headerlink" title="单例存在哪些问题?"></a>单例存在哪些问题?</h3><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。</p>
<p>单例模式书写简洁、使用方便，在代码中，我们不需要创建 对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。</p>
<p>但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体 看看到底有哪些问题。 </p>
<h4 id="1-单例对-OOP-特性的支持不友好"><a href="#1-单例对-OOP-特性的支持不友好" class="headerlink" title="1.单例对 OOP 特性的支持不友好"></a>1.单例对 OOP 特性的支持不友好</h4><p>单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来 讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">//...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">// ...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要 修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>
<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词， 而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是 实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计， 会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多 态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>
<h4 id="2-单例会隐藏类之间的依赖关系"><a href="#2-单例会隐藏类之间的依赖关系" class="headerlink" title="2.单例会隐藏类之间的依赖关系"></a>2.单例会隐藏类之间的依赖关系</h4><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间 的依赖关系，搞清楚这个类依赖了哪些外部类。 通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。</p>
<p>但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需 要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>
<h4 id="3-单例对代码的扩展性不友好"><a href="#3-单例对代码的扩展性不友好" class="headerlink" title="3.单例对代码的扩展性不友好"></a>3.单例对代码的扩展性不友好</h4><p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例 或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类 大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p>
<p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。 </p>
<p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资 源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p>
<p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例 类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源 池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设 计成单例类。</p>
<h4 id="4-单例对代码的可测试性不友好"><a href="#4-单例对代码的可测试性不友好" class="headerlink" title="4.单例对代码的可测试性不友好"></a>4.单例对代码的可测试性不友好</h4><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。 </p>
<p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上 相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是 说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用 例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>
<h5 id="5-单例不支持有参数的构造函数"><a href="#5-单例不支持有参数的构造函数" class="headerlink" title="5.单例不支持有参数的构造函数"></a>5.单例不支持有参数的构造函数</h5><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来 指定连接池的大小。</p>
<p>针对这个问题，我们来看下都有哪些解决方案。 </p>
<p>第一种解决思路是：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在 使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = paramA;<br>        <span class="hljs-built_in">this</span>.paramB = paramB;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Run init() first.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Singleton has been created!&quot;</span>);<br>        &#125;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(paramA, paramB);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br>Singleton.init(<span class="hljs-number">10</span>,<span class="hljs-number">50</span>); <span class="hljs-comment">// 先init，再使用</span><br>Singleton singleton=Singleton.getInstance();<br></code></pre></td></tr></table></figure>

<p>第二种解决思路是：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>= null;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramA;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramB;<br>   <span class="hljs-keyword"> private</span> Singleton(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    &#125;<br>   <span class="hljs-keyword"> public</span> synchronized<span class="hljs-keyword"> static</span> Singleton getInstance(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton(paramA, paramB);<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br>Singleton singleton = Singleton.getInstance(10, 50);<br></code></pre></td></tr></table></figure>

<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提 示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的 解决思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>

<p>第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一 个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态 常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fianl <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">245</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = Config.PARAM_A;<br>        <span class="hljs-built_in">this</span>.paramB = Config.PARAM_B;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有何替代方案"><a href="#有何替代方案" class="headerlink" title="有何替代方案"></a>有何替代方案</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常 用到的一种实现思路。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 静态方法实现方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGenerator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> id.<span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">long</span> id = IdGenerator.getId();<br></code></pre></td></tr></table></figure>

<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。</p>
<p>我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一个种使用方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 1. 老的使用方式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">long</span> id = IdGenerator.getInstance().getId();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// 2. 新的使用方式：依赖注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>(<span class="hljs-params">IdGenerator idGenerator</span>)</span> &#123;<br>    <span class="hljs-built_in">long</span> id = idGenerator.getId();<br>&#125;<br><span class="hljs-comment">// 外部调用demofunction()的时候，传入idGenerator</span><br>IdGenerator idGenerator = IdGenerator.getInsance();<br>demofunction(idGenerator);<br></code></pre></td></tr></table></figure>

<p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传 递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其 他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。 </p>
<p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实 际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强 制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程 序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。 </p>
<p>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面的章节中讲解。</p>
<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>1.单例存在哪些问题？</p>
<p>单例对 OOP 特性的支持不友好</p>
<p>单例会隐藏类之间的依赖关系</p>
<p>单例对代码的扩展性不友好</p>
<p>单例对代码的可测试性不友好</p>
<p>单例不支持有参数的构造函数</p>
<p>2.单例有什么替代解决方案？</p>
<p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p>
<p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<h2 id="单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？"><a href="#单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？" class="headerlink" title="单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？"></a>单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？</h2><h3 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h3><h3 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h3><h3 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h3><h3 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h3><h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>今天的内容比较偏理论，在实际的项目开发中，没有太多的应用。讲解的目的，主要还是拓展你的思路，锻炼你的逻辑思维能力，加深你对单例的认识。</p>
<p>1.如何理解单例模式的唯一性？</p>
<p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<p>2.如何实现线程唯一的单例？</p>
<p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<p>3.如何实现集群环境下的单例？</p>
<p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p>4.如何实现一个多例模式？</p>
<p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p>
<h1 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h2><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过， 在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以 工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所 以，在今天的讲解中，我们沿用第一种分类方法。</p>
<h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。 </p>
<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath)<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>		<span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。</p>
<p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfig<br>        <span class="hljs-title function_">if</span> <span class="hljs-params">(parser == <span class="hljs-literal">null</span>)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时 候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>        &#125;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解 中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作 简单工厂模式的第二种实现方法。 </p>
<h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按 照多态的实现思路，对上面的代码进行重构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFact</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需 要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模 式比起简单工厂模式更加符合开闭原则。</p>
<p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong> </p>
<p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻 辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不 复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。 </p>
<p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。</p>
<p>抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。 </p>
<p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析 器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方 式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br>针对系统配置的解析器：基于接口I<span class="hljs-params">System</span>ConfigParser<br>Json<span class="hljs-params">System</span>ConfigParser<br>Xml<span class="hljs-params">System</span>ConfigParser<br>Yaml<span class="hljs-params">System</span>ConfigParser<br>Properties<span class="hljs-params">System</span>ConfigParser<br></code></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编 写一个工厂类，也就是要编写 8 个工厂类。</p>
<p>如果我们未来还需要增加针对业务配置的解析 器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。</p>
<p>而我们知道，过多的类 也会让系统难维护。这个问题该怎么解决呢？ </p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类 型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>();<br>    <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>();<br><span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景 进行总结。 </p>
<p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>
<p>何为创建逻辑比较复杂呢？我总结了下面两种情况。 </p>
<ul>
<li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。 </p>
</li>
<li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中</p>
</li>
</ul>
<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p>
<p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。 </p>
<p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不 要使用工厂模式的最本质的参考标准。 </p>
<ul>
<li><p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。 </p>
</li>
<li><p>代码复用：创建代码抽离到独立的工厂类之后可以复用。 </p>
</li>
<li><p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 </p>
</li>
<li><p>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</p>
</li>
</ul>
<h2 id="工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>工厂模式（下）：如何设计实现一个Dependency Injection框架？</h2><h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获 取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周 期管理。 </p>
<blockquote>
<p>首先，我们来看配置解析。 </p>
</blockquote>
<p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类 代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事 先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。</p>
<p>所 以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲 的配置。 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提 供的信息来创建对象</p>
<p>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创 建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依 赖 redisCounter。</p>
<blockquote>
<p>其次，我们再来看对象创建。 </p>
</blockquote>
<p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加， 这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。</p>
<p>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码 量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我 们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事 先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。 </p>
<p>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加 载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对 象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。 但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运 行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自 动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</p>
<blockquote>
<p>最后，我们来看对象的生命周期管理。 </p>
</blockquote>
<p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一 种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。</p>
<p>在 Spring 框架中，我 们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返 回新创建的对象，scope=singleton 表示返回单例对象。 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用 到的时候（比如:BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。 </p>
<p>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对 象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之 前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数 据库连接池、关闭文件。</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。但是，大 部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当 然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂 的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直 接影响到我们排查问题的效率。 </p>
<p>今天，我们讲解了一个简单的 DI 容器的实现原理，其核心逻辑主要包括：配置文件解析， 以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在 学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程 序员聚焦在业务代码的开发上。</p>
<h1 id="建造者模式-1"><a href="#建造者模式-1" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。 </p>
<p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。</p>
<p>比如，你有没有考虑过这样几个问题：</p>
<p>直接使用构造函数或者配合 set 方法就能创建对象，为 什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>
<h3 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h3><p>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？ 你可以先思考一下，下面我通过一个例子来带你看一下。 </p>
<p>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155842.png" alt="image-20220110155833218"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Int</span><br><span class="hljs-params">   </span><br><span class="hljs-params">    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数， 参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变 差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非 常隐蔽的 bug。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以 我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填 写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选 配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下 面这三个问题，那现在的设计思路就不能满足了。</p>
<ul>
<li><p>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时 候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构 造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
</li>
<li><p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
</li>
<li><p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之 后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
</li>
</ul>
<p>为了解决这些问题，建造者模式就派上用场了。 </p>
<h3 id="如何使用建造者模式"><a href="#如何使用建造者模式" class="headerlink" title="如何使用建造者模式"></a>如何使用建造者模式</h3><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。 这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且， ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = builder.name;<br>        <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>        <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>        <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>    &#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br><br>    <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>	<span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>        <br>        <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br>    <span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>            .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>            .setMaxTotal(<span class="hljs-number">16</span>)<br>            .setMaxIdle(<span class="hljs-number">10</span>)<br>            .setMinIdle(<span class="hljs-number">12</span>)<br>            .build();<br></code></pre></td></tr></table></figure>

<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。 比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会 导致在第一个 set 之后，对象处于无效状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure>

<p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。 如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一 次性地创建对象，让对象一直处于有效状态。 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变 的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的 成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复 的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</p>
<h3 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h3><p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节 课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？ </p>
<p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子 类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对 象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别。 </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道 的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才 能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用</p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的 问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属 性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p>除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来 创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定 创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可 选参数，“定制化”地创建不同的对象。</p>
<h1 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式：如何最快速地clone一个HashMap散列表？"><a href="#原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="原型模式：如何最快速地clone一个HashMap散列表？"></a>原型模式：如何最快速地clone一个HashMap散列表？</h2><p>JavaScript 是一种基于原型的面 向对象编程语言。即便 JavaScript 现在也引入了类的概念，但它也只是基于原型的语法糖 而已。</p>
<h3 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。 </p>
<p><strong>那何为“对象的创建成本比较大”？</strong> </p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。</p>
<p>应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。 </p>
<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。</p>
<p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong> </p>
<p>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜 索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用 于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建 立一个散列表索引。</p>
<p>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中， HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。</p>
<p>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量 地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删 除关键词的行为。</p>
<p>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定 期根据数据库中的数据，更新内存中的索引和数据。</p>
<p>我们该如何实现这个需求呢？ </p>
<p>实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta， 从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据 的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们 就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散 列表中。</p>
<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版 本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更 新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。 </p>
<p>那我们该如何实现现在这个需求呢？ </p>
<p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中 的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建 另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版 本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<p>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数 据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为 了提高效率，<u>原型模式就派上用场了</u>。</p>
<p>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有 更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新 的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<p>里我们利用了 Java 中的 clone() 语法来复制一个对象</p>
<h3 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h3><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷 贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图 所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155940.png" alt="image-20220110153656490"></p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155942.png" alt="image-20220110153706912"></p>
<p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存 地址，不会递归地拷贝引用对象本身。</p>
<p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。 </p>
<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Deep copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>                    searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas<br>                    newKeywords.put(e.getKey(), newSearchWord);<br>        &#125;<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>                oldSearchWord.setCount(searchWord.getCount());<br>                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                newKeywords.put(searchWord.getKeyword(), searchWord);<br>            &#125;<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span>&#123;<br>        ByteArrayOutputStream bo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        ObjectOutputStream oo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>        oo.writeObject(object);<br>        ByteArrayInputStream bi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>        ObjectInputStream oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>        <br>        <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这 个应用场景，有没有更快、更省内存的实现方式呢？ </p>
<p>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象， 我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需 要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题 中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Shallow copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) cu<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                newKeywords.remove(searchWord.getKeyword());<br>            &#125;<br>            newKeywords.put(searchWord.getKeyword(), searchWord);<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>1.什么是原型模式？ </p>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模 式，简称原型模式。 </p>
<p>2.原型模式的两种实现方法</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。</p>
<p>浅拷贝只会复制对象中基本数据类型数据和引 用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到 的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空 间。 </p>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来 说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就 变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载 10 万条数据并 构建散列表索引，操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了 一点点的性能提升而使用浅拷贝。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2022/02/25/%E5%A4%A7%E5%8E%82%E5%AD%A6%E9%99%A2%EF%BC%9AJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105737.png" alt="image-20220104093439415"></p>
<h2 id="线程基础知识复习"><a href="#线程基础知识复习" class="headerlink" title="线程基础知识复习"></a>线程基础知识复习</h2><h3 id="多线程为什么那么重要"><a href="#多线程为什么那么重要" class="headerlink" title="多线程为什么那么重要"></a>多线程为什么那么重要</h3><p>硬件：摩尔定律失效</p>
<p>软件：异步回调的生产需求</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105738.png" alt="image-20211229093512959"></p>
<h3 id="start一个线程"><a href="#start一个线程" class="headerlink" title="start一个线程"></a>start一个线程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105739.png" alt="image-20211229094556843"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105740.png" alt="image-20211229094614030"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105741.png" alt="image-20211229094622829"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105742.png" alt="image-20211229094642045"></p>
<h3 id="Java多线程相关概念"><a href="#Java多线程相关概念" class="headerlink" title="Java多线程相关概念"></a>Java多线程相关概念</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105743.png" alt="image-20220110201647965"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112107.png" alt="image-20230226110138757"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112108.png" alt="image-20211229095753304"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112109.png" alt="image-20211229095944520"></p>
<h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><p>即便是写一个最简单的HelloWord程序，也会有两个线程：用户线程（main）和 守护线程（GC垃圾回收线程）</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105746.png" alt="image-20211229100546645"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105747.png" alt="image-20211229100603341"></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future和Callable接口"><a href="#Future和Callable接口" class="headerlink" title="Future和Callable接口"></a>Future和Callable接口</h3><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。 </p>
<p>Callable接口中定义了需要有返回的任务需要实现的方法。 比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105748.png" alt="image-20211229102351154"></p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105749.png" alt="image-20211229102512122"></p>
<p>规范：system.out.println(futureTask.get())；放在最后</p>
<p>只要出现get方法，不管是否计算完成都阻塞等待结果完成再运行后面的代码</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105750.png" alt="image-20211229102541675"></p>
<h3 id="对Future的改进"><a href="#对Future的改进" class="headerlink" title="对Future的改进"></a>对Future的改进</h3><p>CompletableFuture的优点：</p>
<p>异步任务结束时，会自动回调某个对象的方法;</p>
<p>异步任务出错时，会自动回调某个对象的方法;</p>
<p>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105751.png" alt="image-20211229104116312"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105752.png" alt="image-20211229104138986"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105753.png" alt="image-20211229104230101"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105754.png" alt="image-20211229105819346"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105755.png" alt="image-20211229105833161"></p>
<h3 id="set、get-的区别"><a href="#set、get-的区别" class="headerlink" title="set、get 的区别"></a>set、get 的区别</h3><p>set和get基本上没啥区别，join不抛出异常</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105756.png" alt="image-20211229132059728"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105757.png" alt="image-20211229140513788"></p>
<h3 id="案例：电商网站性价需求"><a href="#案例：电商网站性价需求" class="headerlink" title="案例：电商网站性价需求"></a>案例：电商网站性价需求</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105758.png" alt="image-20211229132526164"></p>
<p>记录一次你项目中的一次亮点：</p>
<p>我做过一个比价需求，这个需求是要求我们去爬别的网站的数据，针对于同一件物品，看看他们在不同的网站上售价分别是多少。爬虫的兄弟提供给了我一些JOSN格式的数据，我自己做了一个HashMap（或Redis的zest中），做完数据清洁，保证没有重复数据之后，大概是有一万条数据。</p>
<p>针对这一万条数据，最笨的方法是全文扫描，一个一个的过，但是这样虽然可以实现，但是比较慢</p>
<p>后面了解到JUC里面有个CompletableFuture，可以做异步多线程并发，而且不阻塞，用它之后，就可以把网站的性能从xxx秒优化到xxx秒，这就是我技术上一个比较值得骄傲的亮点。</p>
<p>而且CompletableFuture默认使用的 forkjoin 的线程池，我自己手写了线程池，ThreadPollExactor，具体的参数根据自己的系统来定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.juc;<br><br><span class="hljs-keyword">import</span> jdk.nashorn.internal.objects.annotations.Getter;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: GengKY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/12/29 13:29</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplateFutureNetMallDemo</span>&#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;NetMall&gt; list= Arrays.asList(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;JD&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;PDD&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;TaoBao&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;DangDang&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetMall</span>(<span class="hljs-string">&quot;TianMao&quot;</span>)<br>    );<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getPriceByStep</span><span class="hljs-params">(List&lt;NetMall&gt; list,String productName)</span>&#123;<br>        <span class="hljs-keyword">return</span> list.stream()<br>                .map(netMall -&gt; String.format(productName+<span class="hljs-string">&quot;in %s price is %.2f&quot;</span>,netMall.getMallName(),netMall.calPrice(productName)))<br>                .collect(Collectors.toList());<br>    &#125;<br><br><br>    <span class="hljs-comment">//List&lt;NetMall&gt; ----&gt;List&lt;completableFuture&lt;String&gt;&gt; ---&gt;List&lt;string&gt;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getPriceByASync</span><span class="hljs-params">(List&lt;NetMall&gt; list,String productName)</span>&#123;<br>        <span class="hljs-keyword">return</span> list.stream()<br>                .map(netMall -&gt; CompletableFuture.supplyAsync(<br>                        () -&gt; String.format(productName + <span class="hljs-string">&quot;in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calPrice(productName))))<br>                .collect(Collectors.toList())<br>                .stream().map(CompletableFuture::join)<br>                .collect(Collectors.toList());<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;1------------&quot;</span>);<br>        <span class="hljs-type">long</span> startTime=System.currentTimeMillis();<br>        List&lt;String&gt; list1 = getPriceByStep(list, <span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : list1) &#123;<br>            System.out.println(element);<br>        &#125;<br>        <span class="hljs-type">long</span> endTime=System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费时间: &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br><br><br>        System.out.println(<span class="hljs-string">&quot;2------------&quot;</span>);<br>        <span class="hljs-type">long</span> startTime2=System.currentTimeMillis();<br>        List&lt;String&gt; list2 = getPriceByASync(list, <span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String element : list2) &#123;<br>            System.out.println(element);<br>        &#125;<br>        <span class="hljs-type">long</span> endTime2=System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费时间: &quot;</span>+(endTime2-startTime2)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetMall</span> &#123;<br>    <span class="hljs-keyword">private</span> String mallName;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMallName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mallName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NetMall</span><span class="hljs-params">(String mallName)</span>&#123;<br>        <span class="hljs-built_in">this</span>.mallName=mallName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calPrice</span><span class="hljs-params">(String productName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ThreadLocalRandom.current().nextDouble()*<span class="hljs-number">2</span>+productName.charAt(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105759.png" alt="image-20211229140440119"></p>
<h2 id="CompletableFuture常用方法"><a href="#CompletableFuture常用方法" class="headerlink" title="CompletableFuture常用方法"></a>CompletableFuture常用方法</h2><h3 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105800.png" alt="image-20211229142938975"></p>
<h3 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105801.png" alt="image-20211229143847406"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105802.png" alt="image-20211229144356254"></p>
<h3 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105803.png" alt="image-20211229145139950"></p>
<h3 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105804.png" alt="image-20211229145624011"></p>
<h3 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105805.png" alt="image-20211229150116909"></p>
<h3 id="家庭作业"><a href="#家庭作业" class="headerlink" title="家庭作业"></a>家庭作业</h3><p>2个作业</p>
<p>1.CompletableFuture.supplyAsync0.thenCompose()</p>
<p>2.写在简历上。</p>
<p>thenCompose() 流水线</p>
<h2 id="Java中的”锁”事"><a href="#Java中的”锁”事" class="headerlink" title="Java中的”锁”事"></a>Java中的”锁”事</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105806.png" alt="image-20211229151505483"></p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105807.png" alt="image-20211229151449318"></p>
<h3 id="线程八锁-锁的是什么"><a href="#线程八锁-锁的是什么" class="headerlink" title="线程八锁/锁的是什么"></a>线程八锁/锁的是什么</h3><p>根据锁的范围划分：</p>
<p>无锁、有锁；</p>
<p>锁区块、锁方法体；</p>
<p>对象锁、类锁</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105808.png" alt="image-20211230092802062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105809.png" alt="image-20211230095354383"></p>
<p>8种锁的案例实际体现在3个地方：</p>
<p>作用于实例方法，当前实例加锁，进入向步代码前要获得当前实例的锁</p>
<p>作用于代码块，对括号里配置的对象加锁</p>
<p>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁</p>
<h3 id="从自己码角度分析sync"><a href="#从自己码角度分析sync" class="headerlink" title="从自己码角度分析sync"></a>从自己码角度分析sync</h3><h4 id="sync同步代码块"><a href="#sync同步代码块" class="headerlink" title="sync同步代码块"></a>sync同步代码块</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105810.png" alt="image-20211230101007213"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105811.png" alt="image-20211230101015239"></p>
<p><strong>锁同步代码块：对象锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    Object object=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (object)&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>锁同步代码块：类锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    Object object=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (object.getClass())&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，</p>
<p>其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="sync普通同步方法"><a href="#sync普通同步方法" class="headerlink" title="sync普通同步方法"></a>sync普通同步方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105812.png" alt="image-20211230101330077"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，</p>
<p>该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h4 id="sync锁静态同步方法"><a href="#sync锁静态同步方法" class="headerlink" title="sync锁静态同步方法"></a>sync锁静态同步方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105813.png" alt="image-20211230101355440"></p>
<h4 id="sync锁的是什么"><a href="#sync锁的是什么" class="headerlink" title="sync锁的是什么"></a>sync锁的是什么</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105814.png" alt="image-20211230103656628"></p>
<p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</p>
<p>这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。（把信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105815.png" alt="image-20211230103726913"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105816.png" alt="image-20211230103852991"></p>
<h4 id="MarkWord预热"><a href="#MarkWord预热" class="headerlink" title="MarkWord预热"></a>MarkWord预热</h4><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位，后续讲解锁升级时候我们再加深，目前为了承前启后的学习，对下图先混个眼熟即可，O(∩_∩)O</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105817.png" alt="image-20211230104002030"></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105818.png" alt="image-20211230104418491"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>)<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖出第：\t&quot;</span>+(number--)+<span class="hljs-string">&quot;\t 还剩下:&quot;</span>+number);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaleTicketDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Ticket</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ticket</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">35</span>; i++)  ticket.sale(); &#125;,<span class="hljs-string">&quot;c&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105819.png" alt="image-20211230104902630"></p>
<blockquote>
<p>为什么会有公平锁/非公平锁的设计？为什么默认非公平?</p>
</blockquote>
<p>1、恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</p>
<p>2、使用多线程很重要的考量点是线程切换的开销，<code>当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</code></p>
<blockquote>
<p>使用公平锁会有什么问题？</p>
</blockquote>
<p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，</p>
<p>这就是传说中的 “锁饥饿”</p>
<blockquote>
<p>什么时候用公平？什么时候用非公平？</p>
</blockquote>
<p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</p>
<p>否则那就用公平锁，大家公平使用。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105820.png" alt="image-20211230105307326"></p>
<h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105821.png" alt="image-20211230105621559"></p>
<blockquote>
<p>说明：</p>
</blockquote>
<p>可重入锁又名递归锁</p>
<p>是指在<code>同一个线程在外层方法获取锁的时候</code>，<code>再进入该线程的内层方法</code>会<code>自动获取锁(前提，锁对象得是同一个对象)</code>，不会因为之前已经获取过还没释放而阻塞。</p>
<p>如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了<code>作茧自缚</code>。</p>
<p>所以Java中<code>ReentrantLock和synchronized都是可重入锁</code>，可重入锁的一个优点是<code>可一定程度避免死锁</code>。</p>
<h4 id="隐式的可重入锁"><a href="#隐式的可重入锁" class="headerlink" title="隐式的可重入锁"></a>隐式的可重入锁</h4><p>指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p>
<p>与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</p>
<p><strong>同步块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                System.out.println(<span class="hljs-string">&quot;-----外层调用&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;-----中层调用&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;-----内层调用&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m1&quot;</span>);<br>        m2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m2&quot;</span>);<br>        m3();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----m3&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">ReEntryLockDemo</span> <span class="hljs-variable">reEntryLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReEntryLockDemo</span>();<br>        reEntryLockDemo.m1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><p><code>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</code></p>
<p>当执行monitorenter时，如果<code>目标锁对象的计数器为零</code>，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器<code>不为零</code>的情况下，如果锁对象的<code>持有线程是当前线程</code>，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当<code>执行monitorexit时</code>，Java虚拟机则需将锁对象的<code>计数器减1</code>。计数器为零代表锁已被释放。</p>
<h4 id="显式的可重入锁"><a href="#显式的可重入锁" class="headerlink" title="显式的可重入锁"></a>显式的可重入锁</h4><p>加锁、解锁次数不一样的话，自己玩没事</p>
<p>多个线程一起的话，会卡住别人的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<span class="hljs-comment">//1、第一次lock</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;----外层调用lock&quot;</span>);<br>                lock.lock();<span class="hljs-comment">//2、第二次lock</span><br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;----内层调用lock&quot;</span>);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//lock.unlock(); // 正常情况，加锁几次就要解锁几次</span><br>                    <span class="hljs-comment">//正常运行，不会卡住</span><br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<span class="hljs-comment">//1、第一次lock</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;----外层调用lock&quot;</span>);<br>                lock.lock();<span class="hljs-comment">//2、第二次lock</span><br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;----内层调用lock&quot;</span>);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 这里故意注释，实现加锁次数和释放次数不一样</span><br>                    <span class="hljs-comment">// 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</span><br>                    <span class="hljs-comment">//lock.unlock(); // 正常情况，加锁几次就要解锁几次</span><br>                    <span class="hljs-comment">//第二个线程会卡住</span><br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;b thread----外层调用lock&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105822.png" alt="image-20211230132114628"></p>
<p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105823.png" alt="image-20211230132142765" style="zoom:67%;" />

<blockquote>
<p>手写一个死锁案例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;自己持有A，希望获得B&quot;</span>);<br>                <span class="hljs-comment">//暂停几秒钟线程</span><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                <span class="hljs-keyword">synchronized</span> (objectLockB)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;A-------已经获得B&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLockB)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;自己持有B，希望获得A&quot;</span>);<br>                <span class="hljs-comment">//暂停几秒钟线程</span><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                <span class="hljs-keyword">synchronized</span> (objectLockA)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;B-------已经获得A&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>怎么证明是死锁</p>
</blockquote>
<p>使用 jconsole 命令调出控制台</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105824.png" alt="image-20211230132652869"></p>
<p>使用 <code>jps -l</code> <code>jstack 线程ID</code> </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105825.png" alt="image-20211230133025403"></p>
<h3 id="其他的一些锁"><a href="#其他的一些锁" class="headerlink" title="其他的一些锁"></a>其他的一些锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105826.png" alt="image-20211230132454587"></p>
<h2 id="线程中断机制"><a href="#线程中断机制" class="headerlink" title="线程中断机制"></a>线程中断机制</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105827.png" alt="image-20211013191213603"></p>
<h3 id="面试题反馈"><a href="#面试题反馈" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105828.png" alt="image-20211013191240788"></p>
<h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105829.png" alt="image-20211013191303026"></p>
<h3 id="中断的相关API的方法"><a href="#中断的相关API的方法" class="headerlink" title="中断的相关API的方法"></a>中断的相关API的方法</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105830.png" alt="image-20211013191332009"></p>
<h3 id="如何使用中断标志停止线程"><a href="#如何使用中断标志停止线程" class="headerlink" title="如何使用中断标志停止线程"></a>如何使用中断标志停止线程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105831.png" alt="image-20211013191407893"></p>
<h4 id="通过一个volatile变量实现"><a href="#通过一个volatile变量实现" class="headerlink" title="通过一个volatile变量实现"></a>通过一个volatile变量实现</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105832.png" alt="image-20211013191601256"></p>
<h4 id="通过AtomicBoolean"><a href="#通过AtomicBoolean" class="headerlink" title="通过AtomicBoolean"></a>通过AtomicBoolean</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105833.png" alt="image-20211013191614201"></p>
<h4 id="通过Thread类自带的中断api方法实现"><a href="#通过Thread类自带的中断api方法实现" class="headerlink" title="通过Thread类自带的中断api方法实现"></a>通过Thread类自带的中断api方法实现</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105834.png" alt="image-20211013191624282"></p>
<h3 id="interrupt源码分析"><a href="#interrupt源码分析" class="headerlink" title="interrupt源码分析"></a>interrupt源码分析</h3><p>如果一个<code>被阻塞的线程（wait()、join()、sleep()）</code>是 中断的话，将会<code>清除中断标志位（重新设置为false）</code>，并抛出<code> InterruptedException 异常</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105835.png" alt="image-20211013191700509"></p>
<h3 id="isInterrupted源码分析"><a href="#isInterrupted源码分析" class="headerlink" title="isInterrupted源码分析"></a>isInterrupted源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105836.png" alt="image-20211013192015150"></p>
<h3 id="Interrupt是否是立刻停止"><a href="#Interrupt是否是立刻停止" class="headerlink" title="Interrupt是否是立刻停止"></a>Interrupt是否是立刻停止</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105837.png" alt="image-20211013192148680"></p>
<blockquote>
<p> <strong>以下代码说明，当对一个线程调用Interrupt时，并不会立刻停止</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105838.png" alt="image-20211013192253768"></p>
<h3 id="后手案例"><a href="#后手案例" class="headerlink" title="后手案例"></a>后手案例</h3><h4 id="后手案例-1"><a href="#后手案例-1" class="headerlink" title="后手案例-1"></a>后手案例-1</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105839.png" alt="image-20211013192534951"></p>
<p>执行结果：</p>
<p>程序正常执行，在3秒内持续打印 hello interrupt ，3秒后，打印“***程序结束”</p>
<h4 id="后手案例-2"><a href="#后手案例-2" class="headerlink" title="后手案例-2"></a>后手案例-2</h4><p>相较于“后手案例-1”，在 while 循环内 执行休眠操作，并用 try-catch 捕获异常</p>
<p>猜测：打印六次 “hello interrupt”，打印 “***程序结束”</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105840.png" alt="image-20211013192818500"></p>
<p>运行结果：</p>
<p>报异常，程序无法停止</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105841.png" alt="image-20211013193025661"></p>
<p>出现问题的原因：</p>
<p>线程t1在休眠时，线程t2设置 t1.interrupt，导致报异常</p>
<p>报异常之后，interrupt 状态重新设置为 false ，无法停止</p>
<p>解决方案：</p>
<p>在 try-catch 中在设置一次 interrupt</p>
<h4 id="后手案例-3"><a href="#后手案例-3" class="headerlink" title="后手案例-3"></a>后手案例-3</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105842.png" alt="image-20211013193334717"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105843.png" alt="image-20211013193431140"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105844.png" alt="image-20211013193522118"></p>
<h3 id="静态方法-Thread-interrupted"><a href="#静态方法-Thread-interrupted" class="headerlink" title="静态方法 Thread.interrupted"></a>静态方法 Thread.interrupted</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105845.png" alt="image-20211013193627535"></p>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105846.png" alt="image-20211013193730285"></p>
<h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105847.png" alt="image-20211013193752806"></p>
<h3 id="Interrupted对比IsInterrupted"><a href="#Interrupted对比IsInterrupted" class="headerlink" title="Interrupted对比IsInterrupted"></a>Interrupted对比IsInterrupted</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105848.png" alt="image-20211013193928979"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105849.png" alt="image-20211013193839447"></p>
<h3 id="线程中断总结"><a href="#线程中断总结" class="headerlink" title="线程中断总结"></a>线程中断总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105850.png" alt="image-20211230133342947"></p>
<h2 id="加餐-要了解系统架构设计"><a href="#加餐-要了解系统架构设计" class="headerlink" title="加餐 | 要了解系统架构设计"></a>加餐 | 要了解系统架构设计</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105851.png" alt="image-20211230142150574"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105852.png" alt="image-20211230142304514"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105853.png" alt="image-20211230142208060"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105854.png" alt="image-20211230142350887"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105855.png" alt="image-20211230142425741"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105856.png" alt="image-20211230142443498"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105857.png" alt="image-20211230142508215"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105858.png" alt="image-20211230142536251"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105859.png" alt="image-20211230142733549"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105900.png" alt="image-20211230142947844"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105901.png" alt="image-20211230143055295"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105902.png" alt="image-20211230143257157"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105903.png" alt="image-20211230143309414"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112110.png" alt="image-20211230143323220"></p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h3 id="什么是LockSupport"><a href="#什么是LockSupport" class="headerlink" title="什么是LockSupport"></a>什么是LockSupport</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html">LockSupport Java doc</a></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105904.png" alt="image-20211230143545419"></p>
<p>LockSupport是<code>用来创建锁</code>和<code>其他同步类</code>的<code>基本线程阻塞原语</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105905.png" alt="img"></p>
<h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p><strong>一句话说明LockSupport：</strong></p>
<p><strong>LockSupport就是线程等待和唤醒机制(wait/notify)的加强改良版</strong></p>
<p>LockSupport中的 <code>park()</code>和 <code>unpark()</code>的作用分别是<code>阻塞线程</code>和<code>解除阻塞线程</code>。</p>
<p>总之，比wait/notify，await/signal更强。</p>
<p><strong>3种让线程等待和唤醒的方法</strong></p>
<ul>
<li><p>方式1：使用Object中的wait()方法让线程等待，使用object中的notify()方法唤醒线程</p>
</li>
<li><p>方式2：使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p>
</li>
<li><p>方式3：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</p>
</li>
</ul>
<h3 id="两个重要方法"><a href="#两个重要方法" class="headerlink" title="两个重要方法"></a>两个重要方法</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105906.png" alt="image-20211230144502241"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105907.png" alt="image-20211230144516060"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112111.png" alt="image-20211230144736533"></p>
<h2 id="线程等待唤醒机制"><a href="#线程等待唤醒机制" class="headerlink" title="线程等待唤醒机制"></a>线程等待唤醒机制</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105908.png" alt="image-20211230143644770"></p>
<h3 id="Wait和Notify限制"><a href="#Wait和Notify限制" class="headerlink" title="Wait和Notify限制"></a>Wait和Notify限制</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105909.png" alt="image-20211230144401777"></p>
<p>Object类中的wait和notify方法实现线程等待和唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br><br>	<span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				<span class="hljs-keyword">try</span> &#123;<br>					lock.wait();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br>		<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				lock.notify();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>wait和notify方法<code>必须要在同步块或者方法里面</code>且<code>成对出现使用</code>，否则会抛出java.lang.IllegalMonitorStateException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.notify();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Exception in thread &quot;Thread B&quot; java.lang.IllegalMonitorStateException<br>	at java.base/java.lang.Object.notify(Native Method)<br>	at com.example.demo07.main.WaitNotifyDemo.lambda<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.467ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 2354 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">main</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-61" x="878" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1408" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6E" x="1753" y="0"></use>
</g>
</svg>1(WaitNotifyDemo.java:19)<br>	at java.base/java.lang.Thread.run(Thread.java:829)<br>Thread A come in.<br>Thread A 换醒.<br>java.lang.IllegalMonitorStateException<br>	at java.base/java.lang.Object.wait(Native Method)<br>	at java.base/java.lang.Object.wait(Object.java:328)<br>	at com.example.demo07.main.WaitNotifyDemo.lambda<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.467ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 2354 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">main</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-61" x="878" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1408" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6E" x="1753" y="0"></use>
</g>
</svg>0(WaitNotifyDemo.java:11)<br>	at java.base/java.lang.Thread.run(Thread.java:829)<br></code></pre></td></tr></table></figure>



<p>调用顺序要<code>先wait后notify</code>才OK。</p>
<p>先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyDemo</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				<span class="hljs-keyword">try</span> &#123;<br>					lock.wait();<br>				&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>					e.printStackTrace();<br>				&#125;<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;, <span class="hljs-string">&quot;Thread A&quot;</span>).start();<br><br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">synchronized</span> (lock) &#123;<br>				lock.notify();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread B 通知.<br>Thread A come in.<br>.......无限等待......<br></code></pre></td></tr></table></figure>



<h3 id="Await和Signal限制"><a href="#Await和Signal限制" class="headerlink" title="Await和Signal限制"></a>Await和Signal限制</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105910.png" alt="image-20211230144419994"></p>
<p>Condition接口中的await后signal方法实现线程的等待和唤醒，与Object类中的wait和notify方法实现线程等待和唤醒类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionAwaitSignalDemo</span> &#123;		<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;	<br>		<span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>		<span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;	<br>			<span class="hljs-keyword">try</span> &#123;<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in.&quot;</span>);<br>				lock.lock();<br>				condition.await();				<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125; <span class="hljs-keyword">finally</span> &#123;<br>				lock.unlock();<br>			&#125;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 换醒.&quot;</span>);<br>		&#125;,<span class="hljs-string">&quot;Thread A&quot;</span>).start();<br>		<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				lock.lock();<br>				condition.signal();<br>				System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>			&#125;<span class="hljs-keyword">finally</span> &#123;<br>				lock.unlock();<br>			&#125;<br>		&#125;,<span class="hljs-string">&quot;Thread B&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread A come in.<br>Thread B 通知.<br>Thread A 换醒.<br></code></pre></td></tr></table></figure>

<p>await和signal方法<code>必须要在同步块或者方法里面</code>且成对出现使用，否则会抛出 java.lang.IllegalMonitorStateException。</p>
<p>调用顺序要<code>先await后signal</code>才OK。</p>
<h3 id="LockSupport方法介绍"><a href="#LockSupport方法介绍" class="headerlink" title="LockSupport方法介绍"></a>LockSupport方法介绍</h3><p>API中的LockSupport方法摘要</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105911.png" alt="img"></p>
<p><strong>传统的 synchronized 和 Lock 实现等待唤醒通知的约束</strong></p>
<ul>
<li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li>
<li>必须要先等待后唤醒，线程才能够被唤醒</li>
</ul>
<p>LockSupport类中的park等待和unpark唤醒</p>
<p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>
<p>This class associates, with each thread that uses it, a permit (in the sense of the <code>Semaphore</code> class). A call to <code>park</code> will return immediately if the permit is available, consuming it in the process; otherwise it <em>may</em> block. A call to <code>unpark</code> makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.) <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html">link</a></p>
<p><strong>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</strong></p>
<p>LockSupport类使用了一种名为<strong>Permit（许可）的概念</strong>来做到阻塞和唤醒线程的功能，每个线程都有一个许可（permit），permit只有两个值1和零，默认是零。</p>
<p>可以把许可看成是一种(0.1)信号量（Semaphore），但与Semaphore不同的是，<strong>许可的累加上限是1。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105912.png" alt="image-20211230145212290"></p>
<p><strong>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</strong></p>
<p>park()/park(Object blocker) - 阻塞当前线程阻塞传入的具体线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>



<p>permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为0并返回。</p>
<p>unpark(Thread thread) - 唤醒处于阻塞状态的指定线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1（注意多次调用unpark方法，不会累加，pemit值还是1）会自动唤醒thead线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p>
<h3 id="LockSupport案例解析"><a href="#LockSupport案例解析" class="headerlink" title="LockSupport案例解析"></a>LockSupport案例解析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105913.png" alt="img"></p>
<blockquote>
<p><strong>正常使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">Thread A come in.<br>Thread B 通知.<br>Thread A 换醒.<br></code></pre></td></tr></table></figure>

<p>正常 + 无锁块要求。</p>
<p>先前错误的先唤醒后等待顺序，LockSupport可无视这顺序。</p>
<blockquote>
<p>【支持】先执行释放锁的操作unpark，后加锁</p>
</blockquote>
<p><strong>为什么可以先唤醒线程后阻塞线程？</strong></p>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【支持】unpack多次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            LockSupport.unpark(a);<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【不支持】pack多次，导致无限等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 换醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(a);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>【支持】多个通行证，由不同的线程提供</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.juc;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//park多次</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; come in. &quot;</span> + System.currentTimeMillis());<br>            LockSupport.park();<br>            LockSupport.park();<br>            LockSupport.park();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 唤醒. &quot;</span> + System.currentTimeMillis());<br>        &#125;, <span class="hljs-string">&quot;Thread A&quot;</span>);<br>        thread1.start();<br><br>        <span class="hljs-comment">//线程B unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread B&quot;</span>).start();<br><br>        <span class="hljs-comment">//线程C unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread C&quot;</span>).start();<br><br>        <span class="hljs-comment">//线程D unpark一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            LockSupport.unpark(thread1);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 通知.&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p><strong>重点说明</strong></p>
</blockquote>
<p>LockSupport是用来创建锁和共他同步类的基本线程阻塞原语。</p>
<p>LockSuport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻寨之后也有对应的唤醒方法。归根结底，LockSupport调用的Unsafe中的native代码。</p>
<p><strong>LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</strong></p>
<p>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0，</p>
<p>调用一次unpark就加1变成1，</p>
<p>调用一次park会消费permit，也就是将1变成0，同时park立即返回。</p>
<p>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，<strong>重复调用unpark也不会积累凭证</strong>。</p>
<blockquote>
<p><strong>形象的理解</strong></p>
</blockquote>
<p>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</p>
<p>当调用park方法时</p>
<ul>
<li>如果有凭证，则会直接消耗掉这个凭证然后正常退出。</li>
<li>如果无凭证，就必须阻塞等待凭证可用。</li>
</ul>
<p>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无放。</p>
<blockquote>
<p><strong>面试题</strong></p>
</blockquote>
<p><strong>1、为什么可以先唤醒线程后阻塞线程？</strong></p>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p>
<p><strong>2、为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></p>
<p>因为凭证的数量最多为1（不能累加），连续调用两次 unpark和调用一次 unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。</p>
<h2 id="Java内存模型值JMM"><a href="#Java内存模型值JMM" class="headerlink" title="Java内存模型值JMM"></a>Java内存模型值JMM</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105914.png" alt="image-20211013201143830"></p>
<h3 id="面试题反馈-1"><a href="#面试题反馈-1" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105915.png" alt="image-20211013201216815"></p>
<h3 id="计算机硬件体系结构"><a href="#计算机硬件体系结构" class="headerlink" title="计算机硬件体系结构"></a>计算机硬件体系结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105916.png" alt="image-20211013201253977"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105917.png" alt="image-20211013201336229"></p>
<h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105918.png" alt="image-20211013201355896"></p>
<h3 id="JVM规范下三大特性"><a href="#JVM规范下三大特性" class="headerlink" title="JVM规范下三大特性"></a>JVM规范下三大特性</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105919.png" alt="image-20211013201444642"></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105920.png" alt="image-20211013201509370"></p>
<h3 id="多线程遍历的读取过程"><a href="#多线程遍历的读取过程" class="headerlink" title="多线程遍历的读取过程"></a>多线程遍历的读取过程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226105921.png" alt="image-20211013201630782"></p>
<h4 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112112.png" alt="image-20211013201716933"></p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>我们定义的所有共享变量都储存在<strong>物理主内存</strong>中</p>
<p>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)</p>
<p>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)</p>
<p>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</p>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112113.png" alt="image-20211014091919624"></p>
<h3 id="x、y案例说明"><a href="#x、y案例说明" class="headerlink" title="x、y案例说明"></a>x、y案例说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112114.png" alt="image-20211014091939167"></p>
<h3 id="先行发生原则说明"><a href="#先行发生原则说明" class="headerlink" title="先行发生原则说明"></a>先行发生原则说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112115.png" alt="image-20211014092045774"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112116.png" alt="image-20211014092014938"></p>
<h3 id="happens-before八条规则"><a href="#happens-before八条规则" class="headerlink" title="happens-before八条规则"></a>happens-before八条规则</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112117.png" alt="image-20211014092112713"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112118.png" alt="image-20211014092138339"></p>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112119.png" alt="image-20211014092202674"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112120.png" alt="image-20211014092213335"></p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112121.png" alt="image-20211014100358040"></p>
<h3 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112122.png" alt="image-20211014100434379"></p>
<h3 id="什么是内存屏障"><a href="#什么是内存屏障" class="headerlink" title="什么是内存屏障"></a>什么是内存屏障</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112123.png" alt="image-20211014100538275"></p>
<p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是<code>一类同步屏障指令</code>，是CPU或编译器在<code>对内存随机访问的操作中</code>的一个同步点，使得<code>此点之前的所有读写操作</code>都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会<code>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</code>，通过这些内存屏障指令，volatle实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p>
<p>内存屏障之前的所有<code>写操作都要回写到主内存</code>，</p>
<p>内存屏障之后的所有<code>读操作</code>都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112124.png" alt="image-20211014100605653"></p>
<h3 id="四类内存屏障源码分析"><a href="#四类内存屏障源码分析" class="headerlink" title="四类内存屏障源码分析"></a>四类内存屏障源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112125.png" alt="image-20211014100713279"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112126.png" alt="image-20211014100749867"></p>
<h3 id="四大屏障分别是什么意思"><a href="#四大屏障分别是什么意思" class="headerlink" title="四大屏障分别是什么意思"></a>四大屏障分别是什么意思</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112127.png" alt="image-20211014100842497"></p>
<h3 id="内存屏障插入策略"><a href="#内存屏障插入策略" class="headerlink" title="内存屏障插入策略"></a>内存屏障插入策略</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112128.png" alt="image-20211014103438016"></p>
<h4 id="happens-before之volatile变量规则"><a href="#happens-before之volatile变量规则" class="headerlink" title="happens-before之volatile变量规则"></a>happens-before之volatile变量规则</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112129.png" alt="image-20211014103546032"></p>
<h4 id="写总结"><a href="#写总结" class="headerlink" title="写总结"></a>写总结</h4><p>1、在每个volatile 写操作的前面插入一个StoreStore屏障</p>
<p>2、在每个volatile 写操作的后面插入一个StoreLoad屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112130.png" alt="image-20211014103911526"></p>
<h4 id="读总结"><a href="#读总结" class="headerlink" title="读总结"></a>读总结</h4><p>3、在每个volatile读操作的后面插入一个LoadLoad屏障</p>
<p>4、在每个volatile读操作的后面插入一个LoadStore屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112131.png" alt="image-20211014104016981"></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><h4 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h4><p>不加volatile，没有可见性，程序无法停止</p>
<p>加了volatile，保证可见性，程序可以停止</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112132.png" alt="image-20211014113253889"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112133.png" alt="image-20211014113323752"></p>
<h4 id="volatile变量的读写过程"><a href="#volatile变量的读写过程" class="headerlink" title="volatile变量的读写过程"></a>volatile变量的读写过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112134.png" alt="image-20211014113351616"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112135.png" alt="image-20211227140218862"></p>
<ul>
<li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li>
<li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li>
<li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li>
<li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li>
<li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li>
<li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
<li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
</ul>
<h3 id="没有原子性"><a href="#没有原子性" class="headerlink" title="没有原子性"></a>没有原子性</h3><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><p>输出结果：基本都会小于10000，有可能会出现一次10000</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112136.png" alt="image-20211014113441542"></p>
<h4 id="字节码角度说明"><a href="#字节码角度说明" class="headerlink" title="字节码角度说明"></a>字节码角度说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112137.png" alt="image-20211014113542084"></p>
<h4 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112138.png" alt="image-20211014113625778"></p>
<h4 id="读取一个普通变量的情况"><a href="#读取一个普通变量的情况" class="headerlink" title="读取一个普通变量的情况"></a>读取一个普通变量的情况</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112139.png" alt="image-20211014113645474"></p>
<h4 id="volatile对指令的处理"><a href="#volatile对指令的处理" class="headerlink" title="volatile对指令的处理"></a>volatile对指令的处理</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112140.png" alt="image-20211014113730998"></p>
<h4 id="读取赋值一个volatile变量的情况"><a href="#读取赋值一个volatile变量的情况" class="headerlink" title="读取赋值一个volatile变量的情况"></a>读取赋值一个volatile变量的情况</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112141.png" alt="image-20211014113753742"></p>
<h4 id="间隙期不同非原子操作"><a href="#间隙期不同非原子操作" class="headerlink" title="间隙期不同非原子操作"></a>间隙期不同非原子操作</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112142.png" alt="image-20211014113836241"></p>
<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112143.png" alt="image-20211014115835644"></p>
<h4 id="说明与案例"><a href="#说明与案例" class="headerlink" title="说明与案例"></a>说明与案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112144.png" alt="image-20211014115920913"></p>
<h3 id="内存屏障二次复习"><a href="#内存屏障二次复习" class="headerlink" title="内存屏障二次复习"></a>内存屏障二次复习</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112145.png" alt="image-20211014120000331"></p>
<h4 id="volatile有关的禁止指令重排的行为"><a href="#volatile有关的禁止指令重排的行为" class="headerlink" title="volatile有关的禁止指令重排的行为"></a>volatile有关的禁止指令重排的行为</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112146.png" alt="image-20211014120341715"></p>
<h4 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112147.png" alt="image-20211014120008815"></p>
<h2 id="正确使用volatile"><a href="#正确使用volatile" class="headerlink" title="正确使用volatile"></a>正确使用volatile</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112148.png" alt="image-20211014171532003"></p>
<h3 id="使用案例：状态标志"><a href="#使用案例：状态标志" class="headerlink" title="使用案例：状态标志"></a>使用案例：状态标志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112149.png" alt="image-20211014171643098"></p>
<h3 id="使用案例：读多写少"><a href="#使用案例：读多写少" class="headerlink" title="使用案例：读多写少"></a>使用案例：读多写少</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112150.png" alt="image-20211014171658438"></p>
<h3 id="使用案例：双端检索"><a href="#使用案例：双端检索" class="headerlink" title="使用案例：双端检索"></a>使用案例：双端检索</h3><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112151.png" alt="image-20211014171843474"></p>
<h4 id="单线程、多线程下看问题代码"><a href="#单线程、多线程下看问题代码" class="headerlink" title="单线程、多线程下看问题代码"></a>单线程、多线程下看问题代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112152.png" alt="image-20211014171811111"></p>
<h4 id="双端检索正确代码"><a href="#双端检索正确代码" class="headerlink" title="双端检索正确代码"></a>双端检索正确代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112153.png" alt="image-20211014171915535"></p>
<h4 id="静态内部类实现单例模式"><a href="#静态内部类实现单例模式" class="headerlink" title="静态内部类实现单例模式"></a>静态内部类实现单例模式</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112154.png" alt="image-20211014171936749"></p>
<h2 id="volatile总结"><a href="#volatile总结" class="headerlink" title="volatile总结"></a>volatile总结</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112155.png" alt="image-20211014172038912"></p>
<h3 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h3><p>内存屏障：</p>
<p>是一种 <code>屏障指令</code>，它使得 <code>CPU或编译器</code> 对 <code>屏障指令的前和后</code> 所发出的内存操作 <code>执行一个排序的约束</code>。也叫内存栅栏或栅栏指令</p>
<h3 id="内存屏障四大指令"><a href="#内存屏障四大指令" class="headerlink" title="内存屏障四大指令"></a>内存屏障四大指令</h3><p>在每一个volatile写操作前面插入一个StoreStore屏障</p>
<p>在每一个volatile写操作后面插入一个StoreLoad屏障</p>
<p>在每一个volatile读操作后面插入一个LoadLoad屏障</p>
<p>在每一个volatile读操作后面插入一个LoadStore屏障</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112156.png" alt="image-20211014172234151"></p>
<h3 id="volatile关键字系统底层"><a href="#volatile关键字系统底层" class="headerlink" title="volatile关键字系统底层"></a>volatile关键字系统底层</h3><p><strong>字节码层面</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112157.png" alt="image-20211014172438336"></p>
<p><strong>关键字</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112158.png" alt="image-20211014172448001"></p>
<h3 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112159.png" alt="image-20211014172519245"></p>
<h3 id="volatile禁重排"><a href="#volatile禁重排" class="headerlink" title="volatile禁重排"></a>volatile禁重排</h3><h4 id="写指令"><a href="#写指令" class="headerlink" title="写指令"></a>写指令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112200.png" alt="image-20211014172658140"></p>
<h4 id="读指令"><a href="#读指令" class="headerlink" title="读指令"></a>读指令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112201.png" alt="image-20211014172640353"></p>
<h3 id="对比Lock理解"><a href="#对比Lock理解" class="headerlink" title="对比Lock理解"></a>对比Lock理解</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112202.png" alt="image-20211014172721233"></p>
<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112203.png" alt="image-20211014172800415"></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112204.png" alt="image-20211015095341266"></p>
<h3 id="没有CSA之前"><a href="#没有CSA之前" class="headerlink" title="没有CSA之前"></a>没有CSA之前</h3><h4 id="多线程环境下保证线程安全"><a href="#多线程环境下保证线程安全" class="headerlink" title="多线程环境下保证线程安全"></a>多线程环境下保证线程安全</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112205.png" alt="image-20211015095423890"></p>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112206.png" alt="image-20211015095547076"></p>
<h4 id="说明和原理"><a href="#说明和原理" class="headerlink" title="说明和原理"></a>说明和原理</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112207.png" alt="image-20211015095531099"></p>
<h4 id="硬件级别的保证"><a href="#硬件级别的保证" class="headerlink" title="硬件级别的保证"></a>硬件级别的保证</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112208.png" alt="image-20211015095642550"></p>
<h4 id="CASDemo代码"><a href="#CASDemo代码" class="headerlink" title="CASDemo代码"></a>CASDemo代码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112209.png" alt="image-20211015095657387"></p>
<h4 id="compareAndSet源码"><a href="#compareAndSet源码" class="headerlink" title="compareAndSet源码"></a>compareAndSet源码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112210.png" alt="image-20211015095730933"></p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112211.png" alt="image-20211015103607277"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112212.png" alt="image-20211015103622849"></p>
<h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><h4 id="手写自旋锁-1"><a href="#手写自旋锁-1" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112213.png" alt="image-20211015103708544"></p>
<h4 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112214.png" alt="image-20211015103727183"></p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112215.png" alt="image-20211015103814690"></p>
<h4 id="CAS的缺点：CPU空转"><a href="#CAS的缺点：CPU空转" class="headerlink" title="CAS的缺点：CPU空转"></a>CAS的缺点：CPU空转</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112216.png" alt="image-20211015103851075"></p>
<h4 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112217.png" alt="image-20211015103919880"></p>
<h4 id="代码：存在ABA问题"><a href="#代码：存在ABA问题" class="headerlink" title="代码：存在ABA问题"></a>代码：存在ABA问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112218.png" alt="image-20211015103947131"></p>
<h4 id="代码：解决ABA问题"><a href="#代码：解决ABA问题" class="headerlink" title="代码：解决ABA问题"></a>代码：解决ABA问题</h4><p>带邮戳的原子引用：AtomicStampedReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">atomicStampedReference.compareAndSet(x,y,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>





<p>使用：</p>
<p><strong>Class AtomicstampedReference&lt;V&gt;</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112219.png" alt="image-20211015104032870"></p>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>红色和黑色的有什么区别？</p>
<p>为什么要用 LongAdder 替代 AtomicLong？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112220.png" alt="image-20211231093302659"></p>
<h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>countDownLatch 你用在哪里？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112221.png" alt="image-20211231093514011"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span>&#123;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPlusPlus</span><span class="hljs-params">()</span>&#123;<br>        atomicInteger.incrementAndGet();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <br>        <span class="hljs-type">MyNumber</span> <span class="hljs-variable">myNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyNumber</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">5000</span>; j++)&#123;<br>                        myNumber.addPlusPlus();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        countDownLatch.await();<span class="hljs-comment">//不加此行代码的话，由于main线程太快，main结束时，atomicInteger.incrementAndGet()还没算到 500000</span><br>        System.out.println(myNumber.getAtomicInteger().get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112222.png" alt="image-20211231094211978"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <br>        <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br>        <span class="hljs-comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span><br>        <span class="hljs-comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;atomicIntegerArray.length(); i++) &#123;<br>            System.out.println(atomicIntegerArray.get(i));<br>        &#125;<br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmpInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        tmpInt = atomicIntegerArray.getAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">1122</span>);<br>        System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">0</span>));<br>        atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        tmpInt = atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>        System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112223.png" alt="image-20211231094659460"></p>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    String userName;<br>    <span class="hljs-type">int</span>    age;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>,<span class="hljs-number">24</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">li4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;li4&quot;</span>,<span class="hljs-number">26</span>);<br><br>        AtomicReference&lt;User&gt; atomicReferenceUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>        atomicReferenceUser.set(z3);<br>        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());<br>        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>手写自旋锁</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.Interview.study.thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2018-12-28 17:57</span><br><span class="hljs-comment"> * 题目：实现一个自旋锁</span><br><span class="hljs-comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span><br><span class="hljs-comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span>&#123;<br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myLock</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t come in&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-literal">null</span>,thread))&#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myUnLock</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread,<span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t myUnLock over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            <span class="hljs-comment">//暂停一会儿线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">5</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">1</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><blockquote>
<p>解决ABA问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicStampedReference</span> <span class="hljs-variable">atomicStampedReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        abaProblem();<br>        abaResolve();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaResolve</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第1次stamp  &quot;</span>+stamp);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,stamp,stamp+<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第2次stamp  &quot;</span>+atomicStampedReference.getStamp());<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;t3 ----第3次stamp  &quot;</span>+atomicStampedReference.getStamp());<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;t4 ----第1次stamp  &quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">20210308</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+result+<span class="hljs-string">&quot;\t&quot;</span>+atomicStampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaProblem</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">20210308</span>);<br>            System.out.println(atomicInteger.get());<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><blockquote>
<p>不建议用来解决ABA问题</p>
<p>用来解决一次性问题，不适合重复使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.juc.senior.inner.atomic;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-23 10:56</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;update ok&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">2020</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(atomicInteger.get());<br><br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br><br>        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决,让我们知道引用变量中途被更改了几次=========================&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+stampedReference.getStamp());<br>            <span class="hljs-comment">//故意暂停200毫秒，让后面的t4线程拿到和t3一样的版本号</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>            stampedReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 2次版本号&quot;</span>+stampedReference.getStamp());<br>            stampedReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 3次版本号&quot;</span>+stampedReference.getStamp());<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t =======1次版本号&quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停2秒钟,让t3先完成ABA操作了，看看自己还能否修改</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2020</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t=======2次版本号&quot;</span>+stampedReference.getStamp()+<span class="hljs-string">&quot;\t&quot;</span>+stampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start();<br><br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br><br>        System.out.println(<span class="hljs-string">&quot;============AtomicMarkableReference不关心引用变量更改过几次，只关心是否更改过======================&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+marked);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,marked,!marked);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 2次版本号&quot;</span>+markableReference.isMarked());<br>            markableReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,markableReference.isMarked(),!markableReference.isMarked());<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 3次版本号&quot;</span>+markableReference.isMarked());<br>        &#125;,<span class="hljs-string">&quot;t5&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 1次版本号&quot;</span>+marked);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">2020</span>,marked,!marked);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+markableReference.getReference()+<span class="hljs-string">&quot;\t&quot;</span>+markableReference.isMarked());<br>        &#125;,<span class="hljs-string">&quot;t6&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象的属性修改原子类"><a href="#对象的属性修改原子类" class="headerlink" title="对象的属性修改原子类"></a>对象的属性修改原子类</h3><p><font color=red><strong>以一种线程安全的方式操作非线程安全对象内的某些字段</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112224.png" alt="image-20211231100712901"></p>
<blockquote>
<p><strong>AtomicIntegerFieldUpdater</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bankName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CCB&quot;</span>;<span class="hljs-comment">//银行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//钱数</span><br>    AtomicIntegerFieldUpdater&lt;BankAccount&gt; accountAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="hljs-string">&quot;money&quot;</span>);<br><br>    <span class="hljs-comment">//不加锁+性能高，局部微创</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferMoney</span><span class="hljs-params">(BankAccount bankAccount)</span>&#123;<br>        accountAtomicIntegerFieldUpdater.incrementAndGet(bankAccount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-07-14 18:06</span><br><span class="hljs-comment"> * 以一种线程安全的方式操作非线程安全对象的某些字段。</span><br><span class="hljs-comment"> * 需求：</span><br><span class="hljs-comment"> * 1000个人同时向一个账号转账一元钱，那么累计应该增加1000元，</span><br><span class="hljs-comment"> * 除了synchronized和CAS,还可以使用AtomicIntegerFieldUpdater来实现。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <br>        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                bankAccount.transferMoney(bankAccount);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">//暂停毫秒</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(bankAccount.money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>AtomicReferenceField</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVar</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; atomicReferenceFieldUpdater = 	AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="hljs-string">&quot;isInit&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(MyVar myVar)</span>&#123;<br>        <span class="hljs-keyword">if</span>(atomicReferenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---init.....&quot;</span>);<br>            <span class="hljs-comment">//暂停几秒钟线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---init.....over&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;------其它线程正在初始化&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-18 17:20</span><br><span class="hljs-comment"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">MyVar</span> <span class="hljs-variable">myVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVar</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myVar.init(myVar);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原子操作增强类原理深度解析"><a href="#原子操作增强类原理深度解析" class="headerlink" title="原子操作增强类原理深度解析"></a>原子操作增强类原理深度解析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112225.png" alt="image-20211231105318134"></p>
<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote>
<p><strong>阿里要命题目</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112226.png" alt="image-20211231105432864"></p>
<blockquote>
<p><strong>常用API</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112227.png" alt="image-20211231105955468"></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>LongAccumulator提供了自定义的函数操作</p>
</blockquote>
<p>long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAccumulatorDemo</span><br>&#123;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_LongAdder</span><span class="hljs-params">()</span><br>    &#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongBinaryOperator</span>()<br>    &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">applyAsLong</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> left - right;<br>        &#125;<br>    &#125;,<span class="hljs-number">777</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_LongAccumulator</span><span class="hljs-params">()</span><br>    &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">LongAccumulatorDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulatorDemo</span>();<br><br>        demo.add_LongAccumulator();<br>        demo.add_LongAccumulator();<br>        System.out.println(demo.longAccumulator.longValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>LongAdderAPIDemo</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">package</span> com.atguigu.juc.atomics;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAccumulator;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-19 15:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderAPIDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br><br>        longAdder.increment();<br>        longAdder.increment();<br>        longAdder.increment();<br><br>        System.out.println(longAdder.longValue());<br><br>        <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x,y) -&gt; x * y,<span class="hljs-number">2</span>);<br><br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">2</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">3</span>);<br><br>        System.out.println(longAccumulator.longValue());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p><strong>1、定义五个方法</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112228.png" alt="image-20211231110759464"></p>
<p><strong>2、定义测试方法</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112229.png" alt="image-20211231110930670"></p>
<p><strong>3、测试结果</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">D: \devsoft\Javaljdk<span class="hljs-number">1.8.0_111</span>\binljava.exe<br>----costTime: <span class="hljs-number">1555</span>毫秒    add_synchronized    <span class="hljs-number">50000000</span><br>---costTime:  <span class="hljs-number">1010</span> 毫秘   add_AtomicInteger   <span class="hljs-number">50000000</span><br>----costTime: <span class="hljs-number">1056</span> 毫秒   add_AtomicLong      <span class="hljs-number">50000000</span><br>----costTime: <span class="hljs-number">162</span>毫秒     add_LongAdder       <span class="hljs-number">50000006</span><br>----costTime: <span class="hljs-number">214</span> 毫秒    add_LongAccumulator <span class="hljs-number">50000000</span><br></code></pre></td></tr></table></figure>

<h3 id="LongAdder为什么快"><a href="#LongAdder为什么快" class="headerlink" title="LongAdder为什么快"></a>LongAdder为什么快</h3><h3 id="LongAdder源码分析"><a href="#LongAdder源码分析" class="headerlink" title="LongAdder源码分析"></a>LongAdder源码分析</h3><p><font color=red><strong>太难了，暂时未看，等待后期补充【2021-12-31】</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112230.png" alt="image-20211231111331263"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112231.png" alt="image-20211231111358350"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112232.png" alt="image-20211231111408168"></p>
<h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112233.png" alt="image-20211015095759133"></p>
<h3 id="什么是UnSafe类"><a href="#什么是UnSafe类" class="headerlink" title="什么是UnSafe类"></a>什么是UnSafe类</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112234.png" alt="image-20211015095842499"></p>
<h3 id="原子整形是否安全"><a href="#原子整形是否安全" class="headerlink" title="原子整形是否安全"></a>原子整形是否安全</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112235.png" alt="image-20211015095925331"></p>
<h3 id="getAndIncrement源码"><a href="#getAndIncrement源码" class="headerlink" title="getAndIncrement源码"></a>getAndIncrement源码</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112236.png" alt="image-20211015095952684"></p>
<h3 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112237.png" alt="image-20211015100105497"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112238.png" alt="image-20211015100114590"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112239.png" alt="image-20211015100122894"></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="Threadlocal简介"><a href="#Threadlocal简介" class="headerlink" title="Threadlocal简介"></a>Threadlocal简介</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112240.png" alt="image-20220104093557634"></p>
<h3 id="是什么-能干啥-API"><a href="#是什么-能干啥-API" class="headerlink" title="是什么/能干啥/API"></a>是什么/能干啥/API</h3><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法〉都有自己的、独立初始化的变量副本。</p>
<p>ThreadLocal实例通常是<code>类中的私有静态字段</code>，使用它的目的是希望<code>将状态（例如，用户ID或事务ID）与线程关联起来</code>。</p>
<p>实现<code>每一个线程都有自己专属的本地变量副本</code>(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，</p>
<p>主要解决了<code>让每个线程绑定自己的值</code>，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112241.png" alt="image-20211015114634074"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112242.png" alt="image-20211015114705321"></p>
<h3 id="案例：买房提成"><a href="#案例：买房提成" class="headerlink" title="案例：买房提成"></a>案例：买房提成</h3><h4 id="ThreadLocal初始化方法"><a href="#ThreadLocal初始化方法" class="headerlink" title="ThreadLocal初始化方法"></a>ThreadLocal初始化方法</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112243.png" alt="image-20211015114741295"></p>
<h4 id="买房提成案例"><a href="#买房提成案例" class="headerlink" title="买房提成案例"></a>买房提成案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112244.png" alt="image-20211015114755232"></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><strong>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，</strong></p>
<p><strong>如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。</strong></p>
<p>尽量在代理中使用try-finally块进行回收。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112245.png" alt="image-20211015114835559"></p>
<h3 id="从阿里ThreadLocal规范开始"><a href="#从阿里ThreadLocal规范开始" class="headerlink" title="从阿里ThreadLocal规范开始"></a>从阿里ThreadLocal规范开始</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112246.png" alt="image-20220104093715736"></p>
<h3 id="非线程安全的SimpleDateFormat"><a href="#非线程安全的SimpleDateFormat" class="headerlink" title="非线程安全的SimpleDateFormat"></a>非线程安全的SimpleDateFormat</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112247.png" alt="image-20211015121813651"></p>
<h4 id="错误的代码演示"><a href="#错误的代码演示" class="headerlink" title="错误的代码演示"></a>错误的代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112248.png" alt="image-20211015121840093"></p>
<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112249.png" alt="image-20211015121932062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112250.png" alt="image-20211015121920759"></p>
<h4 id="源码分析结论"><a href="#源码分析结论" class="headerlink" title="源码分析结论"></a>源码分析结论</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112251.png" alt="image-20211015122316518"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112252.png" alt="image-20211015122027813"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">30</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//每次用到的时候new</span><br>            System.out.println(sdf.parse(<span class="hljs-string">&quot;2020-11-11 11:11:11&quot;</span>));<br>            sdf = <span class="hljs-literal">null</span>;<span class="hljs-comment">//帮助GC回收</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;,String.valueOf(i)).start();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112253.png" alt="image-20211015122118700"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt;  sdf_threadLocal =<br>        ThreadLocal.withInitial(()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br></code></pre></td></tr></table></figure>



<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112254.png" alt="image-20211015122141371"></p>
<p><strong>次解决方案来自阿里推荐</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112255.png" alt="image-20211015122221608"></p>
<h4 id="其他方案："><a href="#其他方案：" class="headerlink" title="其他方案："></a>其他方案：</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112256.png" alt="image-20211015122348115"></p>
<p><strong>代码</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112257.png" alt="image-20211015122424957"></p>
<h4 id="DataUtils"><a href="#DataUtils" class="headerlink" title="DataUtils"></a>DataUtils</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.juc.senior.utils;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-03 10:14</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateUtils</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1   SimpleDateFormat如果多线程共用是线程不安全的类</span><br><span class="hljs-comment">    public static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static String format(Date date)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return SIMPLE_DATE_FORMAT.format(date);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static Date parse(String datetime) throws ParseException</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return SIMPLE_DATE_FORMAT.parse(datetime);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; SIMPLE_DATE_FORMAT_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().format(date);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String datetime)</span> <span class="hljs-keyword">throws</span> ParseException<br>    &#123;<br>        <span class="hljs-keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().parse(datetime);<br>    &#125;<br><br><br>    <span class="hljs-comment">//3 DateTimeFormatter 代替 SimpleDateFormat</span><br>    <span class="hljs-comment">/*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static String format(LocalDateTime localDateTime)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        return DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public static LocalDateTime parse(String dateString)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);</span><br><span class="hljs-comment">    &#125;*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="家庭作业-1"><a href="#家庭作业-1" class="headerlink" title="家庭作业"></a>家庭作业</h4><p>来自：阿里手册</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112258.png" alt="image-20220104100811176"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3 DateTimeFormatter 代替 SimpleDateFormat</span><br><span class="hljs-comment">/*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public static String format(LocalDateTime localDateTime)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    return DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public static LocalDateTime parse(String dateString)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure>

<h3 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112259.png" alt="image-20220104101005176"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112300.png" alt="image-20220104101300208"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112301.png" alt="image-20220104101333879"></p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><font color=red><strong>threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。</strong></font></p>
<p><font color=red><strong>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</strong></font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112302.png" alt="image-20220104101714282"></p>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112303.png" alt="image-20220104102637567"></p>
<blockquote>
<p>存在的问题：</p>
</blockquote>
<p><code>线程池环境下</code>，线程经常会被复用</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112304.png" alt="image-20220104102713615"></p>
<blockquote>
<p>什么是内存泄漏</p>
</blockquote>
<p>不再会被使用的对象或者变量占用的内存<code>不能被回收</code>，就是内存泄露。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112305.png" alt="image-20220104102918586"></p>
<blockquote>
<p>再看ThreadLocalMap</p>
</blockquote>
<p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)不过是经过了两层包装的ThreadLocal对象:</p>
<p>(1）第一层包装是<code>使用WeakReference&lt;ThreadLoca&lt;?&gt;&gt;</code> 将ThreadLocal对象<code>变成一个弱引用的对象;</code></p>
<p>(2）第二层包装是<code>定义了一个专门的类Entry</code>来<code>扩展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112306.png" alt="image-20220104132656644"></p>
<blockquote>
<p>整体架构</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112307.png" alt="image-20220104132844917"></p>
<h3 id="强软弱虚四大引用"><a href="#强软弱虚四大引用" class="headerlink" title="强软弱虚四大引用"></a>强软弱虚四大引用</h3><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是<code>出现了OOM也不会对该对象进行回收</code>，死都不收。</p>
<p>强引用是我们<code>最常见</code>的普通对象引用，<code>只要还有强引用指向一个对象</code>，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是<code>造成Java内存泄漏的主要原因之一</code>。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用<code>赋值为 null</code>，<br>一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>    myObject = <span class="hljs-literal">null</span>;<br>    System.gc();<br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p>
<p>对于只有软引用的对象来说，</p>
<p>当<code>系统内存充足</code>时它      不会     被回收，</p>
<p>当<code>系统内存不足</code>时它         会     被回收。</p>
<p>软引用通常用在<code>对内存敏感的程序</code>中，比如<code>高速缓存</code>就有用到软引用，内存够用的时候就保留，不够用就回收！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，</p>
<p>对于只有弱引用的对象来说，<code>只要垃圾回收机制一运行</code>，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span><br>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable<br>    &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        WeakReference&lt;MyObject&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>        System.out.println(<span class="hljs-string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">softReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112308.png" alt="image-20220104133420878"></p>
<hr>
<p>虚引用需要java.lang.ref.PhantomReference类来实现。</p>
<p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并<code>不会决定对象的生命周期</code>。<br>如果一个对象<code>仅持有虚引用</code>，那么它就<code>和没有任何引用一样，在任何时候都可能被垃圾回收器回收，</code><br>它<code>不能单独使用</code>也<code>不能通过它访问对象</code>，虚引用必须和<code>引用队列 (ReferenceQueue)</code>联合使用。</p>
<p>虚引用的主要作用是<code>跟踪对象被垃圾回收的状态</code>。 仅仅是提供了一种<code>确保对象被 finalize以后，做某些事情的机制</code>。 PhantomReference的<code>get方法总是返回null</code>，因此无法访问对应的引用对象。</p>
<p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>换句话说，设置虚引用关联的<code>唯一目的</code>，就是在这个<code>对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</code></p>
<p> <img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112309.png" alt="image-20220104133649886"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span><br>&#123;<br>    <span class="hljs-comment">//一般开发中不用调用这个方法，本次只是为了讲课演示</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable<br>    &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---finalize method invoked....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-03-24 10:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>        PhantomReference&lt;MyObject&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>(),referenceQueue);<br>        <span class="hljs-comment">//System.out.println(phantomReference.get());</span><br><br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">600</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                System.out.println(phantomReference.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyObject</span>&gt; reference = referenceQueue.poll();<br>                <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;***********有虚对象加入队列了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">weakReference</span><span class="hljs-params">()</span><br>    &#123;<br>        WeakReference&lt;MyObject&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>        System.out.println(<span class="hljs-string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">softReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span><br>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br><br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strongReference</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----gc before: &quot;</span>+myObject);<br><br>        myObject = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----gc after: &quot;</span>+myObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112310.png" alt="image-20220104133742871"></p>
<h3 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112311.png" alt="image-20220104134029494"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112312.png" alt="image-20220104133918513"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112313.png" alt="image-20220104133959157"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112314.png" alt="image-20220104134328338"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112315.png" alt="image-20220104134433258"></p>
<hr>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112316.png" alt="image-20220104134738063"></p>
<p>结论：</p>
<p>从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，</p>
<p>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。</p>
<h3 id="弱引用结论"><a href="#弱引用结论" class="headerlink" title="弱引用结论"></a>弱引用结论</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112317.png" alt="image-20220104134851393"></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112318.png" alt="image-20220104135035912"></p>
<h2 id="Java对象内存布局和对象头"><a href="#Java对象内存布局和对象头" class="headerlink" title="Java对象内存布局和对象头"></a>Java对象内存布局和对象头</h2><h3 id="面试题反馈-2"><a href="#面试题反馈-2" class="headerlink" title="面试题反馈"></a>面试题反馈</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112319.png" alt="image-20211012185412065"></p>
<p>Object object = new Object()</p>
<p>谈谈你对这句话的理解?一般而言JDK8按照默认情况下,new一个对象占多少内存空间</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，<code>对象在堆内存中的存储布局</code>可以划分为三个部分：</p>
<p><code>一个对象实例</code>：对象头（Header)、实例数据（ Instance Daa）和对齐填充（Padding） </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112320.png" alt="image-20211012185625269"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112321.png" alt="image-20211012193045120"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><font color=red><strong>对象头= 对象标记（MarkWord）+类元信息（类型指针）</strong></font></p>
<p>MarkWord被设计成一个非固定的数据结构</p>
<p>以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p>
<p>默认存储：对象的HashCode、分代年龄和锁标志位等信息。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112322.png" alt="image-20211227162705811"></p>
<h4 id="对象标记（MarkWord）"><a href="#对象标记（MarkWord）" class="headerlink" title="对象标记（MarkWord）"></a>对象标记（MarkWord）</h4><p>它保存什么？</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112323.png" alt="image-20211012193335272"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112324.png" alt="image-20211012193346287"></p>
<p>默认存储对象的HashCode、分代年龄和锁标志位等信息。</p>
<p>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构</p>
<p>以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p>
<h4 id="类元信息（类型指针）"><a href="#类元信息（类型指针）" class="headerlink" title="类元信息（类型指针）"></a>类元信息（类型指针）</h4><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>参考宋红康老师JVM课程中的原图</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112325.png" alt="image-20211012193439744"></p>
<h4 id="对象头多大"><a href="#对象头多大" class="headerlink" title="对象头多大"></a>对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p><strong>存放类的属性(Field)数据信息，包括父类的属性信息，</strong></p>
<p>如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112326.png" alt="image-20211012193707630"></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>&#123;<br>	<span class="hljs-built_in">int</span> i=<span class="hljs-number">5</span>;<br>	<span class="hljs-built_in">char</span> a=<span class="hljs-string">&#x27;a&#x27;</span>;<br>&#125;<br><br>MyObjec对象头 <span class="hljs-number">16</span>个字节：MarkWord <span class="hljs-number">8</span>个字节 + 类型指针 <span class="hljs-number">8</span>个字节<br><span class="hljs-built_in">int</span>类型：<span class="hljs-number">32</span>bit <span class="hljs-number">3</span>个字节<br><span class="hljs-built_in">char</span>类型：<span class="hljs-number">16</span>bit <span class="hljs-number">2</span>个字节<br>此时一共：<span class="hljs-number">16</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>=<span class="hljs-number">21</span>个字节<br>属性填充：<span class="hljs-number">3</span>个字节<br>一共：<span class="hljs-number">24</span>个字节<br></code></pre></td></tr></table></figure>

<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>虚拟机要求<strong>对象起始地址必须是8字节的整数倍</strong>。</p>
<p>填充数据<strong>不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐</strong>。</p>
<h2 id="对象头的MarkWord"><a href="#对象头的MarkWord" class="headerlink" title="对象头的MarkWord"></a>对象头的MarkWord</h2><h3 id="官网理论"><a href="#官网理论" class="headerlink" title="官网理论"></a>官网理论</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112327.png" alt="image-20211012194101288"></p>
<h3 id="再说对象头MarkWord"><a href="#再说对象头MarkWord" class="headerlink" title="再说对象头MarkWord"></a>再说对象头MarkWord</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112328.png" alt="image-20211012194133425"></p>
<h4 id="32位虚拟机"><a href="#32位虚拟机" class="headerlink" title="32位虚拟机"></a>32位虚拟机</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112329.png" alt="image-20211012194154484"></p>
<h4 id="64位虚拟机"><a href="#64位虚拟机" class="headerlink" title="64位虚拟机"></a>64位虚拟机</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112330.png" alt="image-20211012194209714"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112331.png" alt="image-20211012194238368"></p>
<h4 id="64位虚拟机源码"><a href="#64位虚拟机源码" class="headerlink" title="64位虚拟机源码"></a>64位虚拟机源码</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112332.png" alt="image-20211012194253289"></p>
<h2 id="对象布局说明和压缩指针"><a href="#对象布局说明和压缩指针" class="headerlink" title="对象布局说明和压缩指针"></a>对象布局说明和压缩指针</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112333.png" alt="image-20211012201849463"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112334.png" alt="image-20211012201921382"></p>
<h3 id="JOL使用案例"><a href="#JOL使用案例" class="headerlink" title="JOL使用案例"></a>JOL使用案例</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112335.png" alt="image-20211012202019923"></p>
<h4 id="new-Object代码说明"><a href="#new-Object代码说明" class="headerlink" title="new Object代码说明"></a>new Object代码说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112336.png" alt="image-20211012202129097"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112337.png" alt="image-20211012202207850"></p>
<h4 id="换个对象试试"><a href="#换个对象试试" class="headerlink" title="换个对象试试"></a>换个对象试试</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112338.png" alt="image-20211012202257998"></p>
<h4 id="修改GC年龄"><a href="#修改GC年龄" class="headerlink" title="修改GC年龄"></a>修改GC年龄</h4><p>GC年龄采用4位bit存储，最大值为15，使用参数修改大于15时，会报错，无法启动JVM</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112339.png" alt="image-20211012202402683"></p>
<h4 id="自动压缩"><a href="#自动压缩" class="headerlink" title="自动压缩"></a>自动压缩</h4><p>默认开启自动压缩</p>
<p>使用 打印JVM参数</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112340.png" alt="image-20211012202742428"></p>
<p>关闭自动压缩</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112341.png" alt="image-20211012202824337"></p>
<h2 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112342.png" alt="image-20211013094038359"></p>
<h3 id="面试题引入"><a href="#面试题引入" class="headerlink" title="面试题引入"></a>面试题引入</h3><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体;能用对象锁，就不要用类锁。</p>
<p>说明︰尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112343.png" alt="image-20211013094115206"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112344.png" alt="image-20211013094150776"></p>
<h3 id="Synchronized的性能变化"><a href="#Synchronized的性能变化" class="headerlink" title="Synchronized的性能变化"></a>Synchronized的性能变化</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112345.png" alt="image-20211013094246274"></p>
<h3 id="为什么每一个对象都可以成为一个锁"><a href="#为什么每一个对象都可以成为一个锁" class="headerlink" title="为什么每一个对象都可以成为一个锁"></a>为什么每一个对象都可以成为一个锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112346.png" alt="image-20211013094401059"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112347.png" alt="image-20211013094435413"></p>
<h3 id="Monitor（监视器锁）"><a href="#Monitor（监视器锁）" class="headerlink" title="Monitor（监视器锁）"></a>Monitor（监视器锁）</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112348.png" alt="image-20211013094447226"></p>
<h3 id="Synchronized锁优化背景"><a href="#Synchronized锁优化背景" class="headerlink" title="Synchronized锁优化背景"></a>Synchronized锁优化背景</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112349.png" alt="image-20211013094614743"></p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112350.png" alt="image-20211013094724969"></p>
<h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>==synchronized用的锁是存在Java对象头里的Mark Word中，锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位==</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112351.png" alt="image-20211013095018134"></p>
<h2 id="锁升级详解"><a href="#锁升级详解" class="headerlink" title="锁升级详解"></a>锁升级详解</h2><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><h4 id="无锁案例"><a href="#无锁案例" class="headerlink" title="无锁案例"></a>无锁案例</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112352.png" alt="image-20211013095230223"></p>
<h4 id="hashcode有调用才会存储"><a href="#hashcode有调用才会存储" class="headerlink" title="hashcode有调用才会存储"></a>hashcode有调用才会存储</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112353.png" alt="image-20211013095334614"></p>
<h4 id="16进制下的hashcode"><a href="#16进制下的hashcode" class="headerlink" title="16进制下的hashcode"></a>16进制下的hashcode</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112354.png" alt="image-20211013095405797"></p>
<h4 id="2进制下的hashcode"><a href="#2进制下的hashcode" class="headerlink" title="2进制下的hashcode"></a>2进制下的hashcode</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112355.png" alt="image-20211013095423101"></p>
<h4 id="总结：程序不会有锁的竞争"><a href="#总结：程序不会有锁的竞争" class="headerlink" title="总结：程序不会有锁的竞争"></a>总结：程序不会有锁的竞争</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112356.png" alt="image-20211013095533001"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>什么是偏向锁：</p>
<p><code>当一段同步代码一直被同一个线程多次访问</code>，由于只有一个线程那么该线程在后续访问时便会自动获得锁</p>
<p>为什么会有偏向锁：</p>
<p>Hotspot的作者经过研究发现，<code>大多数情况下：多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况</code>，偏向锁就是在这种情况下出现的，它的出现是<code>为了解决只有在一个线程执行同步时提高性能</code>。</p>
<p>过程说明：</p>
<p>那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。</p>
<p>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，<code>如果一致直接进入同步。</code>无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p>
<p>升级为轻量级锁：</p>
<p>假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。</p>
<p><code>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</code></p>
<p>偏向锁的撤销</p>
<p>竞争线程<code>尝试CAS更新对象头失败</code>，会等待到<code>全局安全点</code>（此时不会执行任何代码）撤销偏向锁。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112357.png" alt="image-20211013104052400"></p>
<h4 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112358.png" alt="image-20211013104113759"></p>
<h4 id="64位标记图再看"><a href="#64位标记图再看" class="headerlink" title="64位标记图再看"></a>64位标记图再看</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112359.png" alt="image-20211013140221900"></p>
<h4 id="偏向锁的持有说明"><a href="#偏向锁的持有说明" class="headerlink" title="偏向锁的持有说明"></a>偏向锁的持有说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112400.png" alt="image-20211013140310398"></p>
<h4 id="偏向锁的举例说明"><a href="#偏向锁的举例说明" class="headerlink" title="偏向锁的举例说明"></a>偏向锁的举例说明</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112401.png" alt="image-20211013140421616"></p>
<h4 id="偏向锁JVM命令"><a href="#偏向锁JVM命令" class="headerlink" title="偏向锁JVM命令"></a>偏向锁JVM命令</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112402.png" alt="image-20211013140505059"></p>
<h4 id="偏向锁代码演示【无效果】"><a href="#偏向锁代码演示【无效果】" class="headerlink" title="偏向锁代码演示【无效果】"></a>偏向锁代码演示【无效果】</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112403.png" alt="image-20211013140554657"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112404.png" alt="image-20211013140538655"></p>
<h4 id="偏向锁代码演示【有效果】"><a href="#偏向锁代码演示【有效果】" class="headerlink" title="偏向锁代码演示【有效果】"></a>偏向锁代码演示【有效果】</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112405.png" alt="image-20211013140708554"></p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112406.png" alt="image-20211013140739996"></p>
<h4 id="偏向锁获取撤销流程"><a href="#偏向锁获取撤销流程" class="headerlink" title="偏向锁获取撤销流程"></a>偏向锁获取撤销流程</h4><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112407.png" alt="image-20211013144527645" style="zoom:67%;" />

<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112408.png" alt="image-20211013144131221"></p>
<h4 id="64位标记图"><a href="#64位标记图" class="headerlink" title="64位标记图"></a>64位标记图</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112409.png" alt="image-20211013144212443"></p>
<h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112410.png" alt="image-20211013144238381"></p>
<h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112411.png" alt="image-20211013144306778"></p>
<h4 id="自旋到一定次数"><a href="#自旋到一定次数" class="headerlink" title="自旋到一定次数"></a>自旋到一定次数</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112412.png" alt="image-20211013144352678"></p>
<h4 id="轻量级锁与偏向锁的区别和不同"><a href="#轻量级锁与偏向锁的区别和不同" class="headerlink" title="轻量级锁与偏向锁的区别和不同"></a>轻量级锁与偏向锁的区别和不同</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112413.png" alt="image-20211013144409712"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112414.png" alt="image-20211013144613806"></p>
<h4 id="锁标志位"><a href="#锁标志位" class="headerlink" title="锁标志位"></a>锁标志位</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112415.png" alt="image-20211013144705260"></p>
<h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112416.png" alt="image-20211013144716981"></p>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112417.png" alt="image-20211013144738215"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112418.png" alt="image-20211013144754332"></p>
<h2 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112419.png" alt="image-20211013144839121"></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112420.png" alt="image-20211013144904203"></p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112421.png" alt="image-20211013144924541"></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><font color=red>AbstractQueuedSynchronizer</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112422.png" alt="image-20220105093806917"></p>
<blockquote>
<p><strong>通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</strong></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112423.png" alt="image-20220105093407830"></p>
<blockquote>
<p>AQS相关</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112424.png" alt="image-20220105093527767"></p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><blockquote>
<p>加锁会导致阻塞 =&gt; <code>有阻塞就需要排队，实现排队必然需要队列</code></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112425.png" alt="image-20220105094303829"></p>
<blockquote>
<p>能干嘛：解释说明</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112426.png" alt="image-20220105094524031"></p>
<blockquote>
<p><font color=red><strong>AQS内部体系结构</strong></font></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112427.png" alt="image-20220105095103564"></p>
<blockquote>
<p>官网解释</p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112428.png" alt="image-20220105094157634"></p>
<blockquote>
<p><font color=red><strong>AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</strong></font></p>
</blockquote>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112429.png" alt="image-20220105094050754"></p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112430.png" alt="image-20211013153241873"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112431.png" alt="image-20211013153358110"></p>
<h3 id="面试题引入-1"><a href="#面试题引入-1" class="headerlink" title="面试题引入"></a>面试题引入</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112432.png" alt="image-20211013153311204"></p>
<h3 id="锁得演变过程"><a href="#锁得演变过程" class="headerlink" title="锁得演变过程"></a>锁得演变过程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112433.png" alt="image-20211013153419241"></p>
<h3 id="什么是读写锁"><a href="#什么是读写锁" class="headerlink" title="什么是读写锁"></a>什么是读写锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112434.png" alt="image-20211013153459517"></p>
<h3 id="锁降级说明"><a href="#锁降级说明" class="headerlink" title="锁降级说明"></a>锁降级说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112435.png" alt="image-20211013153631694"></p>
<h3 id="读锁和写锁互斥"><a href="#读锁和写锁互斥" class="headerlink" title="读锁和写锁互斥"></a>读锁和写锁互斥</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112436.png" alt="image-20211013160126827"></p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112437.png" alt="image-20211013153603364"></p>
<h3 id="锁降级说明-1"><a href="#锁降级说明-1" class="headerlink" title="锁降级说明"></a>锁降级说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112438.png" alt="image-20211013153631694"></p>
<h3 id="Java8官网说明"><a href="#Java8官网说明" class="headerlink" title="Java8官网说明"></a>Java8官网说明</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112439.png" alt="image-20211013153729050"></p>
<h3 id="可以降级"><a href="#可以降级" class="headerlink" title="可以降级"></a>可以降级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112440.png" alt="image-20211013153717658"></p>
<h3 id="不可锁升级"><a href="#不可锁升级" class="headerlink" title="不可锁升级"></a>不可锁升级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112441.png" alt="image-20211013153825161"></p>
<h3 id="读写锁降级演示"><a href="#读写锁降级演示" class="headerlink" title="读写锁降级演示"></a>读写锁降级演示</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112442.png" alt="image-20211013153854646"></p>
<p><font color=red>锁可以降级，程序正常执行</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112443.png" alt="image-20211013153925882"></p>
<p><font color=red>程序不能正常执行，会卡住，写锁没有释放，无法获取读锁</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112444.png" alt="image-20211013154000848"></p>
<h3 id="持有写锁后获取读锁"><a href="#持有写锁后获取读锁" class="headerlink" title="持有写锁后获取读锁"></a>持有写锁后获取读锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112445.png" alt="image-20211013154746431"></p>
<h3 id="Oracle源码之锁降级"><a href="#Oracle源码之锁降级" class="headerlink" title="Oracle源码之锁降级"></a>Oracle源码之锁降级</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112446.png" alt="image-20211013160158063"></p>
<h2 id="StampedLock邮戳锁"><a href="#StampedLock邮戳锁" class="headerlink" title="StampedLock邮戳锁"></a>StampedLock邮戳锁</h2><h3 id="什么是StampedLock"><a href="#什么是StampedLock" class="headerlink" title="什么是StampedLock"></a>什么是StampedLock</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112447.png" alt="image-20211013165245758"></p>
<h3 id="什么是锁饥饿问题"><a href="#什么是锁饥饿问题" class="headerlink" title="什么是锁饥饿问题"></a>什么是锁饥饿问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112448.png" alt="image-20211013164511754"></p>
<h3 id="怎么缓解锁饥饿问题"><a href="#怎么缓解锁饥饿问题" class="headerlink" title="怎么缓解锁饥饿问题"></a>怎么缓解锁饥饿问题</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112449.png" alt="image-20211013164559573"></p>
<h3 id="StampedLock乐观读锁"><a href="#StampedLock乐观读锁" class="headerlink" title="StampedLock乐观读锁"></a>StampedLock乐观读锁</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112450.png" alt="image-20211013164654214"></p>
<h3 id="StampedLock的特点"><a href="#StampedLock的特点" class="headerlink" title="StampedLock的特点"></a>StampedLock的特点</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112451.png" alt="image-20211013164747555"></p>
<h3 id="StampedLock三种访问模式"><a href="#StampedLock三种访问模式" class="headerlink" title="StampedLock三种访问模式"></a>StampedLock三种访问模式</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112452.png" alt="image-20211013164836354"></p>
<h3 id="三种访问模式代码演示"><a href="#三种访问模式代码演示" class="headerlink" title="三种访问模式代码演示"></a>三种访问模式代码演示</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112453.png" alt="image-20211013164953897"></p>
<h3 id="StampedLock的缺点"><a href="#StampedLock的缺点" class="headerlink" title="StampedLock的缺点"></a>StampedLock的缺点</h3><p><font color=red>StampedLock可能会导致死锁，建议不要再工作中使用，仅为了应付面试</font></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112454.png" alt="image-20211013164856029"></p>
<h2 id="结课总结"><a href="#结课总结" class="headerlink" title="结课总结"></a>结课总结</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226112455.png" alt="image-20211013165313322"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式02-结构型模式</title>
    <url>/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="结构型模式-上篇"><a href="#结构型模式-上篇" class="headerlink" title="结构型模式 | 上篇"></a>结构型模式 | 上篇</h1><h2 id="结构型模式总览"><a href="#结构型模式总览" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些<strong>类或对象组合在一起</strong>的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>代理模式：新增代理类，控制访问原始类</p>
<p>桥接模式：接口和实现分离，组合优于继承</p>
<p>装饰器模式：不改变原始类，增强原始类</p>
<p>适配器模式：事后补救策略，不兼容的接口转为可兼容</p>
<hr>
<p>代理模式：不改变原始类和接口，为原理类定义代理类，控制访问</p>
<p>桥接模式：将接口和实现部分分离</p>
<p>装饰器模式：不改变原始类和接口，对原始类增强</p>
<p>适配器模式：事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。</p>
<p>我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>静态代理、动态代理（jdk动态代理、cglib动态代理）</p>
<p>Spring中的APO</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>理解一：将抽象和实现解耦，让它们可以独立变化</p>
<p>理解二：一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。类似于“组合优于继承”，通过组合关系来替代继承关系，避免继承层次的指数级爆炸</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时</li>
</ol>
<p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>JDBC数据库连接池：MySQL和Oracle的方便切换</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>不改变原始类和接口，对原始类增强</p>
<p><strong>Q：装饰器模式就是简单的“用组合替代继承”吗？</strong></p>
<p>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。** </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>

<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类<strong>无关的功能</strong>，而在装饰器模式中，装饰器类附加的是跟原始类<strong>相关的增强功 能</strong>。</u></p>
<blockquote>
<p>业务场景</p>
</blockquote>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的IO流</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p><strong>Q：适配器模式有两种实现方式：类适配器和对象适配器。</strong></p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>接口不兼容的场景</p>
<p><strong>Q：那在实际的开发中，什么情况下才会出现接口不兼容呢？</strong></p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的日志框架：Slf4j</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h1 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>它在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<h3 id="代理模式的原理解析"><a href="#代理模式的原理解析" class="headerlink" title="代理模式的原理解析"></a>代理模式的原理解析</h3><p>性能计数器。当时我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略login逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略register逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很明显，上面的写法有两个问题。</p>
<p>第一，性能计数器框架代码侵入到业务代码中，跟业务代 码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。</p>
<p>第二，收集接口请求的 代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处 理。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业 务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。</p>
<p>UserController：核心业务实现类</p>
<p>UserControllerProxy：代理类，通过 委托 的方式（不修改源代码），对核心功能类增强 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span>;<br>    UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略login逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略register逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">private</span> UserController userController;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">(UserController userController)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userController = userController;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>		<span class="hljs-comment">// 委托</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="hljs-comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>())<br></code></pre></td></tr></table></figure>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。</p>
<p>但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个 第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下， 我们该如何实现代理模式呢？ </p>
<p>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承 原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体 代码如下所示：</p>
<p>UserController：别人写的，我们不知道长啥样</p>
<p>UserControllerProxy：我们自己写的，继承了 UserController，重写了里面的方法，方法里面的主要逻辑是对原功能增强，核心逻辑是 super.login() 调用原方法，一般项目开发中这种方式最常用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-comment">//功能增强</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//核心逻辑：通过委托的方式，super.login</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//UserControllerProxy使用举例</span><br>    <span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>();<br></code></pre></td></tr></table></figure>



<h3 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h3><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的 方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的 附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。 </p>
<p>如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项 目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式 的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>
<p>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不 事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后 在系统中用代理类替换掉原始类。那如何实现动态代理呢？ </p>
<p>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已 经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来 看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中， MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创 建代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollectorProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricsCollectorProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();<br>        <span class="hljs-type">DynamicProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(proxiedObject);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), in<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> Object proxiedObject;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>            <span class="hljs-built_in">this</span>.proxiedObject = proxiedObject;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Th<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxiedObject, args);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiName</span> <span class="hljs-operator">=</span> proxiedObject.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + method.getNam<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(apiName, responseTime, startTim<br>        metricsCollector.recordRequest(requestInfo);<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//MetricsCollectorProxy使用举例</span><br>MetricsCollectorProxy proxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollectorProxy</span>();<br>IUserController userController=(IUserController)proxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserC</span><br></code></pre></td></tr></table></figure>

<p>实际上，<strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建 代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。</strong></p>
<p>Spring 为这些类创建动 态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执 行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>
<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在 你的项目开发中。 </p>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类 中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代 理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个 支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数 据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？ </p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的 接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代 码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存 接口）、集中配置（比如配置每个接口缓存过期时间）。 </p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时 候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间） 等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 （比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获 取数据直接返回。</p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。 </p>
<p><strong>代理模式的原理与实现</strong></p>
<p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情 况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原 始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法 来实现代理模式。 </p>
<p><strong>动态代理的原理与实现</strong> </p>
<p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式 的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动 态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类 对应的代理类，然后在系统中用代理类替换掉原始类。 </p>
<p><strong>代理模式的应用场景</strong></p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事 务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只 需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p>
<h1 id="桥接模式-1"><a href="#桥接模式-1" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>最难理解的模式之一，应用场景也比较局限</p>
<p>对于这个模式 有两种不同的理解方式：</p>
<p>在 GoF 的《设计模 式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。” </p>
<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</p>
<h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>JDBC 驱动是桥接模式的经典应用。我们先来看一 下，如何利用 JDBC 驱动来查询数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-comment">//加载及注册JDBC驱动程序</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_pas</span><br><span class="hljs-string">Connection con = DriverManager.getConnection(url);</span><br><span class="hljs-string">Statement stmt = con.createStatement()；</span><br><span class="hljs-string">String query = &quot;</span>select * from test<span class="hljs-string">&quot;;</span><br><span class="hljs-string">ResultSet rs=stmt.executeQuery(query);</span><br><span class="hljs-string">while(rs.next()) &#123;</span><br><span class="hljs-string">    rs.getString(1);</span><br><span class="hljs-string">    rs.getInt(2);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵 活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置 文件就可以了。 </p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很 少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>
<p>源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.jdbc;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException if a database error occurs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-comment">// Required for Class.forName().newInstance()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。 第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代 码，也就是将 MySQL Driver 注册到 DriverManager 类中。 </p>
<p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们 把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后， 后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现 类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>
<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽 象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么 是“抽象”？什么是“实现”呢？ </p>
<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。<u>JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都 委托给 Driver 来执行。</u></p>
<img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130917.png" alt="image-20220110165339220" style="zoom:67%;" />



<h3 id="桥接模式的应用举例"><a href="#桥接模式的应用举例" class="headerlink" title="桥接模式的应用举例"></a>桥接模式的应用举例</h3><p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严 重）级别的消息会通过“自动语音电话”告知相关人员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotificationEmergencyLevel level, String message)</span>&#123;<br>        <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.SEVERE))&#123;<br>			<span class="hljs-comment">//...自动语音电话</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.URGENCY))&#123;<br>			<span class="hljs-comment">//...发微信</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.NORMAL))&#123;	<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.TRIVIAL))&#123;<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际 上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支 判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。 </p>
<p>不过，Notification 的代码显然不符合这个条件。因为<u>每个 if-else 分支中的代码逻辑都比 较复杂</u>，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细 小的类，然后再通过某种更合理的结构组装在一起。 </p>
<p><u>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 （MsgSender 相关类）</u>。其中，Notification 类相当于抽象，MsgSender 类相当于实 现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意 思就是，<u>不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们 可以动态地去指定（比如，通过读取配置来获取对应关系）。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelephoneMsgSender</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>        <span class="hljs-built_in">this</span>.telephones = telephones;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">protected</span> MsgSender msgSender;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.msgSender = msgSender;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SevereNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SevereNotification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">super</span>(msgSender);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>        msgSender.send(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrgencyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrivialNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>总体上来讲，桥接模式的原理比较难理解，但代码实现相对简单。 对于这个模式有两种不同的理解方式。在 GoF 的《设计模式》一书中，桥接模式被定义 为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更 加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式， 让这两个（或多个）维度可以独立进行扩展。” </p>
<p>对于第一种 GoF 的理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关 键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类 库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中 的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实 现”独立开发，通过对象之间的组合关系，组装在一起。</p>
<p>对于第二种理解方式，它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关 系来替代继承关系，避免继承层次的指数级爆炸。</p>
<h1 id="装饰者模式-1"><a href="#装饰者模式-1" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>它的代码结构跟桥接模式非常相似</p>
<blockquote>
<p>以下内容来自 C语言中文网，用于辅助理解</p>
</blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。</p>
<p><strong>Q：装饰器模式包含的角色</strong></p>
<p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130918.png" alt="image-20220110173456399" style="zoom:50%;" />

<p> 装饰器模式的结构图</p>
<h3 id="Java-IO-类的“奇怪”用法"><a href="#Java-IO-类的“奇怪”用法" class="headerlink" title="Java IO 类的“奇怪”用法"></a>Java IO 类的“奇怪”用法</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130919.png" alt="image-20220111094225907"></p>
<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130920.png" alt="image-20220111094255367"></p>
<p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代 码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类， FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓 存功能的数据读取类，可以提高数据读取的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计 一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就 可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读 取数据，用起来岂不是更加简单？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基于继承的设计方案"><a href="#基于继承的设计方案" class="headerlink" title="基于继承的设计方案"></a>基于继承的设计方案</h3><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础 之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还 算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。 </p>
<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(in);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支 持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、 BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩 展，也不好维护。这也是我们在第 10 节中讲的不推荐使用继承的原因。</p>
<h3 id="基于装饰器模式的设计方案"><a href="#基于装饰器模式的设计方案" class="headerlink" title="基于装饰器模式的设计方案"></a>基于装饰器模式的设计方案</h3><p>针对刚刚的 继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示 了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现基于缓存的读数据接口...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DataInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现读取基本类型数据的接口</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>看了上面的代码，你可能会问，那<strong>装饰器模式就是简单的“用组合替代继承”吗？</strong>当然不 是。<strong>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。</strong> </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功 能。</u></p>
<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原 始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器 模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在 设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<h1 id="适配器模式-1"><a href="#适配器模式-1" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？</h2><p>它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类 可以一起工作。</p>
<p>对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式有两种实现方式：类适配器和对象适 配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>具体的代码 实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类适配器: 基于继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.fa();<br>	 &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>     &#125;<br>	 <span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对象适配器：基于组合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有 两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<p>如果 Adaptee 接口并不多，那两种实现方式都可以。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推 荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方 式，Adaptor 的代码量要少一些。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们 推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p>
<h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？ </p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式 算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。 前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情 况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结</p>
<p><strong>1、封装有缺陷的接口设计</strong></p>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影 响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进 行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CD</span> &#123; <span class="hljs-comment">//这个类来自外部sdk，我们无权修改它的代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uglyNamingFunction2</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tooManyParamsFunction3</span> <span class="hljs-params">( <span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB, ...)</span>&#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPerformanceFunction4</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fucntion3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.staticFunction1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.uglyNamingFucntion2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;<br>        <span class="hljs-built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">//...reimplement it...</span><br>    &#125;<br>&#125;        <br>        <br></code></pre></td></tr></table></figure>

<p><strong>2、统一多个类的接口设计</strong></p>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统 一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解 释一下。 </p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入 了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感 词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用 各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定 义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilter</span> &#123; <span class="hljs-comment">// A敏感词过滤系统提供的接口</span><br>    <span class="hljs-comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSexyWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterPoliticalWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// B敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// C敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text, String mask)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ASensitiveWordsFilter</span> <span class="hljs-variable">aFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">BSensitiveWordsFilter</span> <span class="hljs-variable">bFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CSensitiveWordsFilter</span> <span class="hljs-variable">cFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        maskedText = bFilter.filter(maskedText);<br>        maskedText = cFilter.filter(maskedText, <span class="hljs-string">&quot;***&quot;</span>);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行改造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123; <span class="hljs-comment">// 统一接口定义</span><br>    String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilterAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> ASensitiveWordsFilter aFilter;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="hljs-comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="hljs-comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSensitiveWordsFilter</span><span class="hljs-params">(ISensitiveWordsFilter filter)</span> &#123;<br>        filters.add(filter);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> text;<br>        <span class="hljs-keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;<br>            maskedText = filter.filter(maskedText);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3\替换依赖的外部系统</p>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以 减少对代码的改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部系统A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    &#125;<br>    <span class="hljs-comment">// 在我们的项目中，外部系统A的使用示例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>        <span class="hljs-keyword">private</span> IA a;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(IA a)</span> &#123;<br>            <span class="hljs-built_in">this</span>.a = a;<br>        &#125;<br>	<span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>    <span class="hljs-comment">// 将外部系统A替换成外部系统B</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdaptor</span> implemnts IA &#123;<br>        <span class="hljs-keyword">private</span> B b;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdaptor</span><span class="hljs-params">(B b)</span> &#123;<br>            <span class="hljs-built_in">this</span>.b= b;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>            b.fb();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br>	<span class="hljs-comment">// 只需要将BAdaptor如下注入到Demo即可。</span><br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdaptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>()));<br></code></pre></td></tr></table></figure>

<p>4\兼容老版本接口</p>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且 标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用 场景。同样，我还是通过一个例子，来进一步解释一下。 </p>
<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它 改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接 从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为 了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使 用 Iterator 才行。 </p>
<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发 的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是 不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码， 我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下 所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Emueration <span class="hljs-title function_">emumeration</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Collection c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>() &#123;<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator();<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMoreElments</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.hashNext();<br>            &#125;<br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nextElement</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.next():<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5\适配不同格式的数据 </p>
<p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之 间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方 便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类 型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="剖析适配器模式在-Java-日志中的应用"><a href="#剖析适配器模式在-Java-日志中的应用" class="headerlink" title="剖析适配器模式在 Java 日志中的应用"></a>剖析适配器模式在 Java 日志中的应用</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常 用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。 </p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、 erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不 像 JDBC 那样，一开始就制定了数据库操作的接口规范。 </p>
<p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选 一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框 架的选择就没那么随意了。 </p>
<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志 框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比 如，日志存储的文件地址、打印日志的格式）。</p>
<p>如果引入多个组件，每个组件使用的日志框 架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要 统一日志打印框架。 如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范， 提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需 要配合其他日志框架（log4j、logback……）来使用。 </p>
<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能 牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所 以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框 架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// slf4j统一的接口定义</span><br><span class="hljs-keyword">package</span> org.slf4j;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable t)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span>;<br><span class="hljs-comment">//...省略info、warn、error等一堆接口</span><br>&#125;<br><span class="hljs-comment">// log4j日志框架的适配器</span><br><span class="hljs-comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="hljs-comment">// 其中LocationAwareLogger继承自Logger接口，</span><br><span class="hljs-comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="hljs-keyword">package</span> org.slf4j.impl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4jLoggerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarkerIgnoringBase</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocationAwareLogger</span>, Serializable &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> org.apache.log4j.Logger logger; <span class="hljs-comment">// log4j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg1, arg2);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.arrayFormat(format, argArray);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, t);<br>    &#125;<br><span class="hljs-comment">//...省略一堆接口的实现...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写 打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定 的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导 入到项目中即可。 </p>
<p>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日 志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提 供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志 框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配 器的转换，我们能就成功将 log4j 切换为了 logback。</p>
<h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结 构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封 装原始类。 </p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场 景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。 </p>
<p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是 控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 </p>
<p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相 对独立地加以改变。</p>
<p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持 多个装饰器的嵌套使用。 </p>
<p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理 模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>适配器模式有两种实现方式：类适配器和对象适配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样 5 种场景：</p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<h1 id="结构型模式-下篇"><a href="#结构型模式-下篇" class="headerlink" title="结构型模式 | 下篇"></a>结构型模式 | 下篇</h1><h2 id="结构型模式总览-1"><a href="#结构型模式总览-1" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率-1"><a href="#设计模式使用频率-1" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" alt="image-20220106141529342"></p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易 用。</p>
<p>让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>1、解决易用性问题</p>
<p>Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p>
<p>2、解决性能问题</p>
<p>通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度</p>
<p>3、解决分布式事务问题</p>
<p>在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<p>场景举例一：</p>
<p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。</p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>应用举例一：开发一个棋牌游戏</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。</p>
<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间。</p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p>
<p>应用举例二：在文本编辑器中的应用</p>
<p>我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。</p>
<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java Integer 缓冲池</p>
<p>Java String 字符串常量池</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>享元模式 vs 单例、缓存、对象池</strong></p>
<p>应用单例模式是为了保证对象全局唯一。</p>
<p>应用享元模式是为了实现对象复用，节省内存。</p>
<p>缓存是为了提高访问效率，而非复用。 </p>
<p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h1 id="门面模式-1"><a href="#门面模式-1" class="headerlink" title="门面模式"></a>门面模式</h1><h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？</h2><p>原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。 </p>
<p>如果你平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？ </p>
<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需 要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>
<p>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口 不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开 发不同的接口来满足，这就会导致系统的接口无限膨胀。</p>
<h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>这个定义很简洁，我再进一步解释一下。 </p>
<p>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。 </p>
<p>不知道你会不会有这样的疑问，让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么 还要提供一个包裹 a、b、d 的接口 x 呢？关于这个问题，我通过一个具体的例子来解释一 下。 </p>
<p>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过 后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信 的，<u>网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之 间的网络通信次数</u>。 </p>
<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接 口，因自身业务的特点，不支持并发调用这三个接口。</p>
<p>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用 过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。 </p>
<p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应 用场景下，使用门面模式的意图也不同。</p>
<h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><p>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性 问题之外，还能解决其他很多方面的问题。关于这一点，我总结罗列了 3 个常用的应用场 景，你可以参考一下，举一反三地借鉴到自己的项目中。 </p>
<p>除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种 理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</p>
<p>1、解决易用性问题</p>
<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高 层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。 </p>
<p>我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表 述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲 到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要 的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接 口，封装底层实现细节。</p>
<p>2、解决性能问题</p>
<p>关于利用门面模式解决性能问题这一点，刚刚我们已经讲过了。我们通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。所以，关于这 点，我就不再举例说明了。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何 组织门面接口和非门面接口？ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普 通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专 门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很 多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p>
<p>3、解决分布式事务问题</p>
<p>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。 </p>
<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了 一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景： 在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱 包（在数据库的 Wallet 表中）。 </p>
<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来 完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成 功，要么都失败，不能一个成功、一个失败。 </p>
<p><u>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。</u>虽然我 们可以通过引入<u>分布式事务框架或者事后补偿的机制</u>来解决，但代码实现都比较复杂。而最 简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的 话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。 </p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的 好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经 常说，完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不 到哪里去。 </p>
<p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在 实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基 本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口， 来提供更易用的接口。 </p>
<p>门面模式除了解决接口易用性问题之外，我们今天还讲到了其他 2 个应用场景，用它来解 决性能问题和分布式事务问题。</p>
<h1 id="组合模式-1"><a href="#组合模式-1" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全 是两码事。</p>
<p>这里讲的“组合模式”，主要是用来处理树形结构数据。</p>
<p>这里的“数据”，你可 以简单理解为一组对象集合，待会我们会详细讲解。 正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项 目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作 用，能让代码变得非常简洁。</p>
<h3 id="组合模式的原理与实现"><a href="#组合模式的原理与实现" class="headerlink" title="组合模式的原理与实现"></a>组合模式的原理与实现</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功 能： </p>
<p>动态地添加、删除某个目录下的子目录或文件； </p>
<p>统计指定目录下的文件个数； </p>
<p>统计指定目录下的文件总大小。</p>
<p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去 补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isFile;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isFile)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>        <span class="hljs-built_in">this</span>.isFile = isFile;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>            <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> file.length();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果 我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模 （文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对 业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。 按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">protected</span> String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        java.io.<span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(path);<br>        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> file.length();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具 体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> * /wz/</span><br><span class="hljs-comment"> * /wz/a.txt</span><br><span class="hljs-comment"> * /wz/b.txt</span><br><span class="hljs-comment"> * /wz/movies/</span><br><span class="hljs-comment"> * /wz/movies/c.avi</span><br><span class="hljs-comment"> * /xzg/</span><br><span class="hljs-comment"> * /xzg/docs/</span><br><span class="hljs-comment"> * /xzg/docs/d.txt</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">fileSystemTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/&quot;</span>);<br>        fileSystemTree.addSubNode(node_wz);<br>        fileSystemTree.addSubNode(node_xzg);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/a.txt&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/b.txt&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz_movies</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/movies/&quot;</span>);<br>        node_wz.addSubNode(node_wz_a);<br>        node_wz.addSubNode(node_wz_b);<br>        node_wz.addSubNode(node_wz_movies);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_movies_c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/movies/c.avi&quot;</span>);<br>        node_wz_movies.addSubNode(node_wz_movies_c);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg_docs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/docs/&quot;</span>);<br>        node_xzg.addSubNode(node_xzg_docs);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_xzg_docs_d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/xzg/docs/d.txt&quot;</span>);<br>        node_xzg_docs.addSubNode(node_xzg_docs_d);<br>        System.out.println(<span class="hljs-string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());<br>        System.out.println(<span class="hljs-string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场 景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通 过在树上的递归遍历算法来实现。 </p>
<h3 id="组合模式的应用场景举例"><a href="#组合模式的应用场景举例" class="headerlink" title="组合模式的应用场景举例"></a>组合模式的应用场景举例</h3><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子， 你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场 景，你只要“照葫芦画瓢”去设计就可以了。 假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131024.png" alt="image-20220112152058414"></p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。 </p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。 </p>
<p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看 一下。其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出 来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在 内存中构建组织架构图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> id;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HumanResource</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Department</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (HumanResource hr : subNodes) &#123;<br>            totalSalary += hr.calculateSalary();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.salary = totalSalary;<br>        <span class="hljs-keyword">return</span> totalSalary;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(HumanResource hr)</span> &#123;<br>        subNodes.add(hr);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建组织架构的代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ORGANIZATION_ROOT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    <span class="hljs-keyword">private</span> DepartmentRepo departmentRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> EmployeeRepo employeeRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Department</span> <span class="hljs-variable">rootDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(ORGANIZATION_ROOT_ID);<br>        buildOrganization(rootDepartment);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">(Department department)</span> &#123;<br>        List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long subDepartmentId : subDepartmentIds)</span> &#123;<br>            <span class="hljs-type">Department</span> <span class="hljs-variable">subDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(subDepartmentId);<br>            department.addSubNode(subDepartment);<br>            buildOrganization(subDepartment);<br>        &#125;<br>        List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.g<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long employeeId : employeeIds)</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> employeeRepo.getEmployeeSalary(employeeId);<br>            department.addSubNode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(employeeId, salary));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结 构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客 户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<h1 id="享元模式-1"><a href="#享元模式-1" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h2><h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。 </p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。 </p>
<p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之 后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露 任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代 码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。 </p>
<p>接下来，我们通过一个简单的例子解释一下享元模式。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一 个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<span class="hljs-comment">//棋子</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">String</span> text, Color color, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positi</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.id = id;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.text = text;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.color = color;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionX = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionY = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> Color &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        RED, BLACK</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// ...省略其他属性和getter/setter方法...</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ChessBoard &#123;<span class="hljs-comment">//棋局</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> ChessBoard() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        init();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> init() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略摆放其他棋子的代码...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> move(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多）， 那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？ </p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如 下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPieceUnit</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.text = text;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>        RED, BLACK<br>    &#125;<br><span class="hljs-comment">// ...省略其他属性和getter方法...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnitFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        pieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));<br>        pieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessPieceUnit <span class="hljs-title function_">getChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId)</span> &#123;<br>        <span class="hljs-keyword">return</span> pieces.get(chessPieceId);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<br>    <span class="hljs-keyword">private</span> ChessPieceUnit chessPieceUnit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(ChessPieceUnit unit, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.chessPieceUnit = unit;<br>        <span class="hljs-built_in">this</span>.positionX = positionX;<br>        <span class="hljs-built_in">this</span>.positionY = positionY;<br>    &#125;<br><span class="hljs-comment">// 省略getter、setter方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>        <span class="hljs-comment">//...省略...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、 color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享 这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记 录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元 模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。 </p>
<p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简 单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来 达到复用的目的。 </p>
<h3 id="享元模式在文本编辑器中的应用"><a href="#享元模式在文本编辑器中的应用" class="headerlink" title="享元模式在文本编辑器中的应用"></a>享元模式在文本编辑器中的应用</h3><p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的： 如何利用享元模式来优化文本编辑器的内存占用？ 你可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。 </p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的 代码示例如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<span class="hljs-comment">//文字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>        <span class="hljs-keyword">this</span>.font = font;<br>        <span class="hljs-keyword">this</span>.size = size;<br>        <span class="hljs-keyword">this</span>.colorRGB = colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        Character character = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Character</span>(c, font, size, colorRGB);<br>        chars.<span class="hljs-built_in">add</span>(character);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyle</span> &#123;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharacterStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.font = font;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">otherStyle</span> <span class="hljs-operator">=</span> (CharacterStyle) o;<br>        <span class="hljs-keyword">return</span> font.equals(otherStyle.font)<br>                &amp;&amp; size == otherStyle.size<br>                &amp;&amp; colorRGB == otherStyle.colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyleFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharacterStyle <span class="hljs-title function_">getStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">newStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterStyle</span>(font, size, colorRGB);<br>        <span class="hljs-keyword">for</span> (CharacterStyle style : styles) &#123;<br>            <span class="hljs-keyword">if</span> (style.equals(newStyle)) &#123;<br>                <span class="hljs-keyword">return</span> style;<br>            &#125;<br>        &#125;<br>        styles.add(newStyle);<br>        <span class="hljs-keyword">return</span> newStyle;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> CharacterStyle style;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, CharacterStyle style)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>        <span class="hljs-built_in">this</span>.style = style;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, CharacterStyleFactory.getStyle(font<br>                chars.add(character);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h3><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、 对象池这些概念有什么区别呢？我们来简单对比一下。 </p>
<p><strong>我们先来看享元模式跟单例的区别。</strong></p>
<p><u>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每 个对象被多处代码引用共享。</u>实际上，享元模式有点类似于之前讲到的单例的变体：多例。 </p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上 来看，它们是完全不同的。<u>应用享元模式是为了对象复用，节省内存，而应用多例模式是为 了限制对象的个数。</u> </p>
<p><strong>我们再来看享元模式跟缓存的区别。</strong> </p>
<p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际 上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓 存”是两回事。我们平时所讲的缓存，<u>主要是为了提高访问效率，而非复用。</u> </p>
<p><strong>最后我们来看享元模式跟对象池的区别。</strong> </p>
<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么 区别呢？ </p>
<p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象 池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。 每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。 </p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一 抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中 的“复用”实际上是不同的概念。 </p>
<p><u>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中 取一个连接，不需要重新创建）</u>。在任意时刻，每一个对象、连接、线程，并不会被多处使 用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。<u>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享 的，主要目的是节省空间。</u></p>
<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p><strong>享元模式的原理</strong></p>
<p><u>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以 利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以 减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享 元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元， 让这些大量相似对象引用这些享元。</u> </p>
<p><strong>享元模式的实现</strong> </p>
<p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。 </p>
<p><strong>享元模式 VS 单例、缓存、对象池</strong></p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。这里的区别也不例外。 </p>
<p>我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯 一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。 池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h2 id="享元模式（下）：剖析享元模式在Java-Integer、String中-的应用"><a href="#享元模式（下）：剖析享元模式在Java-Integer、String中-的应用" class="headerlink" title="享元模式（下）：剖析享元模式在Java Integer、String中 的应用"></a>享元模式（下）：剖析享元模式在Java Integer、String中 的应用</h2><h3 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>System.out.println(i1 == i2);<br>System.out.println(i3 == i4);<br></code></pre></td></tr></table></figure>

<p>如何判定两个 Java 对象是否相等（也就代码中的“==”操作符的含义）？ </p>
<p>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131025.png" alt="image-20220112155026935"></p>
<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自 动将包装器类型转化为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>; <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure>

<p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱 操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语 句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">59</span>；底层执行了：<span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">59</span>);<br></code></pre></td></tr></table></figure>

<p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操 作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; 底层执行了：<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure>

<p>Q：Java 对象在内存中是如何存储的。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span> a = new User(<span class="hljs-number">123</span>, <span class="hljs-number">23</span>); // id=<span class="hljs-number">123</span>, age=<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>

<p>针对这条语句，我画了一张内存存储结构图，如下所示。a 存储的值是 User 对象的内存地 址，在图中就表现为 a 指向 User 对象。 </p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131026.png" alt="image-20220112155226847"></p>
<p>当我们通过“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的 地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p>
<p>了解了 Java 的这几个语法之后，我们重新看一下开头的那段代码。</p>
<p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、 i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不 同的 Integer 对象，所以通过“==”来判定是否相同的时候，会返回 false。同理， i3==i4 判定语句也会返回 false。 </p>
<p>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这 里，你可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才 导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象 的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函 数的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>	<span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>		<span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，这里的 IntegerCache 相当于，我们上一节课中讲的生成享元对象的工厂类，只不 过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类， 你也可以自行查看 JDK 源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cache to support the object identity semantics of autoboxing for values betw</span><br><span class="hljs-comment"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The cache is initialized on first usage. The size of the cache</span><br><span class="hljs-comment"> * may be controlled by the &#123;<span class="hljs-doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="hljs-comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="hljs-comment"> * may be set and saved in the private system properties in the</span><br><span class="hljs-comment"> * sun.misc.VM class.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>)<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？ </p>
<p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性 创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值， 这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存 对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数 据）。 </p>
<p>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你 通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，你 就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没 有提供设置最小值的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br>-Djava.lang.Integer.IntegerCache.high=<span class="hljs-number">255</span><br><span class="hljs-comment">//方法二：</span><br>-XX:AutoBoxCacheMax=<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure>

<p>现在，让我们再回到最开始的问题，因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同 的享元对象，所以 i1==i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一 个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3==i4 返回 false。 </p>
<p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利 用了享元模式来缓存 -128 到 127 之间的数据。比如，Long 类型对应的 LongCache 享元 工厂类及 valueOf() 函数代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LongCache</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long cache[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[-(-<span class="hljs-number">128</span>) + <span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>            cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(i - <span class="hljs-number">128</span>);<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>            <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子， 假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们 需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。 </p>
<h3 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h3><p>刚刚我们讲了享元模式在 Java Integer 类中的应用，现在，我们再来看下，享元模式在 Java String 类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是 什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小争哥&quot;</span>);<br>System.out.println(s1 == s2);<br>System.out.println(s1 == s3);<br></code></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类 利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存 储结构如下所示：</p>
<p><img src="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131027.png" alt="image-20220112155710422"></p>
<p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对 象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知 道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的 时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需 要再重新创建了。 </p>
<h3 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>在 Java Integer 的实现中，-128 到 127 之间的整型对象会被事先创建好，缓存在 IntegerCache 类中。当我们使用自动装箱或者 valueOf() 来创建这个数值区间的整型对象 时，会复用 IntegerCache 类事先创建好的对象。这里的 IntegerCache 类就是享元工厂 类，事先创建好的整型对象就是享元对象。 </p>
<p>在 Java String 类的实现中，JVM 开辟一块存储区专门存储字符串常量，这块存储区叫作 字符串常量池，类似于 Integer 中的 IntegerCache。不过，跟 IntegerCache 不同的是，它并非事先创建好需要共享的对象，而是在程序的运行期间，根据需要来创建和缓存字符串 常量。 </p>
<p>除此之外，这里我再补充强调一下。 </p>
<p>实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的 引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自 动回收掉。因此，<u>在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元 模式反倒可能会浪费更多的内存。</u>所以，除非经过线上验证，利用享元模式真的可以大大节 省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模 式，得不偿失啊。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL百科全书</title>
    <url>/2022/03/23/%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%9AMySQL%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Linux下的安装与使用"><a href="#一、Linux下的安装与使用" class="headerlink" title="一、Linux下的安装与使用"></a>一、Linux下的安装与使用</h1><h2 id="常用命令行"><a href="#常用命令行" class="headerlink" title="常用命令行"></a>常用命令行</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查看MySQL版本</span><br>mysql --version<br><br><span class="hljs-section"># 查看是否安装成功</span><br>rpm -qa|grep -i mysql<br><br><span class="hljs-section"># 启动MySQL，查看状态</span><br>启动：systemctl start mysqld.service<br>关闭：systemctl stop mysqld.service<br>重启：systemctl restart mysqld.service<br>查看状态：systemctl status mysqld.service<br><br><span class="hljs-section"># 重新启动MySQL服务</span><br>systemctl restart mysqld<br><br><span class="hljs-section"># 设置MySQL服务自启动</span><br>systemctl enable mysqld.service<br><br><span class="hljs-section"># 修改已创建数据库的字符集</span><br>alter database dbtest1 character set &#x27;utf8&#x27;;<br><br><span class="hljs-section"># 修改已创建数据表的字符集</span><br>alter table t<span class="hljs-emphasis">_emp convert to character set &#x27;utf8&#x27;;</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure>



<p>登录MySQL服务器 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下： </p>
<p>下面详细介绍命令中的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql –h hostname<span class="hljs-operator">|</span>hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>hlocalhost <span class="hljs-operator">-</span>P3306 mysql <span class="hljs-operator">-</span>e &quot;select host,user from user&quot;<br></code></pre></td></tr></table></figure>

<p>-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </p>
<p>-P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306， 不使用该参数时自动连接到3306端口，port为连接的端口号。 </p>
<p>-u参数 后面接用户名，username为用户名。 </p>
<p>-p参数 会提示输入密码。 </p>
<p>DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库 中，然后可以使用USE命令来选择数据库。 </p>
<p>-e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL 服务器。</p>
<h2 id="SQL大小写规范"><a href="#SQL大小写规范" class="headerlink" title="SQL大小写规范"></a>SQL大小写规范</h2><p>不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大 小写问题。 windows系统默认大小写不敏感 ，但是 linux系统是大小写敏感的 。 </p>
<p>通过如下命令查看：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%lower_case_table_names%&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210154.png" alt="image-20220121150030248"></p>
<p>lower_case_table_names参数值的设置： </p>
<ul>
<li><p>默认为0，大小写敏感 。 </p>
</li>
<li><p>设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转 换为小写对表和数据库进行查找。 </p>
</li>
<li><p>设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。 </p>
</li>
</ul>
<p><strong>两个平台上SQL大小写的区别具体来说：</strong></p>
<p>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的： </p>
<p>1、数据库名、表名、表的别名、变量名是严格区分大小写的； </p>
<p>2、关键字、函数名称在 SQL 中不区分大小写； </p>
<p>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的； </p>
<p>MySQL在Windows的环境下全部不区分大小写</p>
<h2 id="sql-mode的合理设置"><a href="#sql-mode的合理设置" class="headerlink" title="sql_mode的合理设置"></a>sql_mode的合理设置</h2><p>sql_mode 会影响MySQL支持的SQL语法以及它执行的<code>数据验证检查</code>。通过设置sql_mode，可以完成不同严格程度的数据校验，有效地保障数据准确性。</p>
<p>MySQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于sql_mode系统变量的值。</p>
<p>MySQL5.6和MySQL5.7默认的sql_mode模式参数是不一样的:</p>
<ul>
<li><p>5.6的mode默认值为空(即: NO_ENGINE_SUBSTITUTION )，其实表示的是一个空值，相当于没有什么模式设置，可以理解为<code>宽松模式</code>。在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。</p>
</li>
<li><p>5.7的mode是 STRICT_TRANS_TABLES，也就是<code>严格模式</code>。用于进行数据的严格校验，错误数据不能插入，报error(错误)，并且事务回滚。</p>
</li>
</ul>
<hr>
<p><strong>宽松模式：</strong> </p>
<p>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受， 并且不报错。 </p>
<p><strong>举例 ：</strong>我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时 char(10) ，如果我 在插入数据的时候，其中name这个字段对应的有一条数据的 长度超过了10 ，例如’1234567890abc’，超 过了设定的字段长度10，那么不会报错，并且取前10个字符存上，也就是说你这个数据被存为 了’1234567890’，而’abc’就没有了。但是，我们给的这条数据是错误的，因为超过了字段长度，但是并没 有报错，并且mysql自行处理并接受了，这就是宽松模式的效果。 </p>
<p><strong>应用场景 ：</strong>通过设置sql mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据 库之间进行 迁移 时，则不需要对业务sql 进行较大的修改。 </p>
<p><strong>严格模式：</strong> </p>
<p>出现上面宽松模式的错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式。所 以在 生产等环境 中，我们必须采用的是严格模式，进而 开发、测试环境 的数据库也必须要设置，这样在 开发测试阶段就可以发现问题。并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式。 </p>
<p><strong>开发经验 ：</strong>MySQL等数据库总想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实开发 中，我们应该在自己 开发的项目程序级别将这些校验给做了 ，虽然写项目的时候麻烦了一些步骤，但是这 样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。 </p>
<p><strong>改为严格模式后可能会存在的问题：</strong></p>
<p>若设置模式中包含了 NO_ZERO_DATE ，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而 不是警告。例如，表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配 DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这显然是不满足sql_mode中的NO_ZERO_DATE而报错。</p>
<h1 id="二、MySQL的数据目录"><a href="#二、MySQL的数据目录" class="headerlink" title="二、MySQL的数据目录"></a>二、MySQL的数据目录</h1><h2 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">find / -name mysql<br></code></pre></td></tr></table></figure>

<p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>
<p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和 /usr/sbin</p>
<p>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</p>
<h2 id="MySQL自带的系统数据库"><a href="#MySQL自带的系统数据库" class="headerlink" title="MySQL自带的系统数据库"></a>MySQL自带的系统数据库</h2><p>SHOW DATABASES;</p>
<p>可以看到有4个数据库是属于MySQL自带的系统数据库。 </p>
<p><strong>mysql</strong></p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定 义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 </p>
<p><strong>information_schema</strong> </p>
<p>MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有 哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些 描述性信息，有时候也称之为 元数据 。在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表，用于表示内部系统表。</p>
<p><strong>performance_schema</strong></p>
<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以 用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。 </p>
<p><strong>sys</strong></p>
<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
<h2 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h2><h3 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a>InnoDB存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：<code>表名.frm</code></p>
<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>
<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件 的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的。</p>
<p><strong>2、表中数据和索引</strong></p>
<p><strong>① 系统表空间（system tablespace）</strong> </p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自 己增加文件大小。 </p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名 难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置 文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_data_file_path</span>=data1:<span class="hljs-number">512</span>M<span class="hljs-comment">;data2:512M:autoextend</span><br></code></pre></td></tr></table></figure>

<p><strong>② 独立表空间(file-per-table tablespace)</strong></p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来 存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表 名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：<code>表名.ibd</code></p>
<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应 的 atguigu 目录下会为 test 表创建这两个文件：<code>test.frm</code>  <code>test.ibd</code></p>
<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>
<p><strong>③ 系统表空间与独立表空间的设置</strong> </p>
<p>我们可以自己指定使用 <code>系统表空间</code> 还是 <code>独立表空间</code> 来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动 MySQL服务器的时候这样配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span> <span class="hljs-comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></code></pre></td></tr></table></figure>

<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| innodb_file_per_table | ON    |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>



<p><strong>④ 其他类型的表空间</strong> </p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用 表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h3 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专 门用于描述表结构的文件：<code>表名.frm</code></p>
<p><strong>2、表中数据和索引</strong> </p>
<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test 表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文 件：</p>
<p><code>test.frm 存储表结构 </code></p>
<p><code>test.MYD 存储数据 (MYData) </code></p>
<p><code>test.MYI 存储索引 (MYIndex)</code></p>
<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student_myisam` (<br>`id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`sex` <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>)ENGINE=MYISAM AUTO_INCREMENT=<span class="hljs-number">0</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>举例： <code>数据库a ， 表b </code>。 </p>
<p><strong>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</strong> </p>
<p><code>b.frm </code>：描述表结构文件，字段长度等 </p>
<p>如果采用 <code>系统表空间</code> 模式的，数据信息和索引信息都存储在 <code>ibdata1</code> 中 </p>
<p>如果采用 <code>独立表空间</code> 存储模式，data\a 中还会产生 <code>b.ibd</code> 文件（存储数据信息和索引信息） </p>
<p>此外： </p>
<p>​    ① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较 规则。而MySQL8.0不再提供db.opt文件。 </p>
<p>​    ② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。 </p>
<p><strong>2、如果表b采用 <code>MyISAM</code> ，data\a 中会产生3个文件：</strong> </p>
<p>​    MySQL5.7 中：<code>b.frm</code> ：描述表结构文件，字段长度等。 </p>
<p>​    MySQL8.0 中 <code>b.xxx.sdi </code>：描述表结构文件，字段长度等 </p>
<p>​    <code>b.MYD (MYData)</code>：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>
<p>​    <code>b.MYI (MYIndex)</code>：存放索引信息文件</p>
<h2 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h2><p>我们知道MysQL中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只余存储一个 <code>视图名.frm</code>的文件。如下图中的: emp_details_view.frm</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">[ root<span class="hljs-symbol">@atguigu82</span> mysql]<span class="hljs-meta"># cd ./temp</span><br>[ root<span class="hljs-symbol">@atguigu82</span> temp]<span class="hljs-meta"># ll</span><br></code></pre></td></tr></table></figure>

<h2 id="其他的文件"><a href="#其他的文件" class="headerlink" title="其他的文件"></a>其他的文件</h2><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件:</p>
<p><strong>1、服务器进程文件</strong></p>
<p>我们知道每运行一个MySQL服务器程序，都意味着启动一个进程。MySQL服务器会把自己的进程ID写入到一个文件中。</p>
<p><strong>2、服务器日志文件</strong></p>
<p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等。这些日志各有各的用途，后面讲解。</p>
<p><strong>3、默认/自动生成的SSL和RSA证书和密钥文件</strong></p>
<p>主要是为了客户端和服务器安全通信而创建的一些文件。</p>
<h1 id="三、用户与权限管理"><a href="#三、用户与权限管理" class="headerlink" title="三、用户与权限管理"></a>三、用户与权限管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>MySQL用户可以分为普通用户和root用户。root用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限;普通用户只拥有被授予的各种权限。</p>
<p>MysQL提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出MysQL服务器、创建用户、删除用户、密码管理和权限管理等内容。</p>
<p><strong>MySQL数据库的安全性需要通过账户管理来保证。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210155.png" alt="image-20220120174452352"></p>
<p><strong>可以创建同名的用户，该表中使用 host 和 user 作为联合主键，就算 user相同，只要 host不同就可以</strong></p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>][,用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>]];<br></code></pre></td></tr></table></figure>

<p>用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成； </p>
<p>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户 可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY指定明文密码值。 </p>
<p>CREATE USER语句可以同时创建多个用户。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> zhang3 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123123&#x27;</span>; # 默认host是 %<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户名：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;li4&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;wang5&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>方式1：使用DROP方式删除（推荐） 使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span>[,<span class="hljs-keyword">user</span>]…;<br></code></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">li4</span> ; <span class="hljs-comment"># 默认删除host为%的用户</span><br>DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">&#x27;kangshifu</span>&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure>

<p>方式2：使用DELETE方式删除 </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=’hostname’ <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=’username’;<br></code></pre></td></tr></table></figure>

<p>执行完DELETE命令后要使用FLUSH命令来使用户生效，命令如下： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">FLUSH PRIVILEGES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=<span class="hljs-string">&#x27;Emily&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>

<p>注意：不推荐通过 DELETE FROM USER u WHERE USER=’li4’ 进行删除，系统会有残留信息保 留。而drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表 的相应记录都消失了。</p>
<h3 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h3><p>旧的写法如下 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 修改当前用户的密码：（MySQL5<span class="hljs-number">.7</span>测试有效）<br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-operator">=</span> PASSWORD(<span class="hljs-string">&#x27;123456&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>这里介绍 推荐的写法 ： </p>
<p>1、使用ALTER USER命令来修改当前用户密码 用户可以使用ALTER命令来修改自身密码，如下语句代表修 改当前登录用户的密码。基本语法如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">USER</span>() IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>2、使用SET语句来修改当前用户密码 使用root用户登录MySQL后，可以使用SET语句来修改密码，具体 SQL语句如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">PASSWORD</span>=<span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>该语句会自动将密码加密后再赋给当前用户。</p>
<h3 id="修改其它用户密码"><a href="#修改其它用户密码" class="headerlink" title="修改其它用户密码"></a>修改其它用户密码</h3><p>1、使用ALTER语句来修改普通用户的密码 可以使用ALTER USER语句来修改普通用户的密码。基本语法形 式如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span> [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]<br>[,<span class="hljs-keyword">user</span>[IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]]…;<br></code></pre></td></tr></table></figure>



<p>2、使用SET命令来修改普通用户的密码 使用root用户登录到MySQL服务器后，可以使用SET语句来修改普 通用户的密码。SET语句的代码如下：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-comment">FOR</span> <span class="hljs-comment">&#x27;username&#x27;</span><span class="hljs-comment">@</span><span class="hljs-comment">&#x27;hostname&#x27;</span><span class="hljs-comment">=</span><span class="hljs-comment">&#x27;new_password&#x27;</span>;<br><br></code></pre></td></tr></table></figure>



<p>3、使用UPDATE语句修改普通用户的密码（不推荐）</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> MySQL.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> authentication_string=<span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&quot;123456&quot;</span>)<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">User</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">AND</span> Host = <span class="hljs-string">&quot;hostname&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8密码管理-了解"><a href="#MySQL8密码管理-了解" class="headerlink" title="MySQL8密码管理(了解)"></a>MySQL8密码管理(了解)</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210156.png" alt="image-20220121153526888"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210157.png" alt="image-20220121153540169"></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h3><p>MySQL到底都有哪些权限呢？ </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210158.png" alt="image-20220121075608980"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure>

<p>（1） <code>CREATE和DROP权限</code> ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将 MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 </p>
<p>（2） <code>SELECT、INSERT、UPDATE和DELETE权限</code> 允许在一个数据库现有的表上实施操作。 </p>
<p>（3） <code>SELECT权限</code> 只有在它们真正从一个表中检索行时才被用到。 </p>
<p>（4） <code>INDEX权限</code> 允许创建或删除索引，INDEX适用于已 有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 </p>
<p>（5） <code>ALTER权 限</code> 可以使用ALTER TABLE来更改表的结构和重新命名表。 </p>
<p>（6） <code>CREATE ROUTINE权限</code> 用来创建保存的 程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的 程序。 </p>
<p>（7） <code>GRANT权限</code> 允许授权给其他用户，可用于数据库、表和保存的程序。 </p>
<p>（8） <code>FILE权限</code> 使用 户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权 限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务 器可以访问这些文件）。</p>
<h3 id="授予权限的原则"><a href="#授予权限的原则" class="headerlink" title="授予权限的原则"></a>授予权限的原则</h3><p>权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ： </p>
<p>1、只授予能 满足需要的最小权限 ，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可 以了，不要给用户赋予update、insert或者delete权限。 </p>
<p>2、创建用户的时候 限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。 </p>
<p>3、为每个用户 设置满足密码复杂度的密码 。 </p>
<p>4、 定期清理不需要的用户 ，回收权限或者删除用户。 </p>
<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>给用户授权的方式有 2 种，分别是通过把 角色赋予用户给用户授权 和 直接给用户授权 。用户是数据库的 使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全 隐患。 </p>
<p>授权命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">GRANT 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];<br></code></pre></td></tr></table></figure>

<p>该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>比如： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> atguigudb.* <span class="hljs-keyword">TO</span> li4@localhost ;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为<span class="hljs-number">123</span>。注意这里唯独不包括<span class="hljs-keyword">grant</span>的权限<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> joe@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210159.png" alt="image-20220121080515215"></p>
<p>我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的 分组。 </p>
<p>所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据； </p>
<p>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是 删除。</p>
<p><strong>总结</strong></p>
<p>有一些程序员喜欢使用Root超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。</p>
<p>但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用Root账号。因为Root账号密码放在代码里面不安全，一旦泄露，数据库就会完全<code>失去保护</code>。</p>
<p>而且，MySQL的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p>
<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>查看当前用户权限</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">SHOW</span> GRANTS;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER();<br></code></pre></td></tr></table></figure>

<p>查看某用户的全局权限</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;主机地址&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全 性。MySQL中使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从 db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中 的账户记录使用DROP USER语句）。 </p>
<p>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</p>
<p>收回权限命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">REVOKE</span> 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n <span class="hljs-literal">ON</span> 数据库名称.表名称 FROM 用户名@用户地址;<br></code></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#收回全库全表的所有权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">FROM</span> joe@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br>#收回mysql库下的所有表的插删改查权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> mysql.* <span class="hljs-keyword">FROM</span> joe@localhost;<br></code></pre></td></tr></table></figure>

<p>注意： 须用户重新登录后才能生效</p>
<h2 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h2><p>MySQL服务器通过<code>权限表</code>来控制用户对数据库的访问，权限表存放在<code>my sql数据库</code>中。MySQL数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是<code>user表、db表</code>。除此之外，还有<code>table_priv表</code>、<code>column_priv表</code>和<code>proc_priv表</code>等。在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<h3 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210200.png" alt="image-20220121154742904"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210201.png" alt="image-20220121154629134"></p>
<h3 id="db表"><a href="#db表" class="headerlink" title="db表"></a>db表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210202.png" alt="image-20220123100714323"></p>
<h3 id="tables-priv表和columns-priv表"><a href="#tables-priv表和columns-priv表" class="headerlink" title="tables_priv表和columns_priv表"></a>tables_priv表和columns_priv表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210203.png" alt="image-20220123100703138"></p>
<h3 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210204.png" alt="image-20220121154806757"></p>
<h2 id="访问控制-了解"><a href="#访问控制-了解" class="headerlink" title="访问控制(了解)"></a>访问控制(了解)</h2><p>正常情况下，并不希望每个用户都可以执行所有的数据库操作。当MySQL允许一个用户执行各种操作时，它将首先核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为MySQL中的<code>访问控制过程</code>。MySQL的访问控制分为两个阶段：<code>连接核实阶段</code>和<code>请求核实阶段</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210205.png" alt="image-20220121160707889"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210206.png" alt="image-20220121081848851"></p>
<h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><p>角色是在<code>MySQL 8.0</code>中引入的新功能。在MysQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以拥有授予和撤消的权限。</p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关 重要的。</p>
<h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><p>创建角色使用 CREATE ROLE 语句，语法如下： </p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">CREATE</span> <span class="hljs-symbol">ROLE</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>] [,<span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>]]...<br></code></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为 空。 </p>
<p>练习：我们现在需要创建一个经理的角色，就可以用下面的代码： </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-string">&#x27;manager&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="给角色赋予权限"><a href="#给角色赋予权限" class="headerlink" title="给角色赋予权限"></a>给角色赋予权限</h3><p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>];<br></code></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，图11-43 列出了部分权限列表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">PRIVILEGES</span>\G;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210207.png" alt="image-20220121160914019"></p>
<p>练习1：我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码 来实现：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.settlement <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.goodsmaster <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.invcount <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="查看角色的权限"><a href="#查看角色的权限" class="headerlink" title="查看角色的权限"></a>查看角色的权限</h3><p>赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br><span class="hljs-section">| Grants for manager@% |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br>| GRANT USAGE ON <span class="hljs-strong">*.*</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`goodsmaster`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`invcount`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br><span class="hljs-section">| GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br></code></pre></td></tr></table></figure>

<p><strong>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是 连接登录数据库的权限 。</strong>代码的 最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权 限。 </p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。 </p>
<h3 id="回收角色的权限"><a href="#回收角色的权限" class="headerlink" title="回收角色的权限"></a>回收角色的权限</h3><p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色 授权相同。撤销角色或角色权限使用REVOKE语句。 </p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。 </p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> tablename <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;rolename&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>练习1：撤销school_write角色的权限。 </p>
<p>（1）使用如下语句撤销school_write角色的权限。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> school.* <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后使用SHOW语句查看school_write对应的权限，语句如下。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h3><p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角 色。删除角色的操作很简单，你只要掌握语法结构就行了。 </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">role</span> [,role2]...<br></code></pre></td></tr></table></figure>

<p>注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。 </p>
<p>练习：执行如下SQL删除角色school_read。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">&#x27;school_read</span>&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h3><p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语 法形式如下： </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">GRANT <span class="hljs-keyword">role</span> <span class="hljs-title">[,role2</span>,...] TO <span class="hljs-keyword">user</span> <span class="hljs-title">[,user2</span>,...];<br></code></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。 </p>
<p>练习：给kangshifu用户添加角色school_read权限。 </p>
<p>（1）使用GRANT语句给kangshifu添加school_read权 限，SQL语句如下。 </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（3）使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如 下。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_ROLE</span>();<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210208.png" alt="image-20220121161252761"></p>
<h3 id="激活角色"><a href="#激活角色" class="headerlink" title="激活角色"></a>激活角色</h3><p>方式1：使用set default role 命令激活角色 </p>
<p>举例： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>举例：使用 SET DEFAULT ROLE 为下面4个用户默认激活所有已拥有的角色如下： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span><br><span class="hljs-string">&#x27;dev1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;rw_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方式2：将activate_all_roles_on_login设置为ON </p>
<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| activate_all_roles_on_login | OFF |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>设置：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> GLOBAL <span class="hljs-attribute">activate_all_roles_on_login</span>=ON;<br></code></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有 权限。 </p>
<h3 id="撤销用户的角色"><a href="#撤销用户的角色" class="headerlink" title="撤销用户的角色"></a>撤销用户的角色</h3><p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure>

<p>练习：撤销kangshifu用户的school_read角色。 </p>
<p>（1）撤销的SQL语句如下 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后，执行如下查询语句，查看kangshifu用户的角色信息 执行发现，用户kangshifu之前的school_read角色已被撤销。 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="设置强制角色-mandatory-role"><a href="#设置强制角色-mandatory-role" class="headerlink" title="设置强制角色(mandatory role)"></a>设置强制角色(mandatory role)</h3><p>方式1：服务启动前设置 </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">mandatory_roles</span>=<span class="hljs-string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></code></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PERSIST <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后仍然<br>有效<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后失效<br></code></pre></td></tr></table></figure>



<h1 id="四、逻辑架构"><a href="#四、逻辑架构" class="headerlink" title="四、逻辑架构"></a>四、逻辑架构</h1><h2 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a>逻辑架构剖析</h2><p>首先MySQL是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的mysqld</p>
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示:</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210209.png" alt="image-20220123095116439"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210210.png" alt="image-20220123095127826"></p>
<h3 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a>第1层：连接层</h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是<code>建立 TCP 连接</code>。 </p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码<code>做身份认证、权限获取</code>。 </p>
<ul>
<li><p>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</p>
</li>
<li><p>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限 </p>
</li>
</ul>
<p>TCP 连接收到请求后，必须要<code>分配给一个线程专门与这个客户端的交互</code>。所以还会有个<code>线程池</code>，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h3 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a>第2层：服务层</h3><p>SQL Interface: SQL接口 </p>
<p><strong>接收用户的SQL命令，并且返回用户需要查询的结果。</strong>比如SELECT … FROM就是调用SQL Interface </p>
<p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口 </p>
<p>Parser: 解析器</p>
<p><strong>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤</strong>，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。 </p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其<strong>创建 语法树</strong> ，并根据数据字 典丰富查询语法树，会 <strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还 会对SQl查询进行<strong>语法上的优化，进行查询重写。</strong> </p>
<p>Optimizer: 查询优化器</p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 <strong>执行计划</strong> 。</p>
<p>这个执行计划表明应该 <strong>使用哪些索引</strong> 进行查询（全表检索还是使用索引检索），<strong>表之间的连 接顺序如何</strong>，最后会<strong>按照执行计划中的步骤调用存储引擎提供的方法</strong>来真正的执行查询，并将 查询结果返回给用户。 </p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> id,<span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> gender = <span class="hljs-string">&#x27;女&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 <strong>投影</strong> ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 <strong>连接</strong> 起来生成最终查询结果。</p>
<p>Caches &amp; Buffers： 查询缓存组件</p>
<p>MySQL内部维持着一些<strong>Cache和Buffer</strong>，比如Query Cache用来缓存一条SELECT语句的执行结 果，<strong>如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</strong> </p>
<p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 </p>
<p>这个查询缓存可以在 <strong>不同客户端之间共享</strong> 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</p>
<h3 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a>第3层：引擎层</h3><p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<code>插件式的存储引擎</code>架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MysQL还允许<code>开发人员设置自己的存储引擎</code>。</p>
<p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况）的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p>
<p><strong>插件式存储引擎层</strong>（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取</strong>，对物理服务器级别 维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。 </p>
<p>MySQL 8.0.25默认支持的存储引擎如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210211.png" alt="image-20220123100149104"></p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 <strong>文件系统</strong> 上，以 <strong>文件</strong> 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210212.png" alt="image-20220123100313025"></p>
<p>简化为三层结构： </p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； </li>
<li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关； </li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><h3 id="MySQL中的SQL执行流程"><a href="#MySQL中的SQL执行流程" class="headerlink" title="MySQL中的SQL执行流程"></a>MySQL中的SQL执行流程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210213.png" alt="image-20220123100934027"></p>
<p>MySQL的查询流程：</p>
<p>1、查询缓存：</p>
<p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能。 </p>
<p>大多数情况查询缓存就是个鸡肋，为什么呢？ </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> employee_id,last_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> employee_id = <span class="hljs-number">101</span>;<br></code></pre></td></tr></table></figure>

<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，<code>不是缓存查询计划，而是查询对应的结果。</code>这就意味着查询匹配的 <code>鲁棒性大大降 低 </code>，只有 <code>相同的查询操作</code>才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、 大小写），都会<code>导致缓存不会命中</code>。因此 MySQL 的 查询缓存命中率不高 。 </p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数 举例，<code>可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW</code> ，每次调用都会产生最新的当前 时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的！ </p>
<p>此外，既然是缓存，那就有它 <code>缓存失效的时候</code> 。MySQL的缓存系统会监测涉及到的每张表，只要该表的 结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高 速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。</p>
<p>2、解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210214.png" alt="image-20220123101152349"></p>
<p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> department_id,job_id,<span class="hljs-keyword">avg</span>(salary) <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> department_id;<br></code></pre></td></tr></table></figure>

<p>如果SQL语句正确，则会生成一个这样的语法树：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210215.png" alt="image-20220123101255802"></p>
<p>3、优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。 </p>
<p>举例：如下语句是执行两个表的 join：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test1 <span class="hljs-keyword">join</span> test2 <span class="hljs-keyword">using</span>(ID)<br><span class="hljs-keyword">where</span> test1.name=<span class="hljs-string">&#x27;zhangwei&#x27;</span> <span class="hljs-keyword">and</span> test2.name=<span class="hljs-string">&#x27;mysql高级课程&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方案1：可以先从表 test1 里面取出 name=’zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 ‘mysql高级课程’。 </p>
<p>方案2：可以先从表 test2 里面取出 name=’mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。 </p>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化 器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 </p>
<p>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p>
<p>在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210216.png" alt="image-20220121091908948"></p>
<p>4、执行器： </p>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210217.png" alt="image-20220123101409028"></p>
<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；<br><br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br><br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。<br></code></pre></td></tr></table></figure>



<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。 SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210218.png" alt="image-20220123101456214"></p>
<h3 id="MySQL8中SQL执行原理"><a href="#MySQL8中SQL执行原理" class="headerlink" title="MySQL8中SQL执行原理"></a>MySQL8中SQL执行原理</h3><p>前面的结构图很复杂，我们需要抓取最核心的部分: SQL的执行原理。不同的DBMS的sQL的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条SQL语句会经历不同的模块，那我们就来看下，在不同的模块中，SQL执行所使用的资源（时间)是怎样的。如何在 MysQL中对一条sQL语句的执行时间进行分析。</p>
<p>了解查询语句底层执行的过程: <code>select @@profiling;</code> 或者 <code>show variables like ‘%profiling%&#39;</code> 查看是否开启计划。开启它可以让MySQL收集在SQL执行时所使用的资源情况，命令如下:</p>
<p>1、确认profiling 是否开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@profiling</span>; <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;profiling&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210219.png" alt="image-20220123101555370"></p>
<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>2、多次执行相同SQL查询 </p>
<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employees;<br></code></pre></td></tr></table></figure>

<p>3、查看profiles </p>
<p>查看当前会话所产生的所有 profiles：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">mysql&gt; <span class="hljs-keyword">show</span> profiles; <span class="hljs-meta"># 显示最近的几次查询</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210220.png" alt="image-20220123101707949"></p>
<p>4、查看profile</p>
<p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210221.png" alt="image-20220123101731882"></p>
<p>当然你也可以查询指定的 Query ID，比如： </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">mysql&gt; <span class="hljs-keyword">show </span>profile<span class="hljs-comment">; mysql&gt; show profile for query 7;</span><br></code></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。 </p>
<p>此外，还可以查询更丰富的内容： </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210222.png" alt="image-20220123101814969"></p>
<p>继续：  </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210223.png" alt="image-20220123101830053"></p>
<h3 id="MySQL5-7中SQL执行原理"><a href="#MySQL5-7中SQL执行原理" class="headerlink" title="MySQL5.7中SQL执行原理"></a>MySQL5.7中SQL执行原理</h3><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用 缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置： </p>
<p>1、配置文件中开启查询缓存 </p>
<p>在 /etc/my.cnf 中新增一行：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>重启mysql服务 </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart mysqld</span><br></code></pre></td></tr></table></figure>

<p>3、开启查询执行计划 </p>
<p>由于重启过服务，需要重新执行如下指令，开启profiling。 </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>4、执行语句两次： </p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br></code></pre></td></tr></table></figure>

<p>5、查看profiles</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210224.png" alt="image-20220123102149177"></p>
<p>6、查看profile </p>
<p>显示执行计划，查看程序的执行步骤：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210225.png" alt="image-20220123102228217"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile for query <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210226.png" alt="image-20220123102256808"></p>
<p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中 获取数据。 </p>
<h3 id="SQL语法顺序"><a href="#SQL语法顺序" class="headerlink" title="SQL语法顺序"></a>SQL语法顺序</h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同 而动态调整执行顺序。 </p>
<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 下面是经常出现的查询顺序：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210227.png" alt="image-20220123102323930"></p>
<h3 id="Oracle中的SQL执行流程-了解"><a href="#Oracle中的SQL执行流程-了解" class="headerlink" title="Oracle中的SQL执行流程(了解)"></a>Oracle中的SQL执行流程(了解)</h3><p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用 硬解析还是软解析。 </p>
<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210228.png" alt="image-20220123102353539"></p>
<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。 </p>
<p>1.语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。 </p>
<p>2.语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统 就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。 </p>
<p>3.权限检查：看用户是否具备访问该数据的权限。</p>
<p>4.共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计 划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析 和硬解析又该怎么理解呢？ </p>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中 查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。 </p>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器” 这个步骤，这就是 硬解析 。 </p>
<p>5.优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。 </p>
<p>6.执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执 行语句了。</p>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要 缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对 象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。 </p>
<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量 避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。 </p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量 就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解 析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况 而定。 </p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br></code></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> :player_id;<br></code></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变 量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。 </p>
<p>因此，我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点， 使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。 </p>
<p>Oracle的架构图：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210229.png" alt="image-20220123102535032"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210230.png" alt="image-20220123102542352"></p>
<p>小结： </p>
<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享 池来判断是进行软解析，还是硬解析。</p>
<h2 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池(buffer pool)"></a>数据库缓冲池(buffer pool)</h2><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访 问。 </p>
<p>这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="缓冲池-vs-查询缓存"><a href="#缓冲池-vs-查询缓存" class="headerlink" title="缓冲池 vs 查询缓存"></a>缓冲池 vs 查询缓存</h3><p>缓冲池和查询缓存是一个东西吗？不是。 </p>
<h4 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h4><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。 </p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种 数据的缓存，如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210231.png" alt="image-20220123102701116"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典 信息等。 </p>
<p><strong>缓存池的重要性：</strong> </p>
<p><strong>缓存原则：</strong> </p>
<p>“ 位置 * 频次 ”这个原则，可以帮我们对 I/O 访问效率进行优化。 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲 池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。 </p>
<p><strong>缓冲池的预读特性：</strong></p>
<p>了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<code>预读</code>。</p>
<p>缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<code>大概率还会使用它周围的一些数据</code>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p>
<p><strong>如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?</strong></p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<code>以一定的频率刷新</code>到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做<code>checkpoint</code>的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirty page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>那么什么是查询缓存呢？ </p>
<p>查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。 </p>
<h3 id="什么时候使用查询缓存"><a href="#什么时候使用查询缓存" class="headerlink" title="什么时候使用查询缓存"></a>什么时候使用查询缓存</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210232.png" alt="image-20220121090932464"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210233.png" alt="image-20220123103753070"></p>
<h3 id="缓冲池如何读取数据"><a href="#缓冲池如何读取数据" class="headerlink" title="缓冲池如何读取数据"></a>缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进 行读取。 </p>
<p>缓存在数据库中的结构和作用如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210234.png" alt="image-20220123102818823"></p>
<h3 id="查看-设置缓冲池的大小"><a href="#查看-设置缓冲池的大小" class="headerlink" title="查看/设置缓冲池的大小"></a>查看/设置缓冲池的大小</h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大 小。命令如下： </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_size&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210235.png" alt="image-20220123102902971"></p>
<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">set global innodb_buffer_pool_size <span class="hljs-operator">=</span> <span class="hljs-number">268435456</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210236.png" alt="image-20220123102927306"></p>
<p>或者： </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">268435456</span><br></code></pre></td></tr></table></figure>

<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210237.png" alt="image-20220123102947321"></p>
<h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>Buffer Pool本质是InnoDB向操作系统申请的一块<code>连续的内存空间</code>，在多线程环境下，访问Buffer Pool中的数据都需要<code>加锁</code>处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<code>拆分成若干个小的Buffer Pool</code>，每个Buffer Pool都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code>的值来修改Buffer Pool实例的个数，比方说这样:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_instances</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p> 这样就表明我们要创建2个 Buffer Pool 实例。 </p>
<p>我们看下如何查看缓冲池的个数，使用命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_instances&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210238.png" alt="image-20220123103042487"></p>
<p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<h3 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>
<p>黑盒下的更新数据流程</p>
<p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于BufferPool，同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MysQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MysQL宕机了，这部分数据将会永久地丢失;</p>
<p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办?连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复?</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210239.png" alt="image-20220123103120290"></p>
<h1 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h1><h2 id="存储引擎先关配置"><a href="#存储引擎先关配置" class="headerlink" title="存储引擎先关配置"></a>存储引擎先关配置</h2><p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为MysQL server的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。所以在MySQL server完成了<code>查询优化</code>后，只需按照生成的<code>执行计划</code>调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MySQL中提到了存储引擎的概念。简而言之，<code>存储引擎就是指表的类型</code>。其实存储引擎以前叫做<code>表处理器</code>，后来改名为存储引擎，它的功能就是<code>接收上层传下来的指令</code>，<code>然后对表中的数据进行提取或写入操作</code>。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><p>查看mysql提供什么存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">show engines<span class="hljs-comment">;</span><br>show engines \G<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>引擎、是否支持、描述、事务、分布式事务、savepointer</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210240.png" alt="image-20220123104311188"></p>
<p>显式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: InnoDB<br>Support: DEFAULT<br>Comment: Supports transactions, row-level locking, and foreign keys<br>Transactions: YES<br>XA: YES<br>Savepoints: YES<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 2. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: MRG<span class="hljs-emphasis">_MYISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Collection of identical MyISAM tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 3. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MEMORY</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Hash based, stored in memory, useful for temporary tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 4. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: BLACKHOLE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: /dev/null storage engine (anything you write to it disappears)</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">2. 设置系统默认的存储引擎</span><br><span class="hljs-emphasis">查看默认的存储引擎：</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 5. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MyISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: MyISAM storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 6. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: CSV</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: CSV storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 7. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: ARCHIVE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Archive storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 8. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: PERFORMANCE_</span>SCHEMA<br>Support: YES<br>Comment: Performance Schema<br>Transactions: NO<br>XA: NO<br>Savepoints: NO<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 9. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: FEDERATED<br>Support: NO<br>Comment: Federated MySQL storage engine<br>Transactions: NULL<br>XA: NULL<br>Savepoints: NULL<br></code></pre></td></tr></table></figure>

<h3 id="设置系统默认的存储引擎"><a href="#设置系统默认的存储引擎" class="headerlink" title="设置系统默认的存储引擎"></a>设置系统默认的存储引擎</h3><p>查看默认的存储引擎：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">show</span> variables like <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br><span class="hljs-comment">#或</span><br><span class="hljs-attribute">SELECT</span> @<span class="hljs-variable">@default_storage_engine</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210241.png" alt="image-20220123104407947"></p>
<p>修改默认的存储引擎 </p>
<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">DEFAULT_STORAGE_ENGINE</span>=MyISAM;<br></code></pre></td></tr></table></figure>

<p>或者修改 my.cnf 文件：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=MyISAM<br># 重启服务<br>systemctl <span class="hljs-keyword">restart</span> mysqld.service<br></code></pre></td></tr></table></figure>

<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式。 </p>
<h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">CREATE TABLE 表名(<br>建表语句<span class="hljs-comment">;</span><br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h3><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">ALTER TABLE 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>比如我们修改一下 engine_demo_table 表的存储引擎： </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span> Duplicates: <span class="hljs-number">0</span> Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>这时我们再查看一下 engine_demo_table 的表结构：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">mysql&gt; SHOW CREATE TABLE engine<span class="hljs-emphasis">_demo_</span>table\G<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Table: engine<span class="hljs-emphasis">_demo_</span>table<br>Create Table: CREATE TABLE <span class="hljs-code">`engine_demo_table`</span> (<br><span class="hljs-code">`i`</span> int(11) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>

<h2 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h2><h3 id="InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>InnoDB 引擎：具备外键支持功能的事务存储引擎</h3><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 </p>
<p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务 的完整提交(Commit)和回滚(Rollback)。 </p>
<p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 </p>
<p>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） </p>
</li>
<li><p>表名.ibd 存储数据和索引 </p>
</li>
</ul>
<p>InnoDB是 为处理巨大数据量的最大性能设计 。 </p>
<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。 </li>
</ul>
<p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和 索引。 </p>
<p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p>
<h3 id="MyISAM-引擎：主要的非事务处理存储引擎"><a href="#MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="MyISAM 引擎：主要的非事务处理存储引擎"></a>MyISAM 引擎：主要的非事务处理存储引擎</h3><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 </p>
<p>5.5之前默认的存储引擎 </p>
<p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用 </p>
<p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构 </p>
</li>
<li><p>表名.MYD 存储数据 (MYData) </p>
</li>
<li><p>表名.MYI 存储索引 (MYIndex) </p>
</li>
</ul>
<p>应用场景：只读应用或者以读为主的业务</p>
<h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210242.png" alt="image-20220121102140263"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210243.png" alt="image-20220123105832462"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210244.png" alt="image-20220121102353775"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210245.png" alt="image-20220121103116264"></p>
<h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p>
<p>其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功 能。 </p>
<p>其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存 储引擎。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210246.png" alt="image-20220123110038734"></p>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？ </p>
<p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210247.png" alt="image-20220123110144759"></p>
<h3 id="阿里巴巴、淘宝用哪个"><a href="#阿里巴巴、淘宝用哪个" class="headerlink" title=".阿里巴巴、淘宝用哪个"></a>.阿里巴巴、淘宝用哪个</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210248.png" alt="image-20220123110239707"></p>
<p>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。 </p>
<p>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外 有更多的参数和命令来控制服务器行为。 </p>
<p>该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好 </p>
<p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p>
<h2 id="课外补充："><a href="#课外补充：" class="headerlink" title="课外补充："></a>课外补充：</h2><h3 id="1、InnoDB表的优势"><a href="#1、InnoDB表的优势" class="headerlink" title="1、InnoDB表的优势"></a>1、InnoDB表的优势</h3><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如<code>操作便利、提高了数据库的性能、维护成本低</code>等。如 果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。<code>InnoDB崩溃 恢复功能</code>自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。 </p>
<p>InnoDB存储引擎在主内存中<code>维护缓冲池</code>，高频率使用的数据将在内存中直接被处理。这种缓存方式应用 于多种信息，加速了处理进程。 </p>
<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以 设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插 入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃， 在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被 自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 <code>InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘</code> 。 </p>
<p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高 查询的速度。使用InnoDB可以压缩表和相关的索引，可以 <code>在不影响性能和可用性的情况下创建或删除索 引 </code>。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他 存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 <code>当处理大数据量时， InnoDB兼顾CPU，以达到最大性能</code> 。 </p>
<h3 id="2、InnoDB和ACID模型"><a href="#2、InnoDB和ACID模型" class="headerlink" title="2、InnoDB和ACID模型"></a>2、InnoDB和ACID模型</h3><p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应 用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不 会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的 软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只 依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p>
<p>1、原子方面 </p>
<p>ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>COMMIT语句。 </p>
<p>ROLLBACK语句。 </p>
<p>操作INFORMATION_SCHEMA库中的表数据。 </p>
<p>2、一致性方面 </p>
<p>ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性 主要包括： </p>
<p>InnoDB双写缓存。 </p>
<p>InnoDB崩溃恢复。 </p>
<p>3、隔离方面 </p>
<p>隔离是应用于事务的级别，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>SET ISOLATION LEVEL语句。 </p>
<p>InnoDB锁的低级别信息。 </p>
<p>4、耐久性方面 </p>
<p>ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样 化，耐久性方面没有具体的规则可循。与MySQL相关的特性有： </p>
<p>InnoDB双写缓存，通过innodb_doublewrite配置项配置。 </p>
<p>配置项innodb_flush_log_at_trx_commit。 </p>
<p>配置项sync_binlog。 </p>
<p>配置项innodb_file_per_table。 </p>
<p>存储设备的写入缓存。 </p>
<p>存储设备的备用电池缓存。 </p>
<p>运行MySQL的操作系统。 </p>
<p>持续的电力供应。 </p>
<p>备份策略。 </p>
<p>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</p>
<h3 id="3、InnoDB架构"><a href="#3、InnoDB架构" class="headerlink" title="3、InnoDB架构"></a>3、InnoDB架构</h3><p><strong>1.缓冲池</strong> </p>
<p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的 数据能够直接在内存中获得，从而提高速度。 </p>
<p><strong>2.更改缓存</strong> </p>
<p>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索 引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索 引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。 在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管 理。 </p>
<p><strong>3.自适应哈希索引</strong></p>
<p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行， 不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。 </p>
<p><strong>4.重做日志缓存</strong> </p>
<p>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。 </p>
<p><strong>5.系统表空间</strong> </p>
<p>系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引 数据。多表共享，系统表空间被视为共享表空间。 </p>
<p><strong>6.双写缓存</strong></p>
<p>双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存 后，InnoDB才会将数据页写入合适的位置。 </p>
<p><strong>7.撤销日志</strong> </p>
<p>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他 事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这 些片段包含于回滚片段中。 </p>
<p><strong>8.每个表一个文件的表空间</strong> </p>
<p>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数 据文件代表，该文件默认被创建在数据库目录中。 </p>
<p><strong>9.通用表空间</strong> </p>
<p>使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数 据目录之外能够管理多个表并支持所有行格式的表。 </p>
<p><strong>10.撤销表空间</strong> </p>
<p>撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces配置项配置。 </p>
<p><strong>11.临时表空间</strong></p>
<p>用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。 </p>
<p><strong>12.重做日志</strong></p>
<p>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自 动在初始化期间重新进行。</p>
<h1 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h1><h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找相关数据</code>，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个<code>索引的数据结构</code>，即这个二叉搜索树。二叉搜索树的每个结点存储的是<code>（K，V) 结构</code>，key是Col2，value是该<code>key 所在行的文件指针(地址)</code>。比如：该二叉搜索树的根节点就是（34，0x07）。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34；继续右侧数据，读89到内存，89 == 89；找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了<code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210249.png" alt="image-20220123195051911"></p>
<p><code>索引是在存储引擎中实现的</code>，因此<code>每种存储引擎的索引不一定完全相同</code>，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。所有存储引擎支持每个表<code>至少16个索引</code>，总索引长度<code>至少为256字节</code>。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<p>提示：</p>
<p>索引可以提高查询的速度，但是<code>会影响插入记录的速度</code>。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
<h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong> </p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。 </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主 要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<p> （1）创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加。</p>
<p> （2）索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 </p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<h2 id="Innode中的索引"><a href="#Innode中的索引" class="headerlink" title="Innode中的索引"></a>Innode中的索引</h2><h3 id="目录项记录页的目录页"><a href="#目录项记录页的目录页" class="headerlink" title="目录项记录页的目录页"></a>目录项记录页的目录页</h3><p>树的层次越低，加载的 页越少（页读取到内存之后，使用二分进一步查找），IO次数越少</p>
<p>一个数据页，默认 16kb</p>
<p>B+ 树：叶子节点之间用双向链表，非叶子节点之间单向链表</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210250.png" alt="image-20220123195650125"></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么： </p>
<p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。 </p>
<p>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 </p>
<p>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记 录！！！ </p>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们 通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又 因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。</p>
<h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。 </p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>（所有的用户记录都存储在了叶子节点)，也就是所谓的<code>索引即数据，数据即索引</code>。</p>
<p>术语”聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内 的记录是按照主键的大小顺序排成一个 单向链表 。 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MysQL语句中显式的使用INDEX语句去创建，<code>InnoDB</code>存储引擎会<code>自动</code>的为我们创建聚簇索引。</p>
<p><strong>特点：</strong> </p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<p>页内 的记录是按照主键的大小顺序排成一个 单向链表 。 </p>
<p>各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 </p>
<p>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p>
<p><strong>优点：</strong> </p>
<p>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 </p>
<p>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 </p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。 </p>
<p><strong>缺点：</strong> </p>
<p>1、插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 </p>
<p>2、更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新 </p>
<p>3、二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据 </p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<p><strong>限制：</strong></p>
<p>1、对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。</p>
<p>2、由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>3、如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。|</p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><blockquote>
<p>二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。</p>
</blockquote>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210251.png" alt="image-20220123091747335"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210252.png" alt="image-20220123091441479"></p>
<p><strong>概念：回表</strong> </p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！ </p>
<p><strong>问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</strong></p>
<p><strong>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</strong></p>
<p>1、聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</p>
<p>2、一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</p>
<p>3、使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<p>1、先把各个记录和页按照c2列进行排序。 </p>
<p>2、在记录的c2列相同的情况下，采用c3列进行排序</p>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p>
<p>1、建立 联合索引 只会建立如上图一样的1棵B+树。 </p>
<p>2、为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210253.png" alt="image-20220123094039750"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210254.png" alt="image-20220123094343764"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210255.png" alt="image-20220123094446434"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210256.png" alt="image-20220123094744274"></p>
<h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根页面位置万年不动"><a href="#根页面位置万年不动" class="headerlink" title="根页面位置万年不动"></a>根页面位置万年不动</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210257.png" alt="image-20220123202403635"></p>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210258.png" alt="image-20220123202445109"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210259.png" alt="image-20220123202455155"></p>
<h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210300.png" alt="image-20220123202415852"></p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>B树索引适用存储引擎如表所示： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210301.png" alt="image-20220123202552912"></p>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。</p>
<p>Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。 </p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，<strong>叶子节点的data域存放的是 数据记录的地址 。</strong></p>
<h3 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210302.png" alt="image-20220123202626492"></p>
<p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210303.png" alt="image-20220123202831722"></p>
<h3 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区 别：</strong> </p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。 </p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。 </p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。 </p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： </p>
<p><strong>空间上的代价</strong> </p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。 </p>
<p><strong>时间上的代价</strong> </p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h2><p>从MysQL的角度讲，不得不考虑一个现实问题就是磁盘I0。如果我们能让索引的数据结构尽量<code>减少硬盘的I/O操作</code>，所消耗的时间也就越小。可以说，磁盘的I/O操作次数对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘上的。</strong>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MysQL衡量查询效率的标准就是磁盘I/O次数。</p>
<h3 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h3><p>略</p>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210304.png" alt="image-20220123203956171"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210305.png" alt="image-20220123204007505"></p>
<h3 id="自适应式哈希"><a href="#自适应式哈希" class="headerlink" title="自适应式哈希"></a>自适应式哈希</h3><p>InnoDB会监控对表上各索引页的查询，如果观察该数据被访问的频次符合规则，那么就建立哈希索引来加快数据访问的速度，这个哈希索引称之为”<strong>Adaptive Hash Index,AHI</strong>“,AHI是通过缓冲池的B+树页构建的，建立的速度很快，而且不对整颗树都建立哈希索引。(可以理解成热点的数据才会进入这个哈希表)</p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。 </p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如： </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">mysql&gt; show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%adaptive_hash_index&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210306.png" alt="image-20220123203315740"></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210307.png" alt="image-20220123204105287"></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210308.png" alt="image-20220123204147288"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210309.png" alt="image-20220123204206739"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210310.png" alt="image-20220123204216682"></p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210311.png" alt="image-20220123204230149"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210312.png" alt="image-20220123204313188"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210313.png" alt="image-20220123204325576"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210314.png" alt="image-20220123204335710"></p>
<h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210315.png" alt="image-20220123204353865"></p>
<h2 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h2><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210316.png" alt="image-20220123204424866"></p>
<h1 id="七、InnoDB数据存储结构"><a href="#七、InnoDB数据存储结构" class="headerlink" title="七、InnoDB数据存储结构"></a>七、InnoDB数据存储结构</h1><h2 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p>
<h3 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210317.png" alt="image-20220123171731077"></p>
<h3 id="页结构概述-页的大小"><a href="#页结构概述-页的大小" class="headerlink" title="页结构概述/页的大小"></a>页结构概述/页的大小</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210318.png" alt="image-20220123171810345"></p>
<h3 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210319.png" alt="image-20220123171900691"></p>
<h2 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210320.png" alt="image-20220123171932421"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210321.png" alt="image-20220123172018972"></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="FileHeader（文件头部）"><a href="#FileHeader（文件头部）" class="headerlink" title="FileHeader（文件头部）"></a>FileHeader（文件头部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210322.png" alt="image-20220123172224825"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210323.png" alt="image-20220123172540410"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210324.png" alt="image-20220123172556371"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210325.png" alt="image-20220123172609036"></p>
<h4 id="File-Trailer（文件尾部）"><a href="#File-Trailer（文件尾部）" class="headerlink" title="File Trailer（文件尾部）"></a>File Trailer（文件尾部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210326.png" alt="image-20220123172719823"></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210327.png" alt="image-20220123172831136"></p>
<h4 id="FreeSpace（空闲空间）"><a href="#FreeSpace（空闲空间）" class="headerlink" title="FreeSpace（空闲空间）"></a>FreeSpace（空闲空间）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210328.png" alt="image-20220123172859640"></p>
<h4 id="UserRecords（用户记录）"><a href="#UserRecords（用户记录）" class="headerlink" title="UserRecords（用户记录）"></a>UserRecords（用户记录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210329.png" alt="image-20220123172911774"></p>
<h4 id="Infimum-Supremum（最小最大记录）"><a href="#Infimum-Supremum（最小最大记录）" class="headerlink" title="Infimum+Supremum（最小最大记录）"></a>Infimum+Supremum（最小最大记录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210330.png" alt="image-20220123172946473"></p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><h4 id="PageDirectory（页目录）"><a href="#PageDirectory（页目录）" class="headerlink" title="PageDirectory（页目录）"></a>PageDirectory（页目录）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210331.png" alt="image-20220123173407883"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210332.png" alt="image-20220123173452062"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210333.png" alt="image-20220123173512149"></p>
<h5 id="页目录分组的个数如何确定"><a href="#页目录分组的个数如何确定" class="headerlink" title="页目录分组的个数如何确定?"></a>页目录分组的个数如何确定?</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210334.png" alt="image-20220123173533141"></p>
<h5 id="页目录结构下如何快速查找记录"><a href="#页目录结构下如何快速查找记录" class="headerlink" title="页目录结构下如何快速查找记录?"></a>页目录结构下如何快速查找记录?</h5><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210335.png" alt="image-20220123173658766"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210336.png" alt="image-20220123173707547"></p>
<h4 id="PageHeader（页面头部）"><a href="#PageHeader（页面头部）" class="headerlink" title="PageHeader（页面头部）"></a>PageHeader（页面头部）</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210337.png" alt="image-20220123173858788"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210338.png" alt="image-20220123173940900"></p>
<h2 id="InnoDB行格式（或记录格式）"><a href="#InnoDB行格式（或记录格式）" class="headerlink" title="InnoDB行格式（或记录格式）"></a>InnoDB行格式（或记录格式）</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210339.png" alt="image-20220123174014918"></p>
<h1 id="八、索引的创建与设计原则"><a href="#八、索引的创建与设计原则" class="headerlink" title="八、索引的创建与设计原则"></a>八、索引的创建与设计原则</h1><h2 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a>索引的声明与使用</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 </p>
<p>从 <code>功能逻辑</code> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p>
<p>按照 <code>物理实现方式</code> ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p>
<p>按照 <code>作用字段个数</code> 进行划分，分成单列索引和联合索引。</p>
<p>1.普通索引</p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表<br>student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p>2.唯一性索引</p>
<p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯—量可以更快速地确定某条记录。</p>
<p>3.主键索引</p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE 一张表里最多只有一个主键索引。</p>
<p>Why?这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p>4.单列索引</p>
<p>在表中的单个字段上创建索引。单列索引央根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<p>5.多列(组合、联合)索引</p>
<p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<p>6.全文索引</p>
<p>全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。</p>
<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、ElasticSearch等专门的搜索引擎所替代。</p>
<p>7.补充：空间索引</p>
<p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p>小结：不同的存储引擎支持的索引类型也不一样</p>
<p>nnoDB：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>MylSAM：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>Memory：支持B-tree、Hash等索引，不支持Full-text索引;</p>
<p>NDB：支持Hash索引，不支持 B-tree、Full-text等索引;</p>
<p>Archive：不支持B-tree、Hash、Full-text等索引;</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span>,<br>dept_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> emp_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY(dept_id) <span class="hljs-keyword">REFERENCES</span> dept(dept_id)<br>);<br></code></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name [col_name data_type]<br>[<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY] [index_name] (col_name [length]) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span><br><span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </p>
<p>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </p>
<p>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </p>
<p>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </p>
<p>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </p>
<p>ASC 或 DESC 指定升序或者降序的索引值存储。 </p>
<h5 id="1-创建普通索引"><a href="#1-创建普通索引" class="headerlink" title="1.创建普通索引"></a>1.创建普通索引</h5><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> book(<br>book_id <span class="hljs-type">INT</span> ,<br>book_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>authors <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) ,<br>comment <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>year_publication <span class="hljs-keyword">YEAR</span>,<br>INDEX(year_publication)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="2-创建唯一索引"><a href="#2-创建唯一索引" class="headerlink" title="2.创建唯一索引"></a>2.创建唯一索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test1(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX uk_idx_id(id)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> test1 \G<br></code></pre></td></tr></table></figure>

<h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法： </p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT ,<br>student_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>student_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY(id)<br>);<br></code></pre></td></tr></table></figure>

<p>删除主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">PRIMARY</span> KEY ;<br></code></pre></td></tr></table></figure>

<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引 </p>
<h5 id="4-创建单列索引"><a href="#4-创建单列索引" class="headerlink" title="4.创建单列索引"></a>4.创建单列索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test2(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span>,<br>INDEX single_idx_name(name(<span class="hljs-number">20</span>))<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test2 \G<br></code></pre></td></tr></table></figure>

<h5 id="5-创建组合索引"><a href="#5-创建组合索引" class="headerlink" title="5.创建组合索引"></a>5.创建组合索引</h5><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test3(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>INDEX multi_idx(id,name,age)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW INDEX 查看： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test3 \G<br></code></pre></td></tr></table></figure>

<h5 id="6-创建全文索引"><a href="#6-创建全文索引" class="headerlink" title="6.创建全文索引"></a>6.创建全文索引</h5><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test4(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>FULLTEXT INDEX futxt_idx_info(info)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
<p>举例2： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> articles (<br>id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>title <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">200</span>),<br>body TEXT,<br>FULLTEXT index (title, body)<br>) ENGINE <span class="hljs-operator">=</span> INNODB ;<br></code></pre></td></tr></table></figure>

<p>创建了一个给title和body字段添加全文索引的表。 </p>
<p>举例3：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `papers` (<br>`id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`title` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>FULLTEXT KEY `title` (`title`,`content`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure>

<p>不同于like方式的的查询： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> content <span class="hljs-keyword">LIKE</span> ‘<span class="hljs-operator">%</span>查询字符串<span class="hljs-operator">%</span>’;<br></code></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);<br></code></pre></td></tr></table></figure>

<p><strong>注意点</strong> </p>
<p>1.使用全文索引前，搞清楚版本支持情况； </p>
<p>2.全文索引比 like + % 快 N 倍，但是可能存在精度问题； </p>
<p>3.如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</p>
<h5 id="7-创建空间索引"><a href="#7-创建空间索引" class="headerlink" title="7.创建空间索引"></a>7.创建空间索引</h5><p>空间索引创建中，要求空间类型的字段必须为 <code>非空 </code>。 </p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test5(<br>geo GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>SPATIAL INDEX spa_idx_geo(geo)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<h4 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。 </p>
<p><strong>1.使用ALTER TABLE语句创建索引</strong> </p>
<p>ALTER TABLE语句创建索引的基本语法如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY]<br>[index_name] (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p><strong>2.使用CREATE INDEX创建索引</strong> </p>
<p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><strong>1.使用ALTER TABLE删除索引</strong> </p>
<p>ALTER TABLE删除索引的基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure>

<p><strong>2.使用DROP INDEX语句删除索引</strong> </p>
<p>DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>

<p>提示：</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成 索引的所有列都被删除，则整个索引将被删除。</p>
<h2 id="MySQL8索引新特性"><a href="#MySQL8索引新特性" class="headerlink" title="MySQL8索引新特性"></a>MySQL8索引新特性</h2><h3 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h3><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ts1(a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span>,index idx_a_b(a,b <span class="hljs-keyword">desc</span>));<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210340.png" alt="image-20220124093009807"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210341.png" alt="image-20220124093056738"></p>
<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。 </p>
<blockquote>
<p>提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员 可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。 </p>
</blockquote>
<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用 Using filesort。 </p>
<blockquote>
<p>注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述 查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。 </p>
</blockquote>
<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本 中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a <span class="hljs-keyword">DESC</span>,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>在MySQL 8.0版本中查看数据表ts1的执行计划。 </p>
<p>从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210342.png" alt="image-20220124092321533"></p>
<h1 id="十三、事务基础知识"><a href="#十三、事务基础知识" class="headerlink" title="十三、事务基础知识"></a>十三、事务基础知识</h1><h2 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持<code>一致性</code>，同时我们还能通过事务的机制<code>恢复到某个时间点</code>，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h3 id="存储引擎支持情况"><a href="#存储引擎支持情况" class="headerlink" title="存储引擎支持情况"></a>存储引擎支持情况</h3><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。 </p>
<p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210343.png" alt="image-20220125165016772"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。 </p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210344.png" alt="image-20220125165049411"></p>
<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><h4 id="原子性（atomicity）："><a href="#原子性（atomicity）：" class="headerlink" title="原子性（atomicity）："></a>原子性（atomicity）：</h4><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 </p>
<h4 id="一致性（consistency）："><a href="#一致性（consistency）：" class="headerlink" title="一致性（consistency）："></a>一致性（consistency）：</h4><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述） </p>
<p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态 是 语义上 的而不是语法上的，跟具体的业务有关。 </p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己 来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。 </p>
<p>举例1：A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;=0。</p>
<p>举例2：A账户2o0元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。</p>
<p>举例3：在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</p>
<h4 id="隔离型（isolation）："><a href="#隔离型（isolation）：" class="headerlink" title="隔离型（isolation）："></a>隔离型（isolation）：</h4><p>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 </p>
<p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210345.png" alt="image-20220125165436801"></p>
<h4 id="持久性（durability）："><a href="#持久性（durability）：" class="headerlink" title="持久性（durability）："></a>持久性（durability）：</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。 </p>
<p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 事务 大致划分成几个状态： </p>
<h4 id="活动的（active）"><a href="#活动的（active）" class="headerlink" title="活动的（active）"></a>活动的（active）</h4><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。 </p>
<h4 id="部分提交的（partially-committed）"><a href="#部分提交的（partially-committed）" class="headerlink" title="部分提交的（partially committed）"></a>部分提交的（partially committed）</h4><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘 时，我们就说该事务处在 部分提交的 状态。 </p>
<h4 id="失败的（failed）"><a href="#失败的（failed）" class="headerlink" title="失败的（failed）"></a>失败的（failed）</h4><p>当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。 </p>
<h4 id="中止的（aborted）"><a href="#中止的（aborted）" class="headerlink" title="中止的（aborted）"></a>中止的（aborted）</h4><p>如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称 之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 中止的 状态。 </p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money - <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;AA&#x27;</span>;<br>UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money + <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BB&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="提交的（committed）"><a href="#提交的（committed）" class="headerlink" title="提交的（committed）"></a>提交的（committed）</h4><p>当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处 在了 提交的 状态。 一个基本的状态转换图如下所示：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210346.png" alt="image-20220125165704463"></p>
<h2 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h2><p>使用事务有两种方式，分别为 <code>显式事务</code> 和<code> 隐式事务</code> 。 </p>
<h3 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h3><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>#或者<br>mysql&gt; START TRANSACTION;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>后面可以跟: <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span> / <span class="hljs-keyword">read</span> <span class="hljs-keyword">write</span>(默认) / <span class="hljs-keyword">with</span> consistent <span class="hljs-keyword">snapshot</span><br></code></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：</p>
<p>① READ ONLY ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不 能修改数据。 </p>
<p>② READ WRITE ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。 </p>
<p>③ WITH CONSISTENT SNAPSHOT ：启动一致性读。 </p>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL） </p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 回滚事务。即撤销正在进行的所有没有提交的修改<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br># 将事务回滚到某个保存点。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> [<span class="hljs-keyword">SAVEPOINT</span>]<br></code></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。<br><span class="hljs-keyword">SAVEPOINT</span> 保存点名称;<br><br># 删除某个保存点。<br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名称:<br></code></pre></td></tr></table></figure>



<h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>每条DML语句都是一条独立的事务。</p>
<p>针对于DML操作是有效的，对DDL操作是无效的。</p>
<p>关闭了自动提交之后，写语句要自己 commit，否则会<code>锁表</code></p>
<p>MySQL中有一个系统变量 autocommit ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> autocommit <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种 自动提交 的功能，可以使用下边两种方法之一： </p>
<p>显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回 滚前会暂时关闭掉自动提交的功能。 </p>
<p>把系统变量 autocommit 的值设置为 OFF ，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> OFF;<br>#或<br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210347.png" alt="image-20220125172112442"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210348.png" alt="image-20220125172120904"></p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。 </p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个<code>会话（ Session ）</code>。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理 多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影响太大 ，我们既想保持 事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取 舍了。</p>
<h3 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题： </p>
<p><strong>脏写（ Dirty Write ）</strong> </p>
<p>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数 据，那就意味着发生了 脏写</p>
<p><strong>脏读（ Dirty Read ）</strong></p>
<p>对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。 之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。 </p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象 就称之为 脏读 。 </p>
<p><strong>不可重复读（ Non-Repeatable Read ）</strong> </p>
<p>对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后 Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。 </p>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看 到最新的值，这种现象也被称之为 不可重复读 。 </p>
<p><strong>幻读（ Phantom ）</strong> </p>
<p>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。 </p>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 幻影记录 。</p>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序： </p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并 发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ： </p>
<p>READ UNCOMMITTED ：</p>
<p>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。 </p>
<p>READ COMMITTED ：</p>
<p>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。 </p>
<p>REPEATABLE READ ：</p>
<p>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。 </p>
<p>SERIALIZABLE ：</p>
<p>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。 </p>
<p>SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210349.png" alt="image-20220125173629691"></p>
<p>脏写 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。 不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210350.png" alt="image-20220125173641123"></p>
<h3 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h3><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本之前：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;tx_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> tx_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br># MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation<br><br># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本及之后：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;transaction_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> transaction_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.02</span> sec)<br><br>#或者不同MySQL版本中都可以使用的：<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><br></code></pre></td></tr></table></figure>

<h3 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h3><p><strong>通过下面的语句修改事务的隔离级别：</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;<br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>或者： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;隔离级别&#x27;</span><br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE<span class="hljs-operator">-</span>READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响： </p>
<p>使用 GLOBAL 关键字（在全局范围影响）： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>当前已经存在的会话无效 </p>
</li>
<li><p>只对执行完该语句之后产生的会话起作用 </p>
</li>
</ul>
<p>使用 SESSION 关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>对当前会话的所有后续的事务有效 </p>
</li>
<li><p>如果在事务之间执行，则对后续的事务有效 </p>
</li>
<li><p>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</p>
</li>
</ul>
<blockquote>
<p>小结： </p>
<p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性 就越好，但并发性越弱。</p>
</blockquote>
<h2 id="事务的常见分类"><a href="#事务的常见分类" class="headerlink" title="事务的常见分类"></a>事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型： </p>
<p>扁平事务（Flat Transactions） </p>
<p>带有保存点的扁平事务（Flat Transactions with Savepoints） </p>
<p>链事务（Chained Transactions） </p>
<p>嵌套事务（Nested Transactions） </p>
<p>分布式事务（Distributed Transactions）</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210351.png" alt="image-20220125174041369"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210352.png" alt="image-20220125174109035"></p>
<h1 id="十四、MySQL事务日志"><a href="#十四、MySQL事务日志" class="headerlink" title="十四、MySQL事务日志"></a>十四、MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？ </p>
<p>事务的隔离性由 <code>锁机制</code> 实现。 </p>
<p>而事务的原子性、一致性和持久性由<code>事务的 redo 日志</code>和<code>undo 日志</code>来保证。 </p>
<p>REDO LOG 称为 <code>重做日志</code> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。 </p>
<p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。 </p>
<p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。</p>
<table>
<thead>
<tr>
<th></th>
<th>undo日志</th>
<th>redo日志</th>
</tr>
</thead>
<tbody><tr>
<td>用来保证</td>
<td>持久性</td>
<td>原子性、一致性</td>
</tr>
<tr>
<td>记录的是</td>
<td>物理级别上页的修改操作</td>
<td>逻辑日志</td>
</tr>
<tr>
<td>主要作用</td>
<td>保证数据的可靠性</td>
<td>事务回滚、MVCC</td>
</tr>
<tr>
<td>产生位置</td>
<td>存储引擎层</td>
<td>数据库层</td>
</tr>
<tr>
<td>产生时机</td>
<td>事务执行过程中</td>
<td>事务提交时</td>
</tr>
<tr>
<td>组成部分</td>
<td>redo log buffer 、redo log file</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到<code>内存中的Buffer Pool</code>之后才可以访问。所有的变更都必须先<code>更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘（ <code>checkPoint机制</code>），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h3 id="为什么需要REDO日志"><a href="#为什么需要REDO日志" class="headerlink" title="为什么需要REDO日志"></a>为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发 </code>的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。 </p>
<p>另一方面，事务包含 <code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩 溃，这个事务对数据库中所做的更改也不能丢失。 </p>
<p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题：</p>
<p>1、修改量与刷新磁盘工作量严重不成比例</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在innoDB中是以页为单位来进行磁盘lo的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p>
<p>2、随机IO刷新较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机Io比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
<p><code>另一个解决的思路 ：</code>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2 。</p>
<p>InnoDB引擎的事务采用了WAL技术(（Write-Ahead Logging )，这种技术的思想就是<code>先写日志，再写磁盘</code>，<code>只有日志写入成功，才算事务提交成功</code>，这里的日志就是<code>redo log</code>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210353.png" alt="image-20220126163216220"></p>
<h3 id="REDO日志的好处、特点"><a href="#REDO日志的好处、特点" class="headerlink" title="REDO日志的好处、特点"></a>REDO日志的好处、特点</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>redo日志降低了刷盘频率 </p>
<p>redo日志占用的空间非常小</p>
<ul>
<li>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>redo日志是顺序写入磁盘的</strong></p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快。</p>
<p><strong>事务执行过程中，redo log不断记录</strong></p>
<p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<h3 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h3><p>Redo log可以简单分为以下两个部分： </p>
<p>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。 </p>
<p>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210354.png" alt="image-20220126164106278"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210355.png" alt="image-20220126164116794"></p>
<h3 id="redo的整体流程"><a href="#redo的整体流程" class="headerlink" title="redo的整体流程"></a>redo的整体流程</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210356.png" alt="image-20220126164250628"></p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<h3 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一 定的频率 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210357.png" alt="image-20220126164334492"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存 （page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系 统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。 </p>
<p>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略： </p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） </p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210358.png" alt="image-20220126164459943"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210359.png" alt="image-20220126164511633"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210400.png" alt="image-20220126164523067"></p>
<h3 id="不同刷盘策略演示"><a href="#不同刷盘策略演示" class="headerlink" title="不同刷盘策略演示"></a>不同刷盘策略演示</h3><p>流程图</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210401.png" alt="image-20220126164550158"></p>
<p>小结: innodb_flush_log_at_trx_commit=1</p>
<p>为1时,只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失,但是<code>效率最差</code>的。</p>
<p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210402.png" alt="image-20220126164557233"></p>
<p>小结：innodb_flush_log_at_trx_commit=2</p>
<p>为2时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存（page cache )。</p>
<p>如果仅仅只是MySQL挂了不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210403.png" alt="image-20220126164603143"></p>
<p>小结: innodb_flush_log_at_trx_commit=0</p>
<p>为0时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p>
<p>数值o的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，也无法保证D。</p>
<h3 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h3><h4 id="补充概念：Mini-Transaction"><a href="#补充概念：Mini-Transaction" class="headerlink" title="补充概念：Mini-Transaction"></a>补充概念：Mini-Transaction</h4><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210404.png" alt="image-20220126164811826"></p>
<h4 id="redo-日志写入log-buffer"><a href="#redo-日志写入log-buffer" class="headerlink" title="redo 日志写入log buffer"></a>redo 日志写入log buffer</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210405.png" alt="image-20220126164841075"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210406.png" alt="image-20220126164849968"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210407.png" alt="image-20220126164900488"></p>
<h4 id="redo-log-block的结构图"><a href="#redo-log-block的结构图" class="headerlink" title="redo log block的结构图"></a>redo log block的结构图</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210408.png" alt="image-20220126165004100"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210409.png" alt="image-20220126165019180"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210410.png" alt="image-20220126165025786"></p>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><h4 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210411.png" alt="image-20220126165107986"></p>
<h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210412.png" alt="image-20220126165125652"></p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210413.png" alt="image-20220126165156959"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210414.png" alt="image-20220126165204252"></p>
<h3 id="redolog小结"><a href="#redolog小结" class="headerlink" title="redolog小结"></a>redolog小结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210415.png" alt="image-20220126165229526"></p>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要 先写入一个 undo log 。 </p>
<h3 id="如何理解undo日志"><a href="#如何理解undo日志" class="headerlink" title="如何理解undo日志"></a>如何理解undo日志</h3><p>事务需要保证 原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半 会出现一些情况，比如： </p>
<p>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突 然 断电 导致的错误。 </p>
<p>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行。 以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 回滚 ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 原子性 要求。</p>
<p>每当我们要对一条记录做<code>改动</code>时(这里的改动可以指INSERT、DELETE、UPDATE)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p>
<p>你<code>插入一条记录时</code>，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</p>
<p>你<code>删除了一条记录</code>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</p>
<p>你<code>修改了一条记录</code>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,I将修改前的行放回去)</p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即undo log )。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log 会<code>产生 redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h3 id="undo日志的作用"><a href="#undo日志的作用" class="headerlink" title="undo日志的作用"></a>undo日志的作用</h3><p><strong>作用1：回滚数据</strong></p>
<p>用户对undo日志可能<code>有误解</code>：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p><strong>作用2: MVCC</strong></p>
<p>undo的另一个作用是MVcd，即在InnoDB存储引擎中MVcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
<h3 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h3><h4 id="回滚段与undo页"><a href="#回滚段与undo页" class="headerlink" title="回滚段与undo页"></a>回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了 1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。 </p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务 限制为 1024 。虽然对绝大多数的应用来说都已经够用。 </p>
<p>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到 了 128*1024 。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_undo_logs&#x27;;</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| innodb_undo_logs | 128 |</span><br><span class="hljs-section">+------------------+-------+</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210416.png" alt="image-20220126165928819"></p>
<h4 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h4><p>1、每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。 </p>
<p>2、当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 据会被复制到回滚段。 </p>
<p>3、在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。 </p>
<p>4、回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210417.png" alt="image-20220126170027157"></p>
<p>5、当事务提交时，InnoDB存储引擎会做以下两件事情： </p>
<ul>
<li><p>将undo log放入列表中，以供之后的purge操作 </p>
</li>
<li><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
</li>
</ul>
<h4 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h4><p>1.未提交的回滚数据(uncommitted undo information) ∶该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p>
<p>2.已经提交但未过期的回滚数据(committed undo information) : 该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</p>
<p>3.事务已经提交并过期的数据(expired undo information)：事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</p>
<p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>
<h3 id="undo的类型"><a href="#undo的类型" class="headerlink" title="undo的类型"></a>undo的类型</h3><p>在InnoDB存储引擎中，undo log分为： </p>
<p>insert undo log </p>
<p>update undo log</p>
<p>insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
<p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h3 id="undo-log的生命周期"><a href="#undo-log的生命周期" class="headerlink" title="undo log的生命周期"></a>undo log的生命周期</h3><h4 id="简要生成过程"><a href="#简要生成过程" class="headerlink" title="简要生成过程"></a>简要生成过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210418.png" alt="image-20220126170334099"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210419.png" alt="image-20220126170342843"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210420.png" alt="image-20220126170351424"></p>
<p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p>
<h4 id="详细生成过程"><a href="#详细生成过程" class="headerlink" title="详细生成过程"></a>详细生成过程</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210421.png" alt="image-20220126170435107"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210422.png" alt="image-20220126170446833"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210423.png" alt="image-20220126170457631"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210424.png" alt="image-20220126170506463"></p>
<h4 id="undo-log是如何回滚的"><a href="#undo-log是如何回滚的" class="headerlink" title="undo log是如何回滚的"></a>undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样： </p>
<p>1.通过undo no=3的日志把id=2的数据删除 </p>
<p>2.通过undo no=2的日志把id=1的数据的deletemark还原成0 </p>
<p>3.通过undo no=1的日志把id=1的数据的name还原成Tom </p>
<p>4.通过undo no=0的日志把id=1的数据删除 </p>
<h4 id="undo-log的删除"><a href="#undo-log的删除" class="headerlink" title="undo log的删除"></a>undo log的删除</h4><p><strong>针对于insert undo log</strong> </p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删 除，不需要进行purge操作。 </p>
<p><strong>针对于update undo log</strong> </p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等 待purge线程进行最后的删除。</p>
<p>补充:</p>
<p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清除page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种”假删除”;只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210425.png" alt="image-20220126170656837"></p>
<h1 id="十五、锁"><a href="#十五、锁" class="headerlink" title="十五、锁"></a>十五、锁</h1><p>事务的<code> 隔离性</code> 由这章讲述的 <code>锁</code> 来实现。 </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>锁是计算机协调多个进程或线程<code>并发访问莱一资源</code>的机制。在程序开发中会存在<code>多线程同步</code>的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了<code>保证数据的一致性</code>，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。  </p>
<h2 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种： </p>
<h3 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h3><p>读-读 情况，即并发事务相继 <code>读取相同的记录</code> 。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。 </p>
<h3 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。 </p>
<p>在这种情况下<code>会发生 脏写 </code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓 的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210426.png" alt="image-20220128085542663"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构 </code>，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210427.png" alt="image-20220128085549070"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210428.png" alt="image-20220128085615584"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210429.png" alt="image-20220128085624956"></p>
<p>小结几种说法： </p>
<p><strong>不加锁</strong> </p>
<p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。 </p>
<p><strong>获取锁成功，或者加锁成功</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。 </p>
<p><strong>获取锁失败，或者加锁失败，或者没有获取到锁</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 需要等待，不可以继续执行操作。</p>
<h3 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重 复读 、 幻读 的问题。 </p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经 解决了 幻读 问题。 </p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决 <code>脏读</code> 、 <code>不可重复读</code> 、 <code>幻读</code> 这些问题呢？其实有两种可选的解决方案： </p>
<p><strong>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。</strong> </p>
<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到<code>符合条件的记录版本</code>（历史版本由<code>undo日志</code>构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadVview之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写操作并不冲突</code>。</p>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。 </p>
<ul>
<li><p>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就 是避免了脏读现象； </p>
</li>
<li><p>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会 生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读 和幻读的问题。 </p>
</li>
</ul>
<p><strong>方案二：读、写操作都采用 加锁 的方式。</strong> </p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p>
<p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p>
<p><strong>小结对比发现：</strong> </p>
<p>采用 <code>MVCC</code> 方式的话， <code>读-写</code> 操作彼此并不冲突， 性能更高 。 </p>
<p>采用 <code>加锁</code> 方式的话， <code>读-写</code> 操作彼此需要 排队执行 ，影响性能。 </p>
<p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
<h2 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h2><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210430.png" alt="image-20220128090524948"></p>
<h3 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写 或 写-读 这些情况可能会引起一些问题，需要使用WVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于<code>既要允许读-读情况不受影响</code>，<code>又要使写-写、读-写或写-读情况中的操作相互阻塞</code>，所以MysSQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁(Shared Lock，SLock)和排他锁(Exclusive Lock，XLock),也叫读锁（readlock)和写锁(write lock)。</p>
<p><code>读锁</code> ：也称为<code> 共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。 </p>
<p><code>写锁</code> ：也称为<code> 排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。 </p>
<p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210431.png" alt="image-20220128090725535"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210432.png" alt="image-20220128090742089"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210433.png" alt="image-20220128090753730"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210434.png" alt="image-20220128090812907"></p>
<h3 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h3><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h4><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 S锁 或者 X锁 的。在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 <code>MDL</code> ）结构来实现的。 </p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 <code>崩溃恢复 </code>过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取 InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写： </p>
<ul>
<li><p>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 </p>
</li>
<li><p>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。 </p>
</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 行锁 ，关于 InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210435.png" alt="image-20220128091028657"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210436.png" alt="image-20220128091036865"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210437.png" alt="image-20220128091053120"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210438.png" alt="image-20220128091104143"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210439.png" alt="image-20220128091119368"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210440.png" alt="image-20220128091133594"></p>
<h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p><strong>意向锁的出现是为了协调行锁和表锁的关系，支持多粒度的表锁。</strong></p>
<p>在没有意向锁的时候，如果事务A对表中的数据加了行锁，此时事务B想要对这个表加页锁，那么事务B就首先需要通过遍历的方式判断这个表中的每一行数据是不是有表锁，当数据量比较大的时候，浪费时间</p>
<p>为了解决此问题，使用了意向锁。如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<p>InnoDB 支持 <code>多粒度锁</code>（multiple granularity locking） ，它<code>允许 行级锁 与 表级锁 共存</code>，而意向 锁就是其中的一种 <code>表锁</code> 。 </p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存。</p>
<p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p>
<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p><strong>意向锁分为两种：</strong> </p>
<p>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br></code></pre></td></tr></table></figure>

<p>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p><strong>1.意向锁要解决的问题</strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p>
<p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<ul>
<li><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</p>
</li>
<li><p>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</p>
</li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210441.png" alt="image-20220128091708393"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210442.png" alt="image-20220128091716562"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210443.png" alt="image-20220128091731490"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210444.png" alt="image-20220128091748452"></p>
<p><strong>意向锁的并发性</strong></p>
<p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 他锁时的并发性。（不然我们直接用普通的表锁就行了） </p>
<p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可 能存在多种不同锁，但是这里我们只着重表现意向锁）。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210445.png" alt="image-20220128091812208"></p>
<p><strong>从上面的案例可以得到如下结论：</strong> </p>
<p>1.InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。 </p>
<p>2.意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。 </p>
<p>3.IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </p>
<p>4.意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</p>
<h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `teacher` (<br>`id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `teacher` (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>), (<span class="hljs-string">&#x27;lisi&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> lisi <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。 </p>
<p><strong>1.“Simple inserts” （简单插入）</strong> </p>
<p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行 INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。 </p>
<p><strong>2.“Bulk inserts” （批量插入）</strong> </p>
<p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p>
<p><strong>3.“Mixed-mode inserts” （混合模式插入）</strong> </p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混 合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210446.png" alt="image-20220128092234241"></p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式： </p>
<p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式) </code></p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。 </p>
<p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式) </code></p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。 </p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。 </p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p>
<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式) </code></p>
<p>从 MySQL 8.0 开始，交错锁模式是 默认 设置。 </p>
<p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但 是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能 不是连续的。</p>
<p>如果执行的语句是”simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 </p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</strong></p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210447.png" alt="image-20220128092444808"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210448.png" alt="image-20220128092453945"></p>
<h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2.InnoDB中的行锁"></a>2.InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p>
<p>优点：锁定力度小，发生锁冲突概率低，可以实现的并发度高。</p>
<p>缺点：对于锁的开销比较大，加锁会比较慢容易出现死锁情况。</p>
<p>InnoDB与MyISAM的最大不同有两点:一是支持事务（TRANSACTION);二是采用了行级锁。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210449.png" alt="image-20220214100724739"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210450.png" alt="image-20220214100734982"></p>
<h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210451.png" alt="image-20220214100755360"></p>
<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。 </p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁； </p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。 </p>
</li>
</ul>
<h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h5><p>MySQL 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁</code> 方案解决。</p>
<p>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210452.png" alt="image-20220214100913810"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210453.png" alt="image-20220214100922762"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210454.png" alt="image-20220214100947538"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210455.png" alt="image-20220214101004869"></p>
<h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a>③ 临键锁（Next-Key Locks）</h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 <code>间隙插入新记录</code> ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210456.png" alt="image-20220214101123814"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure>

<h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a>④ 插入意向锁（Insert Intention Locks）</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为:LOCK_INSERT_INTENTION，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间(gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取（4，7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待)。总结来说，插入意向锁的特性可以分成两部分:</p>
<p>(1）插入意向锁是一种特殊的间隙锁—一间隙锁可以锁定开区间内的部分记录。</p>
<p>(2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p>
<p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<code>行锁</code>。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210457.png" alt="image-20220214101429289"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210458.png" alt="image-20220214101451957"></p>
<h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h4><p>页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong> </p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h3 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 数据并发的思维方式 。需要注意的是，乐观锁和悲观锁并不是锁，而是<code>锁的 设计思想 </code>。 </p>
<h4 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身 的锁机制来实现，从而保证数据操作的排它性。 </p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上 锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<code>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</code>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当 其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是 悲观锁思想的实现。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210459.png" alt="image-20220214102010016"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210500.png" alt="image-20220214102029742"></p>
<h4 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过 程序来实现。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。 </p>
<h5 id="乐观锁的版本号机制"><a href="#乐观锁的版本号机制" class="headerlink" title="乐观锁的版本号机制"></a>乐观锁的版本号机制</h5><p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更 新或删除操作时，会执行 UPDATE … SET version=version+1 WHERE version=version 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。 </p>
<h5 id="乐观锁的时间戳机制"><a href="#乐观锁的时间戳机制" class="headerlink" title="乐观锁的时间戳机制"></a>乐观锁的时间戳机制</h5><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。 你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210501.png" alt="image-20220214102106002"></p>
<h4 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景： </p>
<ol>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。 </li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。 </li>
</ol>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210502.png" alt="image-20220214102124473"></p>
<h3 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210503.png" alt="image-20220214102149966"></p>
<p>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。 </p>
<p>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210504.png" alt="image-20220214102216873"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210505.png" alt="image-20220214102240974"></p>
<h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210506.png" alt="image-20220214102319698"></p>
<h3 id="其它锁之：全局锁"><a href="#其它锁之：全局锁" class="headerlink" title="其它锁之：全局锁"></a>其它锁之：全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>

<h3 id="其它锁之：死锁"><a href="#其它锁之：死锁" class="headerlink" title="其它锁之：死锁"></a>其它锁之：死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死 锁示例：</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210507.png" alt="image-20220214102454938"></p>
<p>第二种策略的成本分析 </p>
<p>方法1：如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有 一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后 通过业务重试一般就没问题了，这是 业务无损 的。而关掉死锁检测意味着可能会出现大量的超时，这是 业务有损 的。 </p>
<p>方法2：控制并发度。如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测 的成本很低，就不会出现这个问题。 这个并发控制要做在 数据库服务端 。如果你有中间件，可以考虑在 中间件实现 ；甚至有能力修改MySQL 源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队，这样在 InnoDB内部就不会有大量的死锁检测工作了。</p>
<h1 id="十六、多版本并发控制"><a href="#十六、多版本并发控制" class="headerlink" title="十六、多版本并发控制"></a>十六、多版本并发控制</h1><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210508.png" alt="image-20220214102633787"></p>
<h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><p> MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版 本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保 证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。 </p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到 即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。 </p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞 读；比如这样： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。 </p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 </p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student LOCK <span class="hljs-keyword">IN</span> SHARE MODE; # 共享锁<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; # 排他锁<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">values</span> ... # 排他锁<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> ... # 排他锁<br><span class="hljs-keyword">UPDATE</span> student <span class="hljs-keyword">SET</span> ... # 排他锁<br></code></pre></td></tr></table></figure>

<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题： </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210509.png" alt="image-20220214103021784"></p>
<p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p>
<p>MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210510.png" alt="image-20220214103029537"></p>
<h3 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必 要的隐藏列。</p>
<p>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。 </p>
<p>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210511.png" alt="image-20220214103110105"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210512.png" alt="image-20220214103124895"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210513.png" alt="image-20220214103144338"></p>
<h2 id="MVCC实现原理之ReadView"><a href="#MVCC实现原理之ReadView" class="headerlink" title="MVCC实现原理之ReadView"></a>MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</p>
<h3 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h3><p>在MCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID(“”活跃”指的就是，启动了但还没提交)。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了。 </p>
<p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。 </p>
<p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问 题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210514.png" alt="image-20220214103336220"></p>
<h3 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。 </p>
<p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前 事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p>
<p> 如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判 断一下trx_id属性值是不是在 trx_ids 列表中。 </p>
<ul>
<li><p>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </p>
</li>
<li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p>
</li>
</ul>
<h3 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它： </p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。 在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。 如表所示：</li>
</ol>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210515.png" alt="image-20220214103536185"></p>
<h1 id="十七、其他数据库日志"><a href="#十七、其他数据库日志" class="headerlink" title="十七、其他数据库日志"></a>十七、其他数据库日志</h1><p>我们在讲解数据库事务时，讲过两种日志:重做日志、回滚日志。</p>
<p>对于线上数据库应用系统，突然遭遇数据库宕机怎么办?在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的sQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p>
<p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。 </p>
<p>MySQL8.0 官网日志地址：“ <a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a> ”</p>
<h2 id="MySQL支持的日志"><a href="#MySQL支持的日志" class="headerlink" title="MySQL支持的日志"></a>MySQL支持的日志</h2><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志 和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。 </p>
<p><strong>这6类日志分别为：</strong> </p>
<p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。 </p>
<p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。 </p>
<p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。 </p>
<p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。 </p>
<p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。 </p>
<p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。 </p>
<p>除二进制日志外，其他日志都是 文本文件 。默认情况下，所有日志创建于 MySQL数据目录 中。 </p>
<h3 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h3><p>日志功能会 降低MySQL数据库的性能 。 </p>
<p>日志会 占用大量的磁盘空间 。</p>
<h2 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志(slow query log)"></a>慢查询日志(slow query log)</h2><p>前面章节《第09章_性能分析工具的使用》已经详细讲述。 </p>
<h2 id="通用查询日志-general-query-log"><a href="#通用查询日志-general-query-log" class="headerlink" title="通用查询日志(general query log)"></a>通用查询日志(general query log)</h2><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志， 还原操作时的具体场景，可以帮助我们准确定位问题。</p>
<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p>
<p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p>
<p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点so，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p>
<p>由于网络的原因导致了重复支付。至于解决问题的方案就很多了，这里省略。</p>
<p>可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。</p>
<h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> general_log <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span> #通用查询日志处于关闭状态<br><span class="hljs-operator">|</span> general_log_file <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu01.log <span class="hljs-operator">|</span> #通用查询日志文件的名称是atguigu01.log<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>

<p>说明1：系统变量general_log 的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的默认值是关闭的。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。</p>
<p>说明2：通用查询日志文件的名称是atguiguo1.log。存储路径是/var/ib/mysql/，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了。</p>
<h3 id="启动日志"><a href="#启动日志" class="headerlink" title="启动日志"></a>启动日志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210516.png" alt="image-20220214104404634"></p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>通用查询日志是以 文本文件 的形式存储在文件系统中的，可以使用 文本编辑器 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。 </p>
<p>在Windows操作系统中，使用文本文件查看器； </p>
<p>在Linux系统中，可以使用vi工具或者gedit工具查看； </p>
<p>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。 </p>
<p>从 SHOW VARIABLES LIKE ‘general_log%’; 结果中可以看到通用查询日志的位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>sbin<span class="hljs-operator">/</span>mysqld, Version: <span class="hljs-number">8.0</span><span class="hljs-number">.26</span> (MySQL Community Server <span class="hljs-operator">-</span> GPL). started <span class="hljs-keyword">with</span>:<br>Tcp port: <span class="hljs-number">3306</span> Unix socket: <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>mysql.sock<br><span class="hljs-type">Time</span> Id Command Argument<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">44</span>:<span class="hljs-number">58.052890</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">15.666672</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;general_log%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">28.970765</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.706804</span>Z <span class="hljs-number">11</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@localhost</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> Socket<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.707435</span>Z <span class="hljs-number">11</span> Query <span class="hljs-keyword">select</span> @<span class="hljs-variable">@version</span>_comment limit <span class="hljs-number">1</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.384886</span>Z <span class="hljs-number">12</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385253</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385640</span>Z <span class="hljs-number">12</span> Query USE `atguigu12`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.386179</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.901778</span>Z <span class="hljs-number">13</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.902128</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905179</span>Z <span class="hljs-number">13</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905825</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.163833</span>Z <span class="hljs-number">14</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164451</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164840</span>Z <span class="hljs-number">14</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">40.006687</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account<br></code></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什 么 SQL 操作，针对的是哪个数据表等信息。</p>
<h3 id="停止日志"><a href="#停止日志" class="headerlink" title="停止日志"></a>停止日志</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210517.png" alt="image-20220214104540183"></p>
<h4 id="删除-刷新日志"><a href="#删除-刷新日志" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很 长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210518.png" alt="image-20220214104610167"></p>
<h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h2><h3 id="启动日志-1"><a href="#启动日志-1" class="headerlink" title="启动日志"></a>启动日志</h3><p>在MySQL数据库中，错误日志功能是 默认开启 的。而且，错误日志 无法被禁止 。 默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或 hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>error<span class="hljs-operator">=</span>[path<span class="hljs-operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名<br></code></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。 </p>
<h3 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。 查询错误日志的存储路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_err%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> log_error <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysqld.log <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_services <span class="hljs-operator">|</span> log_filter_internal; log_sink_internal <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_suppression_list <span class="hljs-operator">|</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_verbosity <span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210519.png" alt="image-20220214104745940"></p>
<h3 id="删除-刷新日志-1"><a href="#删除-刷新日志-1" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 直接删除 。 </p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210520.png" alt="image-20220214104805353"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210521.png" alt="image-20220214104814508"></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">install -omysql -gmysql -m0644 <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> <span class="hljs-regexp">/var/</span>log/mysqld.log<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8-0新特性"><a href="#MySQL8-0新特性" class="headerlink" title="MySQL8.0新特性"></a>MySQL8.0新特性</h3><p>MySQL8.0里对错误日志的改进。MySQL8.o的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。</p>
<p><strong>下面这些是来自社区的意见:</strong></p>
<p>默认情况下内容过于冗长·遗漏了有用的信息</p>
<p>难以过滤某些信息</p>
<p>没有标识错误信息的子系统源</p>
<p>没有错误代码，解析消息需要识别错误。引导消息可能会丢失</p>
<p>固定格式</p>
<p><strong>针对这些意见，MySQL做了如下改变:</strong></p>
<p>采用组件架构，通过不同的组件执行日志的写入和过滤功能。写入错误日志的全部信息都具有唯一的错误代码从10000开始</p>
<p>增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息。增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等</p>
<p>两种过滤方式，Internal和Dragnet</p>
<p>三种写入形式，经典、JSON和syseventlog</p>
<p>小结:</p>
<p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p>
<h2 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较 重要 的日志了，在日常开发及运维过程中，经常会遇到。 binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。 </p>
<p>binlog主要应用场景： </p>
<p>一是用于 数据恢复 </p>
<p>二是用于 数据复制</p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210522.png" alt="image-20220214104854289"></p>
<h3 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210523.png" alt="image-20220214105109857"></p>
<h3 id="日志参数设置"><a href="#日志参数设置" class="headerlink" title="日志参数设置"></a>日志参数设置</h3><p><strong>方式1：永久性方式</strong> </p>
<p>修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>#启用二进制日志<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>atguigu<span class="hljs-operator">-</span>bin<br>binlog_expire_logs_seconds<span class="hljs-operator">=</span><span class="hljs-number">600</span><br>max_binlog_size<span class="hljs-operator">=</span><span class="hljs-number">100</span>M<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210524.png" alt="image-20220214105507715"></p>
<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong> </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;<br><br></code></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">chown <span class="hljs-operator">-</span>R <span class="hljs-operator">-</span>v mysql:mysql binlog<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210525.png" alt="image-20220214105548184"></p>
<p><strong>方式2：临时性方式</strong> </p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 会话级别 的设置，没有了global级别的设置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">global</span> 级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>ERROR <span class="hljs-number">1228</span> (HY000): Variable <span class="hljs-string">&#x27;sql_log_bin&#x27;</span> <span class="hljs-keyword">is</span> a SESSION variable <span class="hljs-keyword">and</span> can`t be used<br><span class="hljs-keyword">with</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span><br># session级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> 秒)<br></code></pre></td></tr></table></figure>

<h3 id="查看日志-2"><a href="#查看日志-2" class="headerlink" title="查看日志"></a>查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。 </p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就 会创建一个新的日志文件。 </p>
<p>查看当前的二进制日志文件列表及大小。指令如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-type">BINARY</span> LOGS;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> Log_name <span class="hljs-operator">|</span> File_size <span class="hljs-operator">|</span> Encrypted <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> atguigu<span class="hljs-operator">-</span>bin<span class="hljs-number">.000001</span> <span class="hljs-operator">|</span> <span class="hljs-number">156</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">No</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-number">1</span> 行于数据集 (<span class="hljs-number">0.02</span> 秒)<br></code></pre></td></tr></table></figure>

<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210526.png" alt="image-20220214105635944"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210527.png" alt="image-20220214105656266"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210528.png" alt="image-20220214105719614"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210529.png" alt="image-20220214105729486"></p>
<h3 id="使用日志恢复数据"><a href="#使用日志恢复数据" class="headerlink" title="使用日志恢复数据"></a>使用日志恢复数据</h3><p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210530.png" alt="image-20220214105832031"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210531.png" alt="image-20220214105954967"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210532.png" alt="image-20220214110004021"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210533.png" alt="image-20220214110046092"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210534.png" alt="image-20220214110056135"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210535.png" alt="image-20220214110106530"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210536.png" alt="image-20220214110115454"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210537.png" alt="image-20220214110124763"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210538.png" alt="image-20220214110136968"></p>
<p><img src="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210539.png" alt="image-20220214110147324"></p>
<h3 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 PURGE MASTER LOGS 只删除指定部分的二进制日志文件， RESET MASTER 删除所有的二进制日志文 件。具体如下： </p>
<p>PURGE MASTER LOGS：删除指定日志文件 PURGE MASTER LOGS语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS <span class="hljs-keyword">TO</span> ‘指定日志文件名’<br>PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’<br></code></pre></td></tr></table></figure>

<h3 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h3><p>二进制日志可以通过数据库的 全量备份 和二进制日志中保存的 增量信息 ，完成数据库的 无损失恢复 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数 据恢复，是很有挑战性的，因为起止位置不容易管理。 </p>
<p>在这种情况下，一个有效的解决办法是 配置主从数据库服务器 ，甚至是 一主多从 的架构，把二进制日志 文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常 等问题。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
