

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>设计模式02-结构型模式 - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content=", 设计模式">
  <meta name="description" content="结构型模式 | 上篇结构型模式总览结构型模式主要总结了...">
  <meta name="author" content="kygeng">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/kygeng.github.io/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">设计模式02-结构型模式</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226215039.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">设计模式02-结构型模式</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>January 07, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>63092</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="结构型模式-上篇"><a href="#结构型模式-上篇" class="headerlink" title="结构型模式 | 上篇"></a>结构型模式 | 上篇</h1><h2 id="结构型模式总览"><a href="#结构型模式总览" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些<strong>类或对象组合在一起</strong>的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>代理模式：新增代理类，控制访问原始类</p>
<p>桥接模式：接口和实现分离，组合优于继承</p>
<p>装饰器模式：不改变原始类，增强原始类</p>
<p>适配器模式：事后补救策略，不兼容的接口转为可兼容</p>
<hr>
<p>代理模式：不改变原始类和接口，为原理类定义代理类，控制访问</p>
<p>桥接模式：将接口和实现部分分离</p>
<p>装饰器模式：不改变原始类和接口，对原始类增强</p>
<p>适配器模式：事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220106141529342"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。</p>
<p>我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>静态代理、动态代理（jdk动态代理、cglib动态代理）</p>
<p>Spring中的APO</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>理解一：将抽象和实现解耦，让它们可以独立变化</p>
<p>理解二：一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。类似于“组合优于继承”，通过组合关系来替代继承关系，避免继承层次的指数级爆炸</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时</li>
</ol>
<p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>JDBC数据库连接池：MySQL和Oracle的方便切换</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>不改变原始类和接口，对原始类增强</p>
<p><strong>Q：装饰器模式就是简单的“用组合替代继承”吗？</strong></p>
<p>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。** </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>

<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类<strong>无关的功能</strong>，而在装饰器模式中，装饰器类附加的是跟原始类<strong>相关的增强功 能</strong>。</u></p>
<blockquote>
<p>业务场景</p>
</blockquote>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的IO流</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>事后补救策略，将不兼容的接口转换为可兼容的接口</p>
<p><strong>Q：适配器模式有两种实现方式：类适配器和对象适配器。</strong></p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<p>接口不兼容的场景</p>
<p><strong>Q：那在实际的开发中，什么情况下才会出现接口不兼容呢？</strong></p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的日志框架：Slf4j</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<h1 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>它在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<h3 id="代理模式的原理解析"><a href="#代理模式的原理解析" class="headerlink" title="代理模式的原理解析"></a>代理模式的原理解析</h3><p>性能计数器。当时我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略login逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// ... 省略register逻辑...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很明显，上面的写法有两个问题。</p>
<p>第一，性能计数器框架代码侵入到业务代码中，跟业务代 码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。</p>
<p>第二，收集接口请求的 代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处 理。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业 务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。</p>
<p>UserController：核心业务实现类</p>
<p>UserControllerProxy：代理类，通过 委托 的方式（不修改源代码），对核心功能类增强 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span>;<br>    UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-comment">//...省略其他属性和方法...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略login逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>	<span class="hljs-comment">//...省略register逻辑...</span><br>	<span class="hljs-comment">//...返回UserVo数据...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">private</span> UserController userController;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">(UserController userController)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userController = userController;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>		<span class="hljs-comment">// 委托</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="hljs-comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>())<br></code></pre></td></tr></table></figure>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。</p>
<p>但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个 第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下， 我们该如何实现代理模式呢？ </p>
<p>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承 原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体 代码如下所示：</p>
<p>UserController：别人写的，我们不知道长啥样</p>
<p>UserControllerProxy：我们自己写的，继承了 UserController，重写了里面的方法，方法里面的主要逻辑是对原功能增强，核心逻辑是 super.login() 调用原方法，一般项目开发中这种方式最常用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-comment">//功能增强</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//核心逻辑：通过委托的方式，super.login</span><br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.login(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimes<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.register(telephone, password);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTi<br>                metricsCollector.recordRequest(requestInfo);<br>        <span class="hljs-keyword">return</span> userVo;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//UserControllerProxy使用举例</span><br>    <span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>();<br></code></pre></td></tr></table></figure>



<h3 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h3><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的 方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的 附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。 </p>
<p>如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项 目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式 的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>
<p>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不 事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后 在系统中用代理类替换掉原始类。那如何实现动态代理呢？ </p>
<p>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已 经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来 看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中， MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创 建代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollectorProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricsCollectorProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();<br>        <span class="hljs-type">DynamicProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(proxiedObject);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), in<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> Object proxiedObject;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>            <span class="hljs-built_in">this</span>.proxiedObject = proxiedObject;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Th<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxiedObject, args);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiName</span> <span class="hljs-operator">=</span> proxiedObject.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + method.getNam<br>        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(apiName, responseTime, startTim<br>        metricsCollector.recordRequest(requestInfo);<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//MetricsCollectorProxy使用举例</span><br>MetricsCollectorProxy proxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollectorProxy</span>();<br>IUserController userController=(IUserController)proxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserC</span><br></code></pre></td></tr></table></figure>

<p>实际上，<strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建 代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。</strong></p>
<p>Spring 为这些类创建动 态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执 行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>
<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在 你的项目开发中。 </p>
<p><strong>1、业务系统的非功能性需求开发</strong> </p>
<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类 中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的 例子，就是这个应用场景的一个典型例子。 如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完 成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p>
<p><strong>2、代理模式在 RPC、缓存中的应用</strong> </p>
<p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代 理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。 </p>
<p>我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些 接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个 支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数 据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？ </p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的 接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代 码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存 接口）、集中配置（比如配置每个接口缓存过期时间）。 </p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时 候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间） 等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 （比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获 取数据直接返回。</p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。 </p>
<p><strong>代理模式的原理与实现</strong></p>
<p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情 况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原 始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法 来实现代理模式。 </p>
<p><strong>动态代理的原理与实现</strong> </p>
<p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式 的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动 态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类 对应的代理类，然后在系统中用代理类替换掉原始类。 </p>
<p><strong>代理模式的应用场景</strong></p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事 务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只 需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p>
<h1 id="桥接模式-1"><a href="#桥接模式-1" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>最难理解的模式之一，应用场景也比较局限</p>
<p>对于这个模式 有两种不同的理解方式：</p>
<p>在 GoF 的《设计模 式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。” </p>
<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个） 独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</p>
<h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>JDBC 驱动是桥接模式的经典应用。我们先来看一 下，如何利用 JDBC 驱动来查询数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-comment">//加载及注册JDBC驱动程序</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_pas</span><br><span class="hljs-string">Connection con = DriverManager.getConnection(url);</span><br><span class="hljs-string">Statement stmt = con.createStatement()；</span><br><span class="hljs-string">String query = &quot;</span>select * from test<span class="hljs-string">&quot;;</span><br><span class="hljs-string">ResultSet rs=stmt.executeQuery(query);</span><br><span class="hljs-string">while(rs.next()) &#123;</span><br><span class="hljs-string">    rs.getString(1);</span><br><span class="hljs-string">    rs.getInt(2);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵 活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置 文件就可以了。 </p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很 少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>
<p>源码之下无秘密。要弄清楚这个问题，我们先从 com.mysql.jdbc.Driver 这个类的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.jdbc;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException if a database error occurs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-comment">// Required for Class.forName().newInstance()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。 第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代 码，也就是将 MySQL Driver 注册到 DriverManager 类中。 </p>
<p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们 把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后， 后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现 类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>
<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽 象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么 是“抽象”？什么是“实现”呢？ </p>
<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。<u>JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都 委托给 Driver 来执行。</u></p>
<img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130917.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220110165339220" style="zoom:67%;" />



<h3 id="桥接模式的应用举例"><a href="#桥接模式的应用举例" class="headerlink" title="桥接模式的应用举例"></a>桥接模式的应用举例</h3><p>API 接口监控告警的例子：根据不同的告警规则，触发不 同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的 紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普 通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严 重）级别的消息会通过“自动语音电话”告知相关人员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotificationEmergencyLevel level, String message)</span>&#123;<br>        <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.SEVERE))&#123;<br>			<span class="hljs-comment">//...自动语音电话</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.URGENCY))&#123;<br>			<span class="hljs-comment">//...发微信</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.NORMAL))&#123;	<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(level.equals(NotificationEmergencyLevel.TRIVIAL))&#123;<br>			<span class="hljs-comment">//...发邮件</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际 上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支 判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。 </p>
<p>不过，Notification 的代码显然不符合这个条件。因为<u>每个 if-else 分支中的代码逻辑都比 较复杂</u>，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细 小的类，然后再通过某种更合理的结构组装在一起。 </p>
<p><u>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 （MsgSender 相关类）</u>。其中，Notification 类相当于抽象，MsgSender 类相当于实 现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意 思就是，<u>不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们 可以动态地去指定（比如，通过读取配置来获取对应关系）。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelephoneMsgSender</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>        <span class="hljs-built_in">this</span>.telephones = telephones;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">protected</span> MsgSender msgSender;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.msgSender = msgSender;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SevereNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SevereNotification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>        <span class="hljs-built_in">super</span>(msgSender);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>        msgSender.send(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrgencyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrivialNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br><span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>总体上来讲，桥接模式的原理比较难理解，但代码实现相对简单。 对于这个模式有两种不同的理解方式。在 GoF 的《设计模式》一书中，桥接模式被定义 为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更 加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式， 让这两个（或多个）维度可以独立进行扩展。” </p>
<p>对于第一种 GoF 的理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关 键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类 库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中 的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实 现”独立开发，通过对象之间的组合关系，组装在一起。</p>
<p>对于第二种理解方式，它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关 系来替代继承关系，避免继承层次的指数级爆炸。</p>
<h1 id="装饰者模式-1"><a href="#装饰者模式-1" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>它的代码结构跟桥接模式非常相似</p>
<blockquote>
<p>以下内容来自 C语言中文网，用于辅助理解</p>
</blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。</p>
<p><strong>Q：装饰器模式包含的角色</strong></p>
<p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130918.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220110173456399" style="zoom:50%;" />

<p> 装饰器模式的结构图</p>
<h3 id="Java-IO-类的“奇怪”用法"><a href="#Java-IO-类的“奇怪”用法" class="headerlink" title="Java IO 类的“奇怪”用法"></a>Java IO 类的“奇怪”用法</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130919.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220111094225907"></p>
<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120130920.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220111094255367"></p>
<p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑，比如下面这样一段代 码。我们打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类， FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓 存功能的数据读取类，可以提高数据读取的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计 一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就 可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读 取数据，用起来岂不是更加简单？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基于继承的设计方案"><a href="#基于继承的设计方案" class="headerlink" title="基于继承的设计方案"></a>基于继承的设计方案</h3><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础 之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还 算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。 </p>
<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(in);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支 持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、 BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩 展，也不好维护。这也是我们在第 10 节中讲的不推荐使用继承的原因。</p>
<h3 id="基于装饰器模式的设计方案"><a href="#基于装饰器模式的设计方案" class="headerlink" title="基于装饰器模式的设计方案"></a>基于装饰器模式的设计方案</h3><p>针对刚刚的 继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示 了 Java IO 的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现基于缓存的读数据接口...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DataInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-comment">//...实现读取基本类型数据的接口</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>看了上面的代码，你可能会问，那<strong>装饰器模式就是简单的“用组合替代继承”吗？</strong>当然不 是。<strong>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地 方。</strong> </p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong></p>
<p>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰 器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基 本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/wangzheng/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure>



<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</strong></p>
<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理 模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式 的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加 的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功 能。</u></p>
<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原 始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器 模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在 设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<h1 id="适配器模式-1"><a href="#适配器模式-1" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区-别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？</h2><p>它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类 可以一起工作。</p>
<p>对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式有两种实现方式：类适配器和对象适 配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>具体的代码 实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类适配器: 基于继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.fa();<br>	 &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>     &#125;<br>	 <span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对象适配器：基于组合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有 两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<p>如果 Adaptee 接口并不多，那两种实现方式都可以。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推 荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方 式，Adaptor 的代码量要少一些。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们 推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p>
<h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？ </p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式 算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。 前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情 况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结</p>
<p><strong>1、封装有缺陷的接口设计</strong></p>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影 响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进 行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CD</span> &#123; <span class="hljs-comment">//这个类来自外部sdk，我们无权修改它的代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uglyNamingFunction2</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tooManyParamsFunction3</span> <span class="hljs-params">( <span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB, ...)</span>&#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPerformanceFunction4</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fucntion3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.staticFunction1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.uglyNamingFucntion2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;<br>        <span class="hljs-built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">//...reimplement it...</span><br>    &#125;<br>&#125;        <br>        <br></code></pre></td></tr></table></figure>

<p><strong>2、统一多个类的接口设计</strong></p>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统 一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解 释一下。 </p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入 了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感 词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用 各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定 义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilter</span> &#123; <span class="hljs-comment">// A敏感词过滤系统提供的接口</span><br>    <span class="hljs-comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSexyWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterPoliticalWords</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// B敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// C敏感词过滤系统提供的接口</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text, String mask)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ASensitiveWordsFilter</span> <span class="hljs-variable">aFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">BSensitiveWordsFilter</span> <span class="hljs-variable">bFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CSensitiveWordsFilter</span> <span class="hljs-variable">cFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CSensitiveWordsFilter</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        maskedText = bFilter.filter(maskedText);<br>        maskedText = cFilter.filter(maskedText, <span class="hljs-string">&quot;***&quot;</span>);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用适配器模式进行改造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123; <span class="hljs-comment">// 统一接口定义</span><br>    String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilterAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> ASensitiveWordsFilter aFilter;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>        maskedText = aFilter.filterPoliticalWords(maskedText);<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="hljs-comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="hljs-comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSensitiveWordsFilter</span><span class="hljs-params">(ISensitiveWordsFilter filter)</span> &#123;<br>        filters.add(filter);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> text;<br>        <span class="hljs-keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;<br>            maskedText = filter.filter(maskedText);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maskedText;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3\替换依赖的外部系统</p>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以 减少对代码的改动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部系统A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>    &#125;<br>    <span class="hljs-comment">// 在我们的项目中，外部系统A的使用示例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>        <span class="hljs-keyword">private</span> IA a;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(IA a)</span> &#123;<br>            <span class="hljs-built_in">this</span>.a = a;<br>        &#125;<br>	<span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>    <span class="hljs-comment">// 将外部系统A替换成外部系统B</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdaptor</span> implemnts IA &#123;<br>        <span class="hljs-keyword">private</span> B b;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdaptor</span><span class="hljs-params">(B b)</span> &#123;<br>            <span class="hljs-built_in">this</span>.b= b;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>            b.fb();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br>	<span class="hljs-comment">// 只需要将BAdaptor如下注入到Demo即可。</span><br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdaptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>()));<br></code></pre></td></tr></table></figure>

<p>4\兼容老版本接口</p>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且 标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用 场景。同样，我还是通过一个例子，来进一步解释一下。 </p>
<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它 改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接 从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为 了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使 用 Iterator 才行。 </p>
<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发 的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是 不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码， 我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Emueration <span class="hljs-title function_">emumeration</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Collection c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>() &#123;<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator();<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMoreElments</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.hashNext();<br>            &#125;<br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nextElement</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> i.next():<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5\适配不同格式的数据 </p>
<p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之 间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方 便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类 型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="剖析适配器模式在-Java-日志中的应用"><a href="#剖析适配器模式在-Java-日志中的应用" class="headerlink" title="剖析适配器模式在 Java 日志中的应用"></a>剖析适配器模式在 Java 日志中的应用</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常 用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。 </p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、 erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不 像 JDBC 那样，一开始就制定了数据库操作的接口规范。 </p>
<p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选 一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框 架的选择就没那么随意了。 </p>
<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志 框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比 如，日志存储的文件地址、打印日志的格式）。</p>
<p>如果引入多个组件，每个组件使用的日志框 架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要 统一日志打印框架。 如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范， 提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需 要配合其他日志框架（log4j、logback……）来使用。 </p>
<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能 牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所 以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框 架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// slf4j统一的接口定义</span><br><span class="hljs-keyword">package</span> org.slf4j;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable t)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span>;<br><span class="hljs-comment">//...省略info、warn、error等一堆接口</span><br>&#125;<br><span class="hljs-comment">// log4j日志框架的适配器</span><br><span class="hljs-comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="hljs-comment">// 其中LocationAwareLogger继承自Logger接口，</span><br><span class="hljs-comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="hljs-keyword">package</span> org.slf4j.impl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4jLoggerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarkerIgnoringBase</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocationAwareLogger</span>, Serializable &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> org.apache.log4j.Logger logger; <span class="hljs-comment">// log4j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg1, arg2);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.arrayFormat(format, argArray);<br>            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span> &#123;<br>        logger.log(FQCN, Level.DEBUG, msg, t);<br>    &#125;<br><span class="hljs-comment">//...省略一堆接口的实现...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写 打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定 的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导 入到项目中即可。 </p>
<p>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日 志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提 供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志 框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配 器的转换，我们能就成功将 log4j 切换为了 logback。</p>
<h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结 构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封 装原始类。 </p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场 景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。 </p>
<p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是 控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 </p>
<p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相 对独立地加以改变。</p>
<p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持 多个装饰器的嵌套使用。 </p>
<p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理 模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>适配器模式有两种实现方式：类适配器和对象适配器。</p>
<p>其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样 5 种场景：</p>
<p>封装有缺陷的接口设计</p>
<p>统一多个类的接口设计</p>
<p>替换依赖的外部系统</p>
<p>兼容老版本接口</p>
<p>适配不同格式的数据</p>
<h1 id="结构型模式-下篇"><a href="#结构型模式-下篇" class="headerlink" title="结构型模式 | 下篇"></a>结构型模式 | 下篇</h1><h2 id="结构型模式总览-1"><a href="#结构型模式总览-1" class="headerlink" title="结构型模式总览"></a>结构型模式总览</h2><p>结构型模式主要总结了一 些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
<hr>
<p>门面模式：将多个接口替换为一个门面接口的调用</p>
<p>组合模式：将一组对象表示为树形结构</p>
<p>享元模式：复用不可变对象，节省内存</p>
<h2 id="设计模式使用频率-1"><a href="#设计模式使用频率-1" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220106141529342"></p>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易 用。</p>
<p>让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>1、解决易用性问题</p>
<p>Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p>
<p>2、解决性能问题</p>
<p>通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度</p>
<p>3、解决分布式事务问题</p>
<p>在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<p>场景举例一：</p>
<p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。</p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>应用举例一：开发一个棋牌游戏</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。</p>
<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间。</p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p>
<p>应用举例二：在文本编辑器中的应用</p>
<p>我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。</p>
<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java Integer 缓冲池</p>
<p>Java String 字符串常量池</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>享元模式 vs 单例、缓存、对象池</strong></p>
<p>应用单例模式是为了保证对象全局唯一。</p>
<p>应用享元模式是为了实现对象复用，节省内存。</p>
<p>缓存是为了提高访问效率，而非复用。 </p>
<p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h1 id="门面模式-1"><a href="#门面模式-1" class="headerlink" title="门面模式"></a>门面模式</h1><h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用-性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？</h2><p>原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。 </p>
<p>如果你平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？ </p>
<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需 要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>
<p>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口 不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开 发不同的接口来满足，这就会导致系统的接口无限膨胀。</p>
<h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>这个定义很简洁，我再进一步解释一下。 </p>
<p>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。 </p>
<p>不知道你会不会有这样的疑问，让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么 还要提供一个包裹 a、b、d 的接口 x 呢？关于这个问题，我通过一个具体的例子来解释一 下。 </p>
<p>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过 后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信 的，<u>网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之 间的网络通信次数</u>。 </p>
<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接 口，因自身业务的特点，不支持并发调用这三个接口。</p>
<p>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用 过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数 据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。 </p>
<p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应 用场景下，使用门面模式的意图也不同。</p>
<h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><p>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性 问题之外，还能解决其他很多方面的问题。关于这一点，我总结罗列了 3 个常用的应用场 景，你可以参考一下，举一反三地借鉴到自己的项目中。 </p>
<p>除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种 理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</p>
<p>1、解决易用性问题</p>
<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高 层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如， Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供 更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。 </p>
<p>我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表 述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲 到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要 的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接 口，封装底层实现细节。</p>
<p>2、解决性能问题</p>
<p>关于利用门面模式解决性能问题这一点，刚刚我们已经讲过了。我们通过将多个接口调用替 换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。所以，关于这 点，我就不再举例说明了。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何 组织门面接口和非门面接口？ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普 通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专 门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很 多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p>
<p>3、解决分布式事务问题</p>
<p>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。 </p>
<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了 一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景： 在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱 包（在数据库的 Wallet 表中）。 </p>
<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来 完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成 功，要么都失败，不能一个成功、一个失败。 </p>
<p><u>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。</u>虽然我 们可以通过引入<u>分布式事务框架或者事后补偿的机制</u>来解决，但代码实现都比较复杂。而最 简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的 话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。 </p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的 好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经 常说，完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不 到哪里去。 </p>
<p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在 实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基 本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口， 来提供更易用的接口。 </p>
<p>门面模式除了解决接口易用性问题之外，我们今天还讲到了其他 2 个应用场景，用它来解 决性能问题和分布式事务问题。</p>
<h1 id="组合模式-1"><a href="#组合模式-1" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全 是两码事。</p>
<p>这里讲的“组合模式”，主要是用来处理树形结构数据。</p>
<p>这里的“数据”，你可 以简单理解为一组对象集合，待会我们会详细讲解。 正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项 目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作 用，能让代码变得非常简洁。</p>
<h3 id="组合模式的原理与实现"><a href="#组合模式的原理与实现" class="headerlink" title="组合模式的原理与实现"></a>组合模式的原理与实现</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用 者。）可以统一单个对象和组合对象的处理逻辑。</p>
<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功 能： </p>
<p>动态地添加、删除某个目录下的子目录或文件； </p>
<p>统计指定目录下的文件个数； </p>
<p>统计指定目录下的文件总大小。</p>
<p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去 补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isFile;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isFile)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>        <span class="hljs-built_in">this</span>.isFile = isFile;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFile) &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>            <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> file.length();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果 我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模 （文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对 业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。 按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">protected</span> String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        java.io.<span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(path);<br>        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> file.length();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numOfFiles;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sizeofFiles;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        subNodes.add(fileOrDir);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>            subNodes.remove(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具 体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"> * /wz/</span><br><span class="hljs-comment"> * /wz/a.txt</span><br><span class="hljs-comment"> * /wz/b.txt</span><br><span class="hljs-comment"> * /wz/movies/</span><br><span class="hljs-comment"> * /wz/movies/c.avi</span><br><span class="hljs-comment"> * /xzg/</span><br><span class="hljs-comment"> * /xzg/docs/</span><br><span class="hljs-comment"> * /xzg/docs/d.txt</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">fileSystemTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/&quot;</span>);<br>        fileSystemTree.addSubNode(node_wz);<br>        fileSystemTree.addSubNode(node_xzg);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/a.txt&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/b.txt&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz_movies</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/movies/&quot;</span>);<br>        node_wz.addSubNode(node_wz_a);<br>        node_wz.addSubNode(node_wz_b);<br>        node_wz.addSubNode(node_wz_movies);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_movies_c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/movies/c.avi&quot;</span>);<br>        node_wz_movies.addSubNode(node_wz_movies_c);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg_docs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/docs/&quot;</span>);<br>        node_xzg.addSubNode(node_xzg_docs);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">node_xzg_docs_d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/xzg/docs/d.txt&quot;</span>);<br>        node_xzg_docs.addSubNode(node_xzg_docs_d);<br>        System.out.println(<span class="hljs-string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());<br>        System.out.println(<span class="hljs-string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场 景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通 过在树上的递归遍历算法来实现。 </p>
<h3 id="组合模式的应用场景举例"><a href="#组合模式的应用场景举例" class="headerlink" title="组合模式的应用场景举例"></a>组合模式的应用场景举例</h3><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子， 你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场 景，你只要“照葫芦画瓢”去设计就可以了。 假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131024.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220112152058414"></p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提 供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。 </p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的 薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这 个应用场景可以使用组合模式来设计和实现。 </p>
<p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看 一下。其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出 来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在 内存中构建组织架构图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> id;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HumanResource</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HumanResource</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Department</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (HumanResource hr : subNodes) &#123;<br>            totalSalary += hr.calculateSalary();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.salary = totalSalary;<br>        <span class="hljs-keyword">return</span> totalSalary;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(HumanResource hr)</span> &#123;<br>        subNodes.add(hr);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建组织架构的代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ORGANIZATION_ROOT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    <span class="hljs-keyword">private</span> DepartmentRepo departmentRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> EmployeeRepo employeeRepo; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Department</span> <span class="hljs-variable">rootDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(ORGANIZATION_ROOT_ID);<br>        buildOrganization(rootDepartment);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">(Department department)</span> &#123;<br>        List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long subDepartmentId : subDepartmentIds)</span> &#123;<br>            <span class="hljs-type">Department</span> <span class="hljs-variable">subDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(subDepartmentId);<br>            department.addSubNode(subDepartment);<br>            buildOrganization(subDepartment);<br>        &#125;<br>        List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.g<br>        <span class="hljs-title function_">for</span> <span class="hljs-params">(Long employeeId : employeeIds)</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> employeeRepo.getEmployeeSalary(employeeId);<br>            department.addSubNode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(employeeId, salary));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结 构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客 户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算 法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算 法来实现。 </p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一 处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组 合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也 比较局限，它并不是一种很常用的设计模式。</p>
<h1 id="享元模式-1"><a href="#享元模式-1" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h2><h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。 </p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成 享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享 元，让这些大量相似对象引用这些享元。 </p>
<p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之 后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露 任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代 码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。 </p>
<p>接下来，我们通过一个简单的例子解释一下享元模式。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房 间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋 子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋 盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一 个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<span class="hljs-comment">//棋子</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">String</span> text, Color color, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positi</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.id = id;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.text = text;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.color = color;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionX = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>.positionY = positionX;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> Color &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        RED, BLACK</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// ...省略其他属性和getter/setter方法...</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ChessBoard &#123;<span class="hljs-comment">//棋局</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> ChessBoard() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        init();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> init() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        chessPieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ChessPiece(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略摆放其他棋子的代码...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> move(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">//...省略...</span></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对 象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多）， 那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？ </p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对 象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实 际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元 供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如 下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String text;<br>    <span class="hljs-keyword">private</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPieceUnit</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.text = text;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>        RED, BLACK<br>    &#125;<br><span class="hljs-comment">// ...省略其他属性和getter方法...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnitFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        pieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));<br>        pieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessPieceUnit <span class="hljs-title function_">getChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId)</span> &#123;<br>        <span class="hljs-keyword">return</span> pieces.get(chessPieceId);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<br>    <span class="hljs-keyword">private</span> ChessPieceUnit chessPieceUnit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(ChessPieceUnit unit, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.chessPieceUnit = unit;<br>        <span class="hljs-built_in">this</span>.positionX = positionX;<br>        <span class="hljs-built_in">this</span>.positionY = positionY;<br>    &#125;<br><span class="hljs-comment">// 省略getter、setter方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<br>                ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><span class="hljs-comment">//...省略摆放其他棋子的代码...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>        <span class="hljs-comment">//...省略...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、 color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享 这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记 录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元 模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。 </p>
<p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简 单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来 达到复用的目的。 </p>
<h3 id="享元模式在文本编辑器中的应用"><a href="#享元模式在文本编辑器中的应用" class="headerlink" title="享元模式在文本编辑器中的应用"></a>享元模式在文本编辑器中的应用</h3><p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的： 如何利用享元模式来优化文本编辑器的内存占用？ 你可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们 假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简 化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信 息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。 </p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格 式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中 的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复 杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的 代码示例如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<span class="hljs-comment">//文字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>        <span class="hljs-keyword">this</span>.font = font;<br>        <span class="hljs-keyword">this</span>.size = size;<br>        <span class="hljs-keyword">this</span>.colorRGB = colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> </span>&#123;<br>        Character character = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Character</span>(c, font, size, colorRGB);<br>        chars.<span class="hljs-built_in">add</span>(character);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法， 创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十 几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可 以节省一点内存呢？ </p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设 置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使 用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyle</span> &#123;<br>    <span class="hljs-keyword">private</span> Font font;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharacterStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.font = font;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">otherStyle</span> <span class="hljs-operator">=</span> (CharacterStyle) o;<br>        <span class="hljs-keyword">return</span> font.equals(otherStyle.font)<br>                &amp;&amp; size == otherStyle.size<br>                &amp;&amp; colorRGB == otherStyle.colorRGB;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyleFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharacterStyle <span class="hljs-title function_">getStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">newStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterStyle</span>(font, size, colorRGB);<br>        <span class="hljs-keyword">for</span> (CharacterStyle style : styles) &#123;<br>            <span class="hljs-keyword">if</span> (style.equals(newStyle)) &#123;<br>                <span class="hljs-keyword">return</span> style;<br>            &#125;<br>        &#125;<br>        styles.add(newStyle);<br>        <span class="hljs-keyword">return</span> newStyle;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">private</span> CharacterStyle style;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, CharacterStyle style)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>        <span class="hljs-built_in">this</span>.style = style;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>        <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, CharacterStyleFactory.getStyle(font<br>                chars.add(character);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h3><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、 对象池这些概念有什么区别呢？我们来简单对比一下。 </p>
<p><strong>我们先来看享元模式跟单例的区别。</strong></p>
<p><u>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每 个对象被多处代码引用共享。</u>实际上，享元模式有点类似于之前讲到的单例的变体：多例。 </p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上 来看，它们是完全不同的。<u>应用享元模式是为了对象复用，节省内存，而应用多例模式是为 了限制对象的个数。</u> </p>
<p><strong>我们再来看享元模式跟缓存的区别。</strong> </p>
<p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际 上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓 存”是两回事。我们平时所讲的缓存，<u>主要是为了提高访问效率，而非复用。</u> </p>
<p><strong>最后我们来看享元模式跟对象池的区别。</strong> </p>
<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么 区别呢？ </p>
<p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象 池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。 每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。 </p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一 抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中 的“复用”实际上是不同的概念。 </p>
<p><u>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中 取一个连接，不需要重新创建）</u>。在任意时刻，每一个对象、连接、线程，并不会被多处使 用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。<u>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享 的，主要目的是节省空间。</u></p>
<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p><strong>享元模式的原理</strong></p>
<p><u>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提 是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以 利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以 减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享 元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元， 让这些大量相似对象引用这些享元。</u> </p>
<p><strong>享元模式的实现</strong> </p>
<p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。 </p>
<p><strong>享元模式 VS 单例、缓存、对象池</strong></p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是 要解决的问题。这里的区别也不例外。 </p>
<p>我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯 一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。 池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p>
<h2 id="享元模式（下）：剖析享元模式在Java-Integer、String中-的应用"><a href="#享元模式（下）：剖析享元模式在Java-Integer、String中-的应用" class="headerlink" title="享元模式（下）：剖析享元模式在Java Integer、String中 的应用"></a>享元模式（下）：剖析享元模式在Java Integer、String中 的应用</h2><h3 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>System.out.println(i1 == i2);<br>System.out.println(i3 == i4);<br></code></pre></td></tr></table></figure>

<p>如何判定两个 Java 对象是否相等（也就代码中的“==”操作符的含义）？ </p>
<p>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131025.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220112155026935"></p>
<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自 动将包装器类型转化为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>; <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure>

<p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱 操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语 句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">59</span>；底层执行了：<span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">59</span>);<br></code></pre></td></tr></table></figure>

<p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操 作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; 底层执行了：<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure>

<p>Q：Java 对象在内存中是如何存储的。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span> a = new User(<span class="hljs-number">123</span>, <span class="hljs-number">23</span>); // id=<span class="hljs-number">123</span>, age=<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>

<p>针对这条语句，我画了一张内存存储结构图，如下所示。a 存储的值是 User 对象的内存地 址，在图中就表现为 a 指向 User 对象。 </p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131026.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220112155226847"></p>
<p>当我们通过“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的 地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p>
<p>了解了 Java 的这几个语法之后，我们重新看一下开头的那段代码。</p>
<p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、 i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不 同的 Integer 对象，所以通过“==”来判定是否相同的时候，会返回 false。同理， i3==i4 判定语句也会返回 false。 </p>
<p>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这 里，你可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才 导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象 的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函 数的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>	<span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>		<span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，这里的 IntegerCache 相当于，我们上一节课中讲的生成享元对象的工厂类，只不 过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类， 你也可以自行查看 JDK 源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cache to support the object identity semantics of autoboxing for values betw</span><br><span class="hljs-comment"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The cache is initialized on first usage. The size of the cache</span><br><span class="hljs-comment"> * may be controlled by the &#123;<span class="hljs-doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="hljs-comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="hljs-comment"> * may be set and saved in the private system properties in the</span><br><span class="hljs-comment"> * sun.misc.VM class.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>)<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？ </p>
<p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性 创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值， 这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存 对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数 据）。 </p>
<p>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你 通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，你 就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没 有提供设置最小值的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br>-Djava.lang.Integer.IntegerCache.high=<span class="hljs-number">255</span><br><span class="hljs-comment">//方法二：</span><br>-XX:AutoBoxCacheMax=<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure>

<p>现在，让我们再回到最开始的问题，因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同 的享元对象，所以 i1==i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一 个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3==i4 返回 false。 </p>
<p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利 用了享元模式来缓存 -128 到 127 之间的数据。比如，Long 类型对应的 LongCache 享元 工厂类及 valueOf() 函数代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LongCache</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long cache[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[-(-<span class="hljs-number">128</span>) + <span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>            cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(i - <span class="hljs-number">128</span>);<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>            <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子， 假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们 需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。 </p>
<h3 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h3><p>刚刚我们讲了享元模式在 Java Integer 类中的应用，现在，我们再来看下，享元模式在 Java String 类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是 什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小争哥&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小争哥&quot;</span>);<br>System.out.println(s1 == s2);<br>System.out.println(s1 == s3);<br></code></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类 利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存 储结构如下所示：</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131027.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220112155710422"></p>
<p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对 象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知 道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的 时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需 要再重新创建了。 </p>
<h3 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>在 Java Integer 的实现中，-128 到 127 之间的整型对象会被事先创建好，缓存在 IntegerCache 类中。当我们使用自动装箱或者 valueOf() 来创建这个数值区间的整型对象 时，会复用 IntegerCache 类事先创建好的对象。这里的 IntegerCache 类就是享元工厂 类，事先创建好的整型对象就是享元对象。 </p>
<p>在 Java String 类的实现中，JVM 开辟一块存储区专门存储字符串常量，这块存储区叫作 字符串常量池，类似于 Integer 中的 IntegerCache。不过，跟 IntegerCache 不同的是，它并非事先创建好需要共享的对象，而是在程序的运行期间，根据需要来创建和缓存字符串 常量。 </p>
<p>除此之外，这里我再补充强调一下。 </p>
<p>实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的 引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自 动回收掉。因此，<u>在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元 模式反倒可能会浪费更多的内存。</u>所以，除非经过线上验证，利用享元模式真的可以大大节 省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模 式，得不偿失啊。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>kygeng</li>
    <li><strong>本文链接：</strong><a href="https://kygeng.github.io/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html" title="https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng.github.io&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html">https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng.github.io&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/kygeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul> 

        
  <nav class="nav">
    <a href="/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E03_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><i class="iconfont iconleft"></i>设计模式03-行为型模式</a>
    <a href="/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式01-创建型模式<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%B8%8A%E7%AF%87"><span class="toc-text">结构型模式 | 上篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-text">结构型模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87"><span class="toc-text">设计模式使用频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">代理模式：代理在RPC、缓存、监控等场景中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">代理模式的原理解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">动态代理的原理解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">代理模式的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B8%A0%E9%81%93%E7%9A%84%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-text">桥接模式：如何实现支持不同类型和渠道的消息推送系统？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">桥接模式的原理解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">桥接模式的应用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-1"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E9%80%9A%E8%BF%87%E5%89%96%E6%9E%90Java-IO%E7%B1%BB%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器模式：通过剖析Java IO类库源码学习装饰器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO-%E7%B1%BB%E7%9A%84%E2%80%9C%E5%A5%87%E6%80%AA%E2%80%9D%E7%94%A8%E6%B3%95"><span class="toc-text">Java IO 类的“奇怪”用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-text">基于继承的设计方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-text">基于装饰器模式的设计方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-2"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81%E8%A3%85%E9%A5%B0%EF%BC%8C%E8%BF%99%E5%9B%9B%E4%B8%AA%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA-%E5%88%AB%EF%BC%9F"><span class="toc-text">适配器模式：代理、适配器、桥接、装饰，这四个模式有何区 别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">适配器模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-text">适配器模式应用场景总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%96%E6%9E%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-%E6%97%A5%E5%BF%97%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">剖析适配器模式在 Java 日志中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8-4-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">代理、桥接、装饰器、适配器 4 种设计模式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-3"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%B8%8B%E7%AF%87"><span class="toc-text">结构型模式 | 下篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88-1"><span class="toc-text">结构型模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87-1"><span class="toc-text">设计模式使用频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-text">门面模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">享元模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">门面模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%B2%92%E5%BA%A6%E4%BB%A5%E5%85%BC%E9%A1%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%98%93%E7%94%A8%E6%80%A7%E5%92%8C%E9%80%9A%E7%94%A8-%E6%80%A7%EF%BC%9F"><span class="toc-text">门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用 性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">门面模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">门面模式的应用场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-4"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">组合模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">组合模式的应用场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-5"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%EF%BC%9F"><span class="toc-text">享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">享元模式原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">享元模式在文本编辑器中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-vs-%E5%8D%95%E4%BE%8B%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-text">享元模式 vs 单例、缓存、对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-6"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%89%96%E6%9E%90%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%9C%A8Java-Integer%E3%80%81String%E4%B8%AD-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">享元模式（下）：剖析享元模式在Java Integer、String中 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-Integer-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">享元模式在 Java Integer 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-String-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">享元模式在 Java String 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-7"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/kygeng.github.io/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/kygeng.github.io/js/utils.js"></script>
<script src="/kygeng.github.io/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>