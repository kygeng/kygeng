

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>设计模式01-创建型模式 - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content=", 设计模式">
  <meta name="description" content="设计模式 | 创建型模式创建型模式总览创建型模式主要解...">
  <meta name="author" content="John Doe">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">设计模式01-创建型模式</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226215039.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">设计模式01-创建型模式</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>January 07, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>45280</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="设计模式-创建型模式"><a href="#设计模式-创建型模式" class="headerlink" title="设计模式 | 创建型模式"></a>设计模式 | 创建型模式</h1><h2 id="创建型模式总览"><a href="#创建型模式总览" class="headerlink" title="创建型模式总览"></a>创建型模式总览</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 </p>
<p>单例模式：用来创建全局唯一的对象。</p>
<p>工厂模式：用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式：用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>原型模式：针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220106141529342"></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>实战案例一：处理资源访问冲突 </p>
<p>实战案例二：表示全局唯一类</p>
<p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>配置信息类：在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。 </p>
<p>唯一递增 ID 号码生成器：（区分：唯一 ID 生成器 和 唯一递增 ID 生成器）如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>SpringIoC中注入的bean，如果没有额外配置，默认是单例</p>
<p>连接池类：数据库连接池，创建一个对象，不需要修改，系统中频繁调用</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>饿汉式、懒汉式、双重检测实现方式</p>
<p>静态内部类、枚举</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建不同但是相关类型的对象（继 承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>简单工厂：</strong></p>
<p>我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<p>简单工厂模式的第一种实现方法：</p>
<p>简单工厂模式的第二种实现方法： </p>
<p>如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p>
<p><strong>工厂方法：</strong></p>
<p>简化简单工厂中的 if-else 逻辑，使用多态的方法实现</p>
<p><strong>抽象工厂：</strong></p>
<p>没有前两种常用，在简单工厂和工厂方法中，类只有一种分类方式。</p>
<p>抽象工厂让一个工厂负责创建多个不同类型的对象，而不是只创建一种对象。这样就可以有效地减少工厂类的个数。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Spring中的BeanFactory</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>简单工厂、工厂方法、抽象工厂</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<hr>
<p>当我们创建对象的时候，需要传递的参数很多，构造函数列表冗长，代码的可读性和易用性会变差</p>
<p>使用set方法设置，那么校验这些必填项是否已经填写的逻辑就无处安放</p>
<p>除此之外，假设配置项之间有一定的依赖关系，设置一个属性之后，必须要显示的设置另外几个（例如：更新余额之后，设置最后的更新时间）</p>
<p>或者创建对象时，配置项之间有一定的约束条件（例如：min &lt;= mid &lt;= max）</p>
<p>同时，我们希望创建的类的对象是不可变对象，即不能在这个类中暴露 set 方法</p>
<p>那么，我们可以，把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。</p>
<p>但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。</p>
<p>如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
<p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
<p>把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。</p>
<blockquote>
<p>创建对象的几种方式：</p>
</blockquote>
<p>（1）使用构造函数或者配合 set 方法</p>
<p>（2）使用建造者模式创建对象</p>
<p>（3）使用工厂模式创建对象</p>
<p><strong>Q：使用构造函数或者配合 set 方法就能创建对象，为什么还要用建造者模式</strong></p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p><strong>Q：建造者模式 和 工厂模式 有什么区别</strong></p>
<p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别： </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。</p>
<p><strong>Q：什么是对象创建成本比较大？</strong></p>
<p>从数据库中读取数据创建对象、创建对象时需要经过经过大量的计算</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>浅拷贝：clone</p>
<p>深拷贝：BeanUtils、递归拷贝对象和对象引用、先序列化再反序列化成新的对象</p>
<h2 id="Ex：创建对象的几种方式"><a href="#Ex：创建对象的几种方式" class="headerlink" title="Ex：创建对象的几种方式"></a>Ex：创建对象的几种方式</h2><p>1、使用 new 关键字创建对象：</p>
<p>这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造函数（无参的和有参的）。比如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Student student <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>2、反射：使用Class类的newInstance方法：</p>
<p>我们也可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：`</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Student student2 = (Student)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;根路径.Student&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;　<br></code></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> Student.class.newInstance();<br></code></pre></td></tr></table></figure>

<p>3、反射：使用Constructor类的newInstance方法</p>
<p>本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。</p>
<p>我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;Student&gt; constructor = Student.class.getInstance(); <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> constructor.newInstance();　<br></code></pre></td></tr></table></figure>

<p>这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
<p>这也是众多框架Spring、Hibernate、Struts等使用后者的原因。</p>
<p>4、使用Clone的方法：</p>
<p>无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> &lt;Student&gt;stu.clone();<br></code></pre></td></tr></table></figure>

<p>这也是原型模式的应用。</p>
<p>5、使用反序列化：</p>
<p>当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.obj&quot;</span>)); <br><span class="hljs-type">Student</span> <span class="hljs-variable">stu3</span> <span class="hljs-operator">=</span> (Student)in.readObject();<br></code></pre></td></tr></table></figure>



<p>6、另外：两种newInstance方法有没有区别？  </p>
<p>Class类位于java的lang包中，而构造器类是java反射机制的一部分。</p>
<p>Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。</p>
<p>Class类的newInstance需要其构造方法是共有的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。</p>
<p>Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常。</p>
<p>Class类本质上调用了反射包构造器类中无参数的newInstance方法，捕获了InvocationTargetException，将构造器本身的异常抛出。</p>
<h1 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="实战案例一：处理资源访问冲突"><a href="#实战案例一：处理资源访问冲突" class="headerlink" title="实战案例一：处理资源访问冲突"></a>实战案例一：处理资源访问冲突</h3><p>在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        writer.write(mesasge);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Logger类的应用示例：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(username + <span class="hljs-string">&quot; logined!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(OrderVo order)</span> &#123;<br>        <span class="hljs-comment">// ...省略业务逻辑代码...</span><br>        logger.log(<span class="hljs-string">&quot;Created an order: &quot;</span> + order.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>存在的问题：</p>
</blockquote>
<p>所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。</p>
<p>在 UserController 和 OrderController 中，我们分别创 建两个 Logger 对象。</p>
<p>在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时 分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存 在日志信息互相覆盖的情况。</p>
<blockquote>
<p>解决方案1：加对象锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被 强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同 的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p>
<blockquote>
<p>解决方案2：加类锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/wangzheng/log.txt&quot;</span>);<br>        writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true表示追加写入</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Logger.class) &#123; <span class="hljs-comment">// 类级别的锁</span><br>            writer.write(mesasge);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之 间同时调用 log() 函数，而导致的日志覆盖问题。</p>
<blockquote>
<p>其他解决方案：</p>
</blockquote>
<p>分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易 的事情。</p>
<p>除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题： 多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志 文件。这种方式实现起来也稍微有点复杂。 </p>
<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁 的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句 柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>
<h3 id="实战案例二：表示全局唯一类"><a href="#实战案例二：表示全局唯一类" class="headerlink" title="实战案例二：表示全局唯一类"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 </p>
<p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以 对象的形式存在，也理所应当只有一份。 </p>
<p>再比如，唯一递增 ID 号码生成器（区分：唯一 ID 生成器 和 唯一递增 ID 生成器），如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br>	<span class="hljs-comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br>	<span class="hljs-comment">// 比如下面会用到的incrementAndGet().</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-comment">// IdGenerator使用举例</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； </p>
<p>考虑对象创建时的线程安全问题； </p>
<p>考虑是否支持延迟加载； </p>
<p>考虑 getInstance() 性能是否高（是否加锁）。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存 多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行 为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。 </p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化 过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作， 会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作， 提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问 题。 </p>
<p>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程 序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一 段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优势是支持延迟加载</p>
<p>缺点也很明显，我们给 getInstance() 这个方法加了一把大锁 （synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于 串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用 到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低 等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>
<h4 id="双端检索"><a href="#双端检索" class="headerlink" title="双端检索"></a>双端检索</h4><p>既支持延迟 加载、又支持高并发的单例实现方式，也就是双重检测实现方式。 在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(IdGenerator.class) &#123; <span class="hljs-comment">// 此处为类级别的锁</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻 辑），就被另一个线程使用了。 </p>
<p>要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p>
<p>实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作 设计为原子操作，就自然能禁止重排序）。</p>
<p>关于这点的详细解释，跟特定语言有关，我就不 展开讲了，感兴趣的同学可以自行研究一下。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>比双重检测更加简单，利用 Java 的静态内部类，有点 类似饿汉式，但又能做到了延迟加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>









<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p><strong>单例的定义</strong></p>
<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p><strong>单例的用处</strong></p>
<p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p>
<p><strong>单例的实现</strong></p>
<p>单例有下面几种经典的实现方式。</p>
<p><strong>饿汉式</strong></p>
<p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p>
<p><strong>懒汉式</strong></p>
<p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p>
<p><strong>双重检测实现方式</strong></p>
<p>既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<p><strong>静态内部类</strong></p>
<p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p>
<p><strong>枚举</strong></p>
<p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<h2 id="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h2><h3 id="单例存在哪些问题"><a href="#单例存在哪些问题" class="headerlink" title="单例存在哪些问题?"></a>单例存在哪些问题?</h3><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。</p>
<p>单例模式书写简洁、使用方便，在代码中，我们不需要创建 对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。</p>
<p>但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体 看看到底有哪些问题。 </p>
<h4 id="1-单例对-OOP-特性的支持不友好"><a href="#1-单例对-OOP-特性的支持不友好" class="headerlink" title="1.单例对 OOP 特性的支持不友好"></a>1.单例对 OOP 特性的支持不友好</h4><p>单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来 讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">//...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(...)</span> &#123;<br>		<span class="hljs-comment">// ...</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br>		<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要 修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。</p>
<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词， 而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是 实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计， 会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多 态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>
<h4 id="2-单例会隐藏类之间的依赖关系"><a href="#2-单例会隐藏类之间的依赖关系" class="headerlink" title="2.单例会隐藏类之间的依赖关系"></a>2.单例会隐藏类之间的依赖关系</h4><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间 的依赖关系，搞清楚这个类依赖了哪些外部类。 通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。</p>
<p>但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需 要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>
<h4 id="3-单例对代码的扩展性不友好"><a href="#3-单例对代码的扩展性不友好" class="headerlink" title="3.单例对代码的扩展性不友好"></a>3.单例对代码的扩展性不友好</h4><p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例 或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类 大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p>
<p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。 </p>
<p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资 源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p>
<p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。 如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例 类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源 池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设 计成单例类。</p>
<h4 id="4-单例对代码的可测试性不友好"><a href="#4-单例对代码的可测试性不友好" class="headerlink" title="4.单例对代码的可测试性不友好"></a>4.单例对代码的可测试性不友好</h4><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。 </p>
<p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上 相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是 说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用 例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>
<h5 id="5-单例不支持有参数的构造函数"><a href="#5-单例不支持有参数的构造函数" class="headerlink" title="5.单例不支持有参数的构造函数"></a>5.单例不支持有参数的构造函数</h5><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来 指定连接池的大小。</p>
<p>针对这个问题，我们来看下都有哪些解决方案。 </p>
<p>第一种解决思路是：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在 使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = paramA;<br>        <span class="hljs-built_in">this</span>.paramB = paramB;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Run init() first.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Singleton has been created!&quot;</span>);<br>        &#125;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(paramA, paramB);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br>Singleton.init(<span class="hljs-number">10</span>,<span class="hljs-number">50</span>); <span class="hljs-comment">// 先init，再使用</span><br>Singleton singleton=Singleton.getInstance();<br></code></pre></td></tr></table></figure>

<p>第二种解决思路是：将参数放到 getIntance() 方法中。具体的代码实现如下所示：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>= null;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramA;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>paramB;<br>   <span class="hljs-keyword"> private</span> Singleton(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    &#125;<br>   <span class="hljs-keyword"> public</span> synchronized<span class="hljs-keyword"> static</span> Singleton getInstance(int paramA,<span class="hljs-built_in"> int </span>paramB) &#123;<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton(paramA, paramB);<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br>Singleton singleton = Singleton.getInstance(10, 50);<br></code></pre></td></tr></table></figure>

<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提 示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的 解决思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>

<p>第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一 个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态 常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fianl <span class="hljs-type">int</span> <span class="hljs-variable">PARAM_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">245</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> paramB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramA = Config.PARAM_A;<br>        <span class="hljs-built_in">this</span>.paramB = Config.PARAM_B;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有何替代方案"><a href="#有何替代方案" class="headerlink" title="有何替代方案"></a>有何替代方案</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常 用到的一种实现思路。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 静态方法实现方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGenerator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> id.<span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">long</span> id = IdGenerator.getId();<br></code></pre></td></tr></table></figure>

<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。</p>
<p>我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一个种使用方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 1. 老的使用方式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">long</span> id = IdGenerator.getInstance().getId();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// 2. 新的使用方式：依赖注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demofunction</span>(<span class="hljs-params">IdGenerator idGenerator</span>)</span> &#123;<br>    <span class="hljs-built_in">long</span> id = idGenerator.getId();<br>&#125;<br><span class="hljs-comment">// 外部调用demofunction()的时候，传入idGenerator</span><br>IdGenerator idGenerator = IdGenerator.getInsance();<br>demofunction(idGenerator);<br></code></pre></td></tr></table></figure>

<p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传 递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其 他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。 </p>
<p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实 际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强 制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程 序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。 </p>
<p>对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面的章节中讲解。</p>
<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>1.单例存在哪些问题？</p>
<p>单例对 OOP 特性的支持不友好</p>
<p>单例会隐藏类之间的依赖关系</p>
<p>单例对代码的扩展性不友好</p>
<p>单例对代码的可测试性不友好</p>
<p>单例不支持有参数的构造函数</p>
<p>2.单例有什么替代解决方案？</p>
<p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p>
<p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<h2 id="单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？"><a href="#单例模式（下）：如何设计实现一个集群环境下的分布式单例模-式？" class="headerlink" title="单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？"></a>单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？</h2><h3 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h3><h3 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h3><h3 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h3><h3 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h3><h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p>
<p>今天的内容比较偏理论，在实际的项目开发中，没有太多的应用。讲解的目的，主要还是拓展你的思路，锻炼你的逻辑思维能力，加深你对单例的认识。</p>
<p>1.如何理解单例模式的唯一性？</p>
<p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<p>2.如何实现线程唯一的单例？</p>
<p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<p>3.如何实现集群环境下的单例？</p>
<p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p>4.如何实现一个多例模式？</p>
<p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p>
<h1 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h2><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过， 在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以 工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所 以，在今天的讲解中，我们沿用第一种分类方法。</p>
<h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。 </p>
<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath)<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>		<span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。</p>
<p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfig<br>        <span class="hljs-title function_">if</span> <span class="hljs-params">(parser == <span class="hljs-literal">null</span>)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>                    <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>            parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时 候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>        cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>        <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>        &#125;<br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解 中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作 简单工厂模式的第二种实现方法。 </p>
<h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按 照多态的实现思路，对上面的代码进行重构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFact</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需 要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模 式比起简单工厂模式更加符合开闭原则。</p>
<p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong> </p>
<p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻 辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不 复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。 </p>
<p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。</p>
<p>抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。 </p>
<p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析 器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方 式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nsis">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br>针对系统配置的解析器：基于接口I<span class="hljs-params">System</span>ConfigParser<br>Json<span class="hljs-params">System</span>ConfigParser<br>Xml<span class="hljs-params">System</span>ConfigParser<br>Yaml<span class="hljs-params">System</span>ConfigParser<br>Properties<span class="hljs-params">System</span>ConfigParser<br></code></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编 写一个工厂类，也就是要编写 8 个工厂类。</p>
<p>如果我们未来还需要增加针对业务配置的解析 器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。</p>
<p>而我们知道，过多的类 也会让系统难维护。这个问题该怎么解决呢？ </p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类 型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>();<br>    <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>();<br><span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRuleConfigParser</span> <span class="hljs-title function_">createRuleParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ISystemConfigParser</span> <span class="hljs-title function_">createSystemParser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景 进行总结。 </p>
<p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>
<p>何为创建逻辑比较复杂呢？我总结了下面两种情况。 </p>
<ul>
<li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。 </p>
</li>
<li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中</p>
</li>
</ul>
<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p>
<p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。 </p>
<p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不 要使用工厂模式的最本质的参考标准。 </p>
<ul>
<li><p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。 </p>
</li>
<li><p>代码复用：创建代码抽离到独立的工厂类之后可以复用。 </p>
</li>
<li><p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 </p>
</li>
<li><p>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</p>
</li>
</ul>
<h2 id="工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>工厂模式（下）：如何设计实现一个Dependency Injection框架？</h2><h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获 取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周 期管理。 </p>
<blockquote>
<p>首先，我们来看配置解析。 </p>
</blockquote>
<p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类 代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事 先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。</p>
<p>所 以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲 的配置。 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提 供的信息来创建对象</p>
<p>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创 建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依 赖 redisCounter。</p>
<blockquote>
<p>其次，我们再来看对象创建。 </p>
</blockquote>
<p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加， 这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。</p>
<p>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码 量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我 们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事 先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。 </p>
<p>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加 载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对 象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。 但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运 行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自 动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</p>
<blockquote>
<p>最后，我们来看对象的生命周期管理。 </p>
</blockquote>
<p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一 种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。</p>
<p>在 Spring 框架中，我 们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返 回新创建的对象，scope=singleton 表示返回单例对象。 除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用 到的时候（比如:BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。 </p>
<p>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对 象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之 前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数 据库连接池、关闭文件。</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。但是，大 部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当 然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂 的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直 接影响到我们排查问题的效率。 </p>
<p>今天，我们讲解了一个简单的 DI 容器的实现原理，其核心逻辑主要包括：配置文件解析， 以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在 学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程 序员聚焦在业务代码的开发上。</p>
<h1 id="建造者模式-1"><a href="#建造者模式-1" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。 </p>
<p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。</p>
<p>比如，你有没有考虑过这样几个问题：</p>
<p>直接使用构造函数或者配合 set 方法就能创建对象，为 什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>
<h3 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h3><p>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？ 你可以先思考一下，下面我通过一个例子来带你看一下。 </p>
<p>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这 里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以 下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155842.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220110155833218"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Int</span><br><span class="hljs-params">   </span><br><span class="hljs-params">    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;   <br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数， 参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变 差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非 常隐蔽的 bug。</p>
<p>解决这个问题的办法你应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代 冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以 我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填 写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选 配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下 面这三个问题，那现在的设计思路就不能满足了。</p>
<ul>
<li><p>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时 候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构 造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校 验这些必填项是否已经填写的逻辑就无处安放了。 </p>
</li>
<li><p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的 设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。 </p>
</li>
<li><p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之 后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p>
</li>
</ul>
<p>为了解决这些问题，建造者模式就派上用场了。 </p>
<h3 id="如何使用建造者模式"><a href="#如何使用建造者模式" class="headerlink" title="如何使用建造者模式"></a>如何使用建造者模式</h3><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者 的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会 创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。 这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且， ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = builder.name;<br>        <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>        <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>        <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>    &#125;<br>    <span class="hljs-comment">//...省略getter方法...</span><br><br>    <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>	<span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>        <br>        <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>            <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br>    <span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>            .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>            .setMaxTotal(<span class="hljs-number">16</span>)<br>            .setMaxIdle(<span class="hljs-number">10</span>)<br>            .setMinIdle(<span class="hljs-number">12</span>)<br>            .build();<br></code></pre></td></tr></table></figure>

<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。 比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会 导致在第一个 set 之后，对象处于无效状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure>

<p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。 如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一 次性地创建对象，让对象一直处于有效状态。 实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变 的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的 成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复 的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</p>
<h3 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h3><p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节 课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？ </p>
<p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子 类），由给定的参数来决定创建哪种类型的对象。</p>
<p>建造者模式是用来创建一种类型的复杂对 象，通过设置不同的可选参数，“定制化”地创建不同的对象。 </p>
<p>网上有一个经典的例子很好地解释了两者的区别。 </p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比 如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起 司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 </p>
<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道 的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才 能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用</p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一 种，我们就要考虑使用建造者模式了。 </p>
<p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的 问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻 辑就无处安放了。 </p>
<p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方 法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。 </p>
<p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属 性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来 设置属性值的方式就不适用了。</p>
<p>除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来 创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定 创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可 选参数，“定制化”地创建不同的对象。</p>
<h1 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式：如何最快速地clone一个HashMap散列表？"><a href="#原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="原型模式：如何最快速地clone一个HashMap散列表？"></a>原型模式：如何最快速地clone一个HashMap散列表？</h2><p>JavaScript 是一种基于原型的面 向对象编程语言。即便 JavaScript 现在也引入了类的概念，但它也只是基于原型的语法糖 而已。</p>
<h3 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。 </p>
<p><strong>那何为“对象的创建成本比较大”？</strong> </p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。</p>
<p>应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。 </p>
<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。</p>
<p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong> </p>
<p>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜 索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用 于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建 立一个散列表索引。</p>
<p>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中， HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。</p>
<p>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量 地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删 除关键词的行为。</p>
<p>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定 期根据数据库中的数据，更新内存中的索引和数据。</p>
<p>我们该如何实现这个需求呢？ </p>
<p>实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta， 从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据 的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们 就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散 列表中。</p>
<p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版 本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更 新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。 </p>
<p>那我们该如何实现现在这个需求呢？ </p>
<p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中 的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建 另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版 本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<p>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数 据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为 了提高效率，<u>原型模式就派上用场了</u>。</p>
<p>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有 更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新 的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<p>里我们利用了 Java 中的 clone() 语法来复制一个对象</p>
<h3 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h3><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷 贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图 所示：</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155940.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220110153656490"></p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155942.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220110153706912"></p>
<p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存 地址，不会递归地拷贝引用对象本身。</p>
<p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。 </p>
<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Deep copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>                    searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas<br>                    newKeywords.put(e.getKey(), newSearchWord);<br>        &#125;<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>                oldSearchWord.setCount(searchWord.getCount());<br>                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                newKeywords.put(searchWord.getKeyword(), searchWord);<br>            &#125;<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span>&#123;<br>        ByteArrayOutputStream bo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        ObjectOutputStream oo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>        oo.writeObject(object);<br>        ByteArrayInputStream bi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>        ObjectInputStream oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>        <br>        <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这 个应用场景，有没有更快、更省内存的实现方式呢？ </p>
<p>我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象， 我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需 要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题 中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Shallow copy</span><br>        HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) cu<br>        <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>        <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>            <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>                maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>                newKeywords.remove(searchWord.getKeyword());<br>            &#125;<br>            newKeywords.put(searchWord.getKeyword(), searchWord);<br>        &#125;<br>        lastUpdateTime = maxNewUpdatedTime;<br>        currentKeywords = newKeywords;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>1.什么是原型模式？ </p>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建 新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模 式，简称原型模式。 </p>
<p>2.原型模式的两种实现方法</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。</p>
<p>浅拷贝只会复制对象中基本数据类型数据和引 用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到 的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空 间。 </p>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来 说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就 变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载 10 万条数据并 构建散列表索引，操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了 一点点的性能提升而使用浅拷贝。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>John Doe</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E01_%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul> 

        
  <nav class="nav">
    <a href="/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><i class="iconfont iconleft"></i>设计模式02-结构型模式</a>
    <a></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式 | 创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-text">创建型模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87"><span class="toc-text">设计模式使用频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ex%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">Ex：创建对象的几种方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%94%AF%E6%8C%81%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E4%B8%8D%E6%AF%94%E9%A5%BF%E6%B1%89%E5%BC%8F%E6%9B%B4%E4%BC%98%EF%BC%9F"><span class="toc-text">单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%A4%84%E7%90%86%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%86%B2%E7%AA%81"><span class="toc-text">实战案例一：处理资源访问冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E8%A1%A8%E7%A4%BA%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E7%B1%BB"><span class="toc-text">实战案例二：表示全局唯一类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-text">如何实现一个单例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%8F%88%E6%9C%89%E4%BD%95%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">单例存在哪些问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BD%95%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-text">有何替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-1"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1-%E5%BC%8F%EF%BC%9F"><span class="toc-text">单例模式（下）：如何设计实现一个集群环境下的分布式单例模 式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F"><span class="toc-text">如何理解单例模式中的唯一性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-text">如何实现线程唯一的单例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-text">如何实现集群环境下的单例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">如何实现一个多例模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-2"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%B2%A1%E4%BA%8B%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%88Simple-Factory%EF%BC%89"><span class="toc-text">简单工厂（Simple Factory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%88Factory-Method%EF%BC%89"><span class="toc-text">工厂方法（Factory Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%88Abstract-Factory%EF%BC%89"><span class="toc-text">抽象工厂（Abstract Factory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-3"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AADependency-Injection%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-text">工厂模式（下）：如何设计实现一个Dependency Injection框架？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C-DI-%E5%AE%B9%E5%99%A8%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">工厂模式和 DI 容器有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DI-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">DI 容器的核心功能有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-4"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%AF%A6%E8%A7%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81set%E6%96%B9%E6%B3%95%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">为什么需要建造者模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">如何使用建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">与工厂模式有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-5"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9C%80%E5%BF%AB%E9%80%9F%E5%9C%B0clone%E4%B8%80%E4%B8%AAHashMap%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">原型模式：如何最快速地clone一个HashMap散列表？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-text">原型模式的原理与应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">原型模式的实现方式：深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-6"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>