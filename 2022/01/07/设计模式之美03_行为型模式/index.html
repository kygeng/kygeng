

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>设计模式03-行为型模式 - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content=", 设计模式">
  <meta name="description" content="行为型模式 | 上篇行为型模式总览创建型设计模式：主要...">
  <meta name="author" content="kygeng">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/kygeng.github.io/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">设计模式03-行为型模式</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226215039.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">设计模式03-行为型模式</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>January 07, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>140765</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="行为型模式-上篇"><a href="#行为型模式-上篇" class="headerlink" title="行为型模式 | 上篇"></a>行为型模式 | 上篇</h1><h2 id="行为型模式总览"><a href="#行为型模式总览" class="headerlink" title="行为型模式总览"></a>行为型模式总览</h2><p>创建型设计模式：主要解决“对象的创建”问题</p>
<p>结构型设计模式：主要解决“类或对象的组合或组装”问题</p>
<p>行为型设计模式：主要解决“类或对象之间的交互”问题</p>
<hr>
<p>创建型模式：将创建和使用代码解耦</p>
<p>结构型模式：将不同的功能代码解耦</p>
<p>行为型模式：将不同的行为代码解耦</p>
<hr>
<p>观察者模式：发布订阅模式，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>
<p>模板方法模式：让子类在不改变业务逻辑整体结构的情况下，重新定义其中的某些步骤</p>
<p>策略模式：解耦策略的定义、创建和使用，控制代码的复杂度</p>
<p>职责链模式：多个处理器依次处理同一个请求</p>
<p>迭代器模式：遍历集合对象</p>
<p>状态模式：将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</p>
<hr>
<p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</p>
<p>备忘录模式：存储副本以便后期恢复</p>
<p>命令模式：将函数封装成对象，把函数像对象一样使用</p>
<p>解释器模式：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</p>
<p>中介模式：一组对象之间的交互关系从多对多（网状关系）转换为一对多（星状关系）</p>
<h2 id="设计模式使用频率"><a href="#设计模式使用频率" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131102.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220112162840676"></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式</p>
<p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依 赖的对象都会自动收到通知。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现 方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<hr>
<p>实战案例一：P2P 投资理财系统</p>
<p>用户注册成功之后，我们会给用户发放投资体验金</p>
<p>如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠 券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地 修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操 作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维 护性。</p>
<p>用户注册成功之后，推送用户注册信息给大数据 征信系统</p>
<p>当我们把发送体验金替换为发送优惠券的时候</p>
<hr>
<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能 短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。</p>
<p>如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信 系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者 模式呢？</p>
<p>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现 思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优 雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。</p>
<p>模板模式主要是用来解决<strong>复用和扩展</strong>两个问题</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>模板模式作用一：复用</p>
<p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变 的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。 所有的子类都可以复用父类中模板方法定义的流程代码。</p>
<p>模板模式作用二：扩展</p>
<p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转。基于这个 作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化 框架的功能。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>模板模式作用一：复用</p>
<p>Java InputStream、Java AbstractList</p>
<p>模板模式作用二：扩展</p>
<p>Java Servlet、JUnit TestCase</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的 方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现 比较灵活，以上两点都不是必须的。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：什么是回调？</strong></p>
<p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>
<p>通 过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果 返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统， 等三方支付系统执行完成之后，将结果通过回调接口返回给用户。 </p>
<p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调 函数；异步回调指的是在函数返回之后执行回调函数。</p>
<p><strong>应用举例一：JdbcTemplate</strong> </p>
<p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于 回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以， 在命名上，这些类使用 Template（模板）这个单词作为后缀。</p>
<p><strong>应用举例二：setClickListener(）</strong> </p>
<p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<p><strong>应用举例三：addShutdownHook()</strong> </p>
<p>Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？ 网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉 得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用 场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能 认识，遇到场景会用就可以了。</p>
<p><strong>Q：模板模式 vs 回调</strong></p>
<p>从应用场景上来看同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。 </p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。 </p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点。</p>
<p>1、像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。 </p>
<p>2、回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。 </p>
<p>3、如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略 模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部 分。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<p><strong>个人理解：</strong> </p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过， 它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p>
<p>实战案例一：利用策略模式避免分支判断</p>
<p>实战案例二：实现一个支持给不同大小文件排序的小程序</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>1、策略的定义</p>
<p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略 类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策 略。</p>
<p>2、策略的创建 </p>
<p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建 哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根 据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的 都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实 现策略工厂类。</p>
<p>3、策略的使用</p>
<p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见 的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它 为止。</p>
<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再 传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职 责，所以叫作职责链模式。</p>
<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往 下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一 遍，不存在中途终止的情况。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说， 用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、 反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。 </p>
<p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打 马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链 模式的定义，第二种处理方式是职责链模式的变体。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p><strong>Servlet Filter</strong></p>
<p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规 范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支 持过滤器功能。</p>
<p><strong>Spring Interceptor</strong> </p>
<p>刚刚讲了 Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上 可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。 </p>
<p>它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处 理器，后面一种实现方式更加简单。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>状态模式是状 态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动 作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须 的，也可能只转移状态，不执行任何动作。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>状态机实现方式一：分支逻辑法</p>
<p>参照状态转移 图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为 分支逻辑法。</p>
<p>状态机实现方式二：查表法</p>
<p>除了用状态转移图来表示之外，状态机还可以用二维表来表示，在这个 二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到 的新状态及其执行的动作。</p>
<p>状态机实现方式三：状态模式</p>
<p>如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能 发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的 实现方式有一定局限性。</p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断 逻辑。</p>
<hr>
<p>像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状 态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种 类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业 务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p>
<hr>
<p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移 图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简 单、最直接，是首选。 </p>
<p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合 适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。 </p>
<p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动 作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）</p>
<p>用来遍历集合对象，这里说的“集合对象”也可以叫“容器”“聚合 对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将 集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>迭代器模式。它用来遍历集合对象。不过，很多 编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开 发，我们直接使用即可，很少会自己去实现一个迭代器。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中的迭代器类</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非 实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实 现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代 器类中。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：使用迭代器的优势</strong></p>
<p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一 种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p>
<p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器 提供的迭代器即可； </p>
<p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职 责更加单一； </p>
<p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都 实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<p><strong>Q：遍历集合元素的同时，增加或者删除集合中的元素？</strong></p>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出 错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。 </p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候 不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很 难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解 决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<p><strong>Q：如何实现一个支持“快照”功能的迭代器？</strong></p>
<p>1、创建副本，迭代过程中在副本集上遍历</p>
<p>2、为每个元素添加 创建时间createTime，删除时间deleteTime，删除元素时，更新删除时间，在迭代的过程中，只迭代当前时间 currentTime &lt; 删除时间 deleteTime</p>
<h1 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式（上）：详解各种应用场景下观察者模式的不同实现-方式"><a href="#观察者模式（上）：详解各种应用场景下观察者模式的不同实现-方式" class="headerlink" title="观察者模式（上）：详解各种应用场景下观察者模式的不同实现 方式"></a>观察者模式（上）：详解各种应用场景下观察者模式的不同实现 方式</h2><p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：</p>
<p>有同步阻塞的实现 方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h3 id="原理及应用场景剖析"><a href="#原理及应用场景剖析" class="headerlink" title="原理及应用场景剖析"></a>原理及应用场景剖析</h3><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。 一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者 （Observer）。</p>
<p>不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不 同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、 EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合 刚刚给出的定义，都可以看作观察者模式。</p>
<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实 现方式</p>
<p>现在，我们先来看其中最经典的一种实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.remove(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>        System.out.println(<span class="hljs-string">&quot;ConcreteObserverOne is notified.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>        System.out.println(<span class="hljs-string">&quot;ConcreteObserverTwo is notified.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverOne</span>());<br>        subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverTwo</span>());<br>        subject.notifyObservers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。</p>
<p>观察者模式的实现方法各式各样，函数、类的 命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach， remove 函数还可以叫作 detach 等等。不过，万变不离其宗</p>
<hr>
<p>P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验 金。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br><span class="hljs-comment">//省略输入参数的校验代码</span><br><span class="hljs-comment">//省略userService.register()异常的try-catch代码</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>        promotionService.issueNewUserExperienceCash(userId);<br>        <span class="hljs-keyword">return</span> userId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展 和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的 类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠 券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地 修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操 作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维 护性。</p>
<p>这个时候，观察者模式就能派上用场了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点：setRegObservers</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 一次性设置好，之后也不可能动态的修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRegObservers</span><span class="hljs-params">(List&lt;RegObserver&gt; observers)</span> &#123;<br>        regObservers.addAll(observers);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>		<span class="hljs-comment">//省略输入参数的校验代码</span><br>		<span class="hljs-comment">//省略userService.register()异常的try-catch代码</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>        <span class="hljs-keyword">for</span> (RegObserver observer : regObservers) &#123;<br>            observer.handleRegSuccess(userId);<br>        &#125;<br>        <span class="hljs-keyword">return</span> userId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点：interface RegObserver</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegPromotionObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>        promotionService.issueNewUserExperienceCash(userId);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegNotificationObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>    <span class="hljs-keyword">private</span> NotificationService notificationService;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>        notificationService.sendInboxMessage(userId, <span class="hljs-string">&quot;Welcome...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据 征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要 修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。 </p>
<p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改 RegPromotionObserver 类中 handleRegSuccess() 函数的代码，这还是违反开闭原则 呀？你说得没错，不过，相对于 register() 函数来说，handleRegSuccess() 函数的逻辑要 简单很多，修改更不容易出错，引入 bug 的风险更低。</p>
<p>实际上，<strong>设计模式要干的事情就 是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型 模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借 助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足 开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<h3 id="基于不同应用场景的不同实现方式"><a href="#基于不同应用场景的不同实现方式" class="headerlink" title="基于不同应用场景的不同实现方式"></a>基于不同应用场景的不同实现方式</h3><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。 </p>
<p>不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有 同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实 现方式。 </p>
<p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。<strong>观察者和 被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成 之后，才执行后续的代码。</strong>对照上面讲到的用户注册的例子，register() 函数依次调用执行 每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户 端。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能 短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。 具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所 有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。 </p>
<p>userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。</p>
<p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实 现方式，那就是基于 EventBus 来实现。今天，我们就不展开讲解了。</p>
<p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实 现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信 系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者 模式呢？ </p>
<p>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现 思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优 雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</p>
<p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成 本。不过，<u>它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被 观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解 耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知 被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相 应的逻辑。</u></p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同 功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单 一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提 高代码的可扩展性。 </p>
<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者 一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观 察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实 现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h2 id="观察者模式（下）：如何实现一个异步非阻塞的EventBus框-架？"><a href="#观察者模式（下）：如何实现一个异步非阻塞的EventBus框-架？" class="headerlink" title="观察者模式（下）：如何实现一个异步非阻塞的EventBus框 架？"></a>观察者模式（下）：如何实现一个异步非阻塞的EventBus框 架？</h2><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；</p>
<p>异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；</p>
<p>进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<h3 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h3><h3 id="EventBus-框架功能需求介绍"><a href="#EventBus-框架功能需求介绍" class="headerlink" title="EventBus 框架功能需求介绍"></a>EventBus 框架功能需求介绍</h3><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框 架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p>
<p>其中， Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞 模式，同时也支持同步阻塞模式</p>
<h3 id="手把手实现一个-EventBus-框"><a href="#手把手实现一个-EventBus-框" class="headerlink" title="手把手实现一个 EventBus 框"></a>手把手实现一个 EventBus 框</h3><h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。 </p>
<p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让 程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样 的效果，而这个框架就是我们这节课讲的 EventBus。EventBus 翻译为“事件总线”，它 提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中 实现观察者模式，不需要从零开始开发。 </p>
<p>很多人觉得做业务开发没有技术挑战，实际上，做业务开发也会涉及很多非业务功能的开 发，比如今天讲到的 EventBus。在平时的业务开发中，我们要善于抽象这些非业务的、可 复用的功能，并积极地把它们实现成通用的框架。</p>
<h1 id="模板模式-1"><a href="#模板模式-1" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中-的应用"><a href="#模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中-的应用" class="headerlink" title="模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中 的应用"></a>模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中 的应用</h2><p>模板模式主要是用来解决<strong>复用和扩展</strong>两个问题。</p>
<p>我们今天会结合 Java Servlet、 JUnit TestCase、Java InputStream、Java AbstractList 四个例子来具体讲解这两个作 用。</p>
<h3 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h3><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。 </p>
<p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中 的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也 是模板方法模式名字的由来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>        method1();<br><span class="hljs-comment">//...</span><br>        method2();<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> ConcreteClass1();<br>demo.templateMethod();<br></code></pre></td></tr></table></figure>

<h3 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h3><p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。 </p>
<p>模板模式<u>把一个算法中不变的流程抽象到父类的模板方法</u> templateMethod() 中，<u>将可变 的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现</u>。 所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体 会一下。</p>
<h4 id="1-Java-InputStream"><a href="#1-Java-InputStream" class="headerlink" title="1.Java InputStream"></a>1.Java InputStream</h4><p>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、 Reader、Writer。我们拿 InputStream 来举例说明一下。 </p>
<p>我把 InputStream 部分相关代码贴在了下面。在代码中，read() 函数是一个模板方法，定 义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br>    <span class="hljs-comment">//重点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <br>    <span class="hljs-comment">//...省略其他代码...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> read();<br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-type">byte</span>)c;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-type">byte</span>)c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteArrayInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="hljs-number">0xff</span>) : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-Java-AbstractList"><a href="#2-Java-AbstractList" class="headerlink" title="2.Java AbstractList"></a>2.Java AbstractList</h4><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方 法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index,Collection&lt;?extends E&gt; c)</span>&#123;<br>        rangeCheckForAdd(index);<br>        <span class="hljs-type">boolean</span> modified=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(E e:c)&#123;<br>            <span class="hljs-comment">//重点：在这里调用add</span><br>            add(index++,e);<br>            modified=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> modified;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h3><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转，你可以结合第 19 节来一块理解。</p>
<p>基于这个 作用，模板模式常用在框架的开发中，让框架用户可以<u>在不修改框架源码的情况下，定制化 框架的功能</u>。我们通过 Junit TestCase、Java Servlet 两个例子来解释一下。</p>
<h4 id="1-Java-Servlet"><a href="#1-Java-Servlet" class="headerlink" title="1.Java Servlet"></a>1.Java Servlet</h4><p>对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注 业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不 难。我们只需要<strong>定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求。</strong></p>
<p>当我们在浏览器中输入网址（比如，<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容 器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p>
<p>我们现在来看，HttpServlet 的 service() 函数长什么样子。</p>
<p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。</p>
<p>实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架 用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>
<h4 id="2-JUnit-TestCase"><a href="#2-JUnit-TestCase" class="headerlink" title="2.JUnit TestCase"></a>2.JUnit TestCase</h4><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、 tearDown() 等），让框架用户可以在这些扩展点上扩展功能。 </p>
<p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的 整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后 执行 tearDown() 做扫尾工作。</p>
<p>TestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了 默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模 板模式的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Assert</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        setUp();<br>        <span class="hljs-keyword">try</span> &#123;<br>            runTest();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable running) &#123;<br>            exception = running;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tearDown();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable tearingDown) &#123;<br>                <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) exception = tearingDown;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> exception;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets up the fixture, for example, open a network connection.</span><br><span class="hljs-comment">     * This method is called before a test is executed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tears down the fixture, for example, close a network connection.</span><br><span class="hljs-comment">     * This method is called after a test is executed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法 模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算 法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这 里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式 名字的由来。 </p>
<p><strong>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的 方法定义为 abstract，可以强迫子类去实现。</strong>不过，在实际项目开发中，模板模式的实现 比较灵活，以上两点都不是必须的。</p>
<p>模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的 模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修 改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h2 id="模板模式（下）：模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式（下）：模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式（下）：模板模式与Callback回调函数有何区别和联系？"></a>模板模式（下）：模板模式与Callback回调函数有何区别和联系？</h2><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式 相同的作用，那就是回调（Callback）。</p>
<h3 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h3><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。<strong>A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</strong> </p>
<p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使 用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。这里我用 Java 语言举例说明一下。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICallback</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodToCallback</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(ICallback callback)</span> &#123;<br><span class="hljs-comment">//...</span><br>        callback.methodToCallback();<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BClass</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BClass</span>();<br>        b.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ICallback</span>() &#123; <span class="hljs-comment">//回调对象</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodToCallback</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Call back me.&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是 Java 语言中回调的典型代码实现。从代码实现中，我们可以看出，回调跟模板模 式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的 逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代 码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能 力。</p>
<p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通 过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果 返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统， 等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>
<p><strong>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调 函数；异步回调指的是在函数返回之后执行回调函数。</strong>上面的代码实际上是同步回调的实现 方式，在 process() 函数返回之前，执行完回调函数 methodToCallback()。而上面支付的 例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。<strong>从应用 场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</strong></p>
<h3 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h3><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于 回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以， 在命名上，这些类使用 Template（模板）这个单词作为后缀。 </p>
<p>这些 Template 类的设计思路都很相近，所以，我们只拿其中的 JdbcTemplate 来举例分 析一下。对于其他 Template 类，你可以阅读源码自行分析。 </p>
<p>在前面的章节中，我们也多次提到，Java 提供了 JDBC 类库来封装不同类型的数据库操 作。不过，直接使用 JDBC 来编写操作数据库的代码，还是有点复杂的。比如，下面这段 是使用 JDBC 来查询用户信息的代码。</p>
<p>queryUser() 函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连 接、创建 statement、关闭连接、关闭 statement、处理异常。针对不同的 SQL 执行请 求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。 </p>
<p>针对这个问题，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来简化数据库编 程。使用 JdbcTemplate 查询用户信息，我们只需要编写跟这个业务有关的代码，其中包 括，查询用户的 SQL 语句、查询结果与 User 对象之间的映射关系。其他流程性质的代码 都封装在了 JdbcTemplate 类中，不需要我们每次都重新编写。我用 JdbcTemplate 重写 了上面的例子，代码简单了很多，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">queryUser</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where id=&quot;</span>+id;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRowMapper</span>()).get(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRowMapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RowMapper</span>&lt;User&gt; &#123;<br>        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setId(rs.getLong(<span class="hljs-string">&quot;id&quot;</span>));<br>            user.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            user.setTelephone(rs.getString(<span class="hljs-string">&quot;telephone&quot;</span>));<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那 JdbcTemplate 底层具体是如何实现的呢？我们来看一下它的源码。</p>
<p>其中， JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。</p>
<h3 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h3><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> (Button)findViewById(R.id.button);<br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;I am clicked.&quot;</span>);<br>	&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象 给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者 （OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。 </p>
<p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证 了我们前面讲的，异步回调比较像观察者模式。</p>
<h3 id="应用举例三：addShutdownHook"><a href="#应用举例三：addShutdownHook" class="headerlink" title="应用举例三：addShutdownHook()"></a>应用举例三：addShutdownHook()</h3><p>Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？ </p>
<p>网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉 得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用 场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能 认识，遇到场景会用就可以了。</p>
<p>Hook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。接下来，我们拿 JVM 来举例说明一下。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以 注册一个 JVM 关闭的 Hook。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代 码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownHookDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownHook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;I am called during shutting down.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShutdownHook</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看 addShutdownHook() 的代码实现，如下所示。这里我只给出了部分相关代 码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShutdownHook</span><span class="hljs-params">(Thread hook)</span> &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            sm.checkPermission(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;shutdownHooks&quot;</span>));<br>        &#125;<br>        ApplicationShutdownHooks.add(hook);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationShutdownHooks</span> &#123;<br>    <span class="hljs-comment">/* The set of registered hooks */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;<br>    <span class="hljs-keyword">static</span> &#123;<br>        hooks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;<br>        hooks = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Thread hook)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Shutdown in progress&quot;</span>);<br>        <span class="hljs-keyword">if</span> (hook.isAlive())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook already running&quot;</span>);<br>        <span class="hljs-keyword">if</span> (hooks.containsKey(hook))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook previously registered&quot;</span>);<br>        hooks.put(hook, hook);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runHooks</span><span class="hljs-params">()</span> &#123;<br>        Collection&lt;Thread&gt; threads;<br>        <span class="hljs-keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;<br>            threads = hooks.keySet();<br>            hooks = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            hook.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    hook.join();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中我们可以发现，有关 Hook 的逻辑都被封装到 ApplicationShutdownHooks 类 中了。当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程， 并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所 以，这也算是一种异步回调。 </p>
<h3 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h3><p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度， 来对比一下模板模式和回调。</p>
<p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。 </p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。 </p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点。</p>
<p>1、像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。 </p>
<p>2、回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。 </p>
<p>3、如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可</p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>今天，我们重点介绍了回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框 架、类库、组件等的设计中经常会用到。 </p>
<p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就 是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。 </p>
<p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式， 异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加 灵活。</p>
<h1 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="策略模式（上）：如何避免冗长的if-else-switch分支判断代-码？"><a href="#策略模式（上）：如何避免冗长的if-else-switch分支判断代-码？" class="headerlink" title="策略模式（上）：如何避免冗长的if-else/switch分支判断代 码？"></a>策略模式（上）：如何避免冗长的if-else/switch分支判断代 码？</h2><p>最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过， 它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p>
<h3 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h3><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。 </p>
<p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略 模式跟两者类似，也能起到解耦的作用，不过，它<strong>解耦的是策略的定义、创建、使用这三部 分</strong>。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<h3 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h3><p>策略类的定义比较简单，<strong>包含一个策略接口和一组实现这个接口的策略类。</strong>因为所有的策略 类都实现相同的接口，所以，<strong>客户端代码基于接口而非实现编程，可以灵活地替换不同的策 略。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//具体的算法...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//具体的算法...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建 哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根 据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        strategies.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>());<br>        strategies.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Strategy <span class="hljs-title function_">getStrategy</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> strategies.get(type);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对 象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对 象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象， 缓存到工厂类中，用的时候直接返回。 </p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的 都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实 现策略工厂类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Strategy <span class="hljs-title function_">getStrategy</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.策略的使用</p>
<p>刚刚讲了策略的定义和创建，现在，我们再来看一下，策略的使用。 </p>
<p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见 的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。 </p>
<p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间， 根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们 通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略接口：EvictionStrategy</span><br><span class="hljs-comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span><br><span class="hljs-comment">// 策略工厂：EvictionStrategyFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> EvictionStrategy eviction;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserCache</span><span class="hljs-params">(EvictionStrategy eviction)</span> &#123;<br>        <span class="hljs-built_in">this</span>.eviction = eviction;<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EvictionStrategy</span> <span class="hljs-variable">evictionStrategy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./config.properties&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;eviction_type&quot;</span>);<br>        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);<br>        <span class="hljs-type">UserCache</span> <span class="hljs-variable">userCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserCache</span>(evictionStrategy);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非运行时动态确定，在代码中指定使用哪种策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-type">EvictionStrategy</span> <span class="hljs-variable">evictionStrategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruEvictionStrategy</span>();<br>        <span class="hljs-type">UserCache</span> <span class="hljs-variable">userCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserCache</span>(evictionStrategy);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个 Application  中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成 了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>
<h3 id="如何利用策略模式避免分支判断？"><a href="#如何利用策略模式避免分支判断？" class="headerlink" title="如何利用策略模式避免分支判断？"></a>如何利用策略模式避免分支判断？</h3><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可 以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型待动 态，决定使用哪种策略这样一种应用场景。 </p>
<p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。具体的 代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直 接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">discount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">OrderType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> order.getType();<br>        <span class="hljs-keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="hljs-comment">// 普通订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="hljs-comment">// 团购订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="hljs-comment">// 促销订单</span><br>            <span class="hljs-comment">//...省略折扣计算算法代码</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> discount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码 重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的 代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">calDiscount</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br><span class="hljs-comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg</span><br><span class="hljs-comment">// 策略的创建</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        strategies.put(OrderType.NORMAL, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalDiscountStrategy</span>());<br>        strategies.put(OrderType.GROUPON, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrouponDiscountStrategy</span>());<br>        strategies.put(OrderType.PROMOTION, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromotionDiscountStrategy</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiscountStrategy <span class="hljs-title function_">getDiscountStrategy</span><span class="hljs-params">(OrderType type)</span> &#123;<br>        <span class="hljs-keyword">return</span> strategies.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 策略的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-type">OrderType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> order.getType();<br>        <span class="hljs-type">DiscountStrategy</span> <span class="hljs-variable">discountStrategy</span> <span class="hljs-operator">=</span> DiscountStrategyFactory.getDiscountStra<br>        <span class="hljs-keyword">return</span> discountStrategy.calDiscount(order);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂 类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 ifelse 分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据 type 查表（代码中的 strategies 就是表）替代根据 type 分支判断。 </p>
<p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方 式了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiscountStrategy <span class="hljs-title function_">getDiscountStrategy</span><span class="hljs-params">(OrderType type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Type should not be null.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type.equals(OrderType.NORMAL)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalDiscountStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.GROUPON)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrouponDiscountStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromotionDiscountStrategy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类 中，实际上并没有真正将它移除。关于这个问题如何解决，我今天先暂时卖个关子。你可以 在留言区说说你的想法，我在下一节课中再讲解。</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以 使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。 </p>
<p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部 分组成的。</p>
<p>1、策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。 </p>
<p>2、策略的创建由工厂类来完成，封装策略创建的细节。</p>
<p>3、策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编 译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应 用场景。</p>
<p>除此之外，我们还可以通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂 类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
<h2 id="策略模式（下）：如何实现一个支持给不同大小文件排序的小程-序？"><a href="#策略模式（下）：如何实现一个支持给不同大小文件排序的小程-序？" class="headerlink" title="策略模式（下）：如何实现一个支持给不同大小文件排序的小程 序？"></a>策略模式（下）：如何实现一个支持给不同大小文件排序的小程 序？</h2><p>设计原则和思想其实比设计模式更加普 适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。</p>
<p>问题与解决思路</p>
<p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含 整型数，并且，相邻的数字通过逗号来区隔。如果由你来编写这样一个小程序，你会如何来 实现呢？你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。 </p>
<p>你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个 一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语 言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。 </p>
<p>但是，如果文件很大呢？比如有 10GB 大小，因为内存有限（比如只有 8GB 大小），我们 没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法（具 体怎么做，可以参看我的另一个专栏《数据结构与算法之美》中的“排序”相关章节）了。 </p>
<p>如果文件更大，比如有 100GB 大小，我们为了利用 CPU 多核的优势，可以在外部排序的 基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的 MapReduce。 </p>
<p>如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了。这个时候， 我们可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。</p>
<h3 id="代码实现与分析"><a href="#代码实现与分析" class="headerlink" title="代码实现与分析"></a>代码实现与分析</h3><p>解决思路讲完了，不难理解。接下来，我们看一下，如何将解决思路翻译成代码实现。 </p>
<p>我先用最简单直接的方式实现将它实现出来。具体代码我贴在下面了，你可以先看一下。因 为我们是在讲设计模式，不是讲算法，所以，在下面的代码实现中，我只给出了跟设计模式 相关的骨架代码，并没有给出每种排序算法的具体代码实现。感兴趣的话，你可以自行实现 一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            quickSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            externalSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            concurrentExternalSort(filePath);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            mapreduceSort(filePath);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 快速排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">externalSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 外部排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">concurrentExternalSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 多线程外部排序</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mapreduceSort</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">// 利用MapReduce多机排序</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingTool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sorter</span> <span class="hljs-variable">sorter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sorter</span>();<br>        sorter.sortFile(args[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在“编码规范”那一部分我们讲过，函数的行数不能过多，最好不要超过一屏的大小。所 以，为了避免 sortFile() 函数过长，我们把每种排序算法从 sortFile() 函数中抽离出来，拆 分成 4 个独立的排序函数。</p>
<p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、 扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项 目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫 了。只有每个小的功能模块都写好，整个项目的代码才能不差。</p>
<p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的 话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的 代码实现都堆在 Sorter 一个类中，这就会导致这个类的代码很多。而在“编码规范”那一 部分中，我们也讲到，一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的 排序算法都设计成 Sorter 的私有函数，也会影响代码的可复用性。 </p>
<h3 id="代码优化与重构"><a href="#代码优化与重构" class="headerlink" title="代码优化与重构"></a>代码优化与重构</h3><p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设 计模式来重构，也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独 立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一 个常用手段。按照这个解决思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentExternalSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapReduceSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISortAlg</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        ISortAlg sortAlg;<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentExternalSort</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            sortAlg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceSort</span>();<br>        &#125;<br>        sortAlg.sort(filePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可 维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的 if-else 那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一 步，也就是将策略的定义分离出来。 </p>
<p>实际上，上面的代码还可以继续优化。每种排序类都是无状态的，我们没必要在每次使用的 时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装。按 照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortAlgFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, ISortAlg&gt; algs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        algs.put(<span class="hljs-string">&quot;QuickSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>());<br>        algs.put(<span class="hljs-string">&quot;ExternalSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalSort</span>());<br>        algs.put(<span class="hljs-string">&quot;ConcurrentExternalSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentExternalSort</span>());<br>        algs.put(<span class="hljs-string">&quot;MapReduceSort&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceSort</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ISortAlg <span class="hljs-title function_">getSortAlg</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> algs.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortFile</span><span class="hljs-params">(String filePath)</span> &#123;<br><span class="hljs-comment">// 省略校验逻辑</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> file.length();<br>        ISortAlg sortAlg;<br>        <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">6</span> * GB) &#123; <span class="hljs-comment">// [0, 6GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;QuickSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">10</span> * GB) &#123; <span class="hljs-comment">// [6GB, 10GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ExternalSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileSize &lt; <span class="hljs-number">100</span> * GB) &#123; <span class="hljs-comment">// [10GB, 100GB)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ConcurrentExternalSort&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [100GB, ~)</span><br>            sortAlg = SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;MapReduceSort&quot;</span>);<br>        &#125;<br>        sortAlg.sort(filePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略 模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写 完全没问题。但如果你特别想将 if-else 分支判断移除掉，那也是有办法的。我直接给出代 码，你一看就能明白。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">GB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;AlgRange&gt; algs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>*GB, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;QuickSort&quot;</span>)));<br>        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">6</span>*GB, <span class="hljs-number">10</span>*GB, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;ExternalSort</span><br><span class="hljs-string">                algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;</span>ConcurrentE<br>                        algs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlgRange</span>(<span class="hljs-number">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class="hljs-string">&quot;Ma</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    public void sortFile(String filePath) &#123;</span><br><span class="hljs-string">// 省略校验逻辑</span><br><span class="hljs-string">        File file = new File(filePath);</span><br><span class="hljs-string">        long fileSize = file.length();</span><br><span class="hljs-string">        ISortAlg sortAlg = null;</span><br><span class="hljs-string">        for (AlgRange algRange : algs) &#123;</span><br><span class="hljs-string">            if (algRange.inRange(fileSize)) &#123;</span><br><span class="hljs-string">                sortAlg = algRange.getAlg();</span><br><span class="hljs-string">                break;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        sortAlg.sort(filePath);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    private static class AlgRange &#123;</span><br><span class="hljs-string">        private long start;</span><br><span class="hljs-string">        private long end;</span><br><span class="hljs-string">        private ISortAlg alg;</span><br><span class="hljs-string">        public AlgRange(long start, long end, ISortAlg alg) &#123;</span><br><span class="hljs-string">            this.start = start;</span><br><span class="hljs-string">            this.end = end;</span><br><span class="hljs-string">            this.alg = alg;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        public ISortAlg getAlg() &#123;</span><br><span class="hljs-string">            return alg;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        public boolean inRange(long size) &#123;</span><br><span class="hljs-string">            return size &gt;= start &amp;&amp; size &lt; end;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和 Sorter 类中的静 态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静 态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。 </p>
<p>你可能会说，即便这样，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符 合开闭原则。有什么办法让我们完全满足开闭原则呢？ </p>
<p>对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我 们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配 置文件或者搜索被 annotation 标注的策略类，然后通过反射了动态地加载这些策略类、创 建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件 或者用 annotation 标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来 解决。</p>
<p>对于 Sorter 来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法 之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可， 不需要改动代码。 </p>
<h3 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不 多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在 即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。 </p>
<p>一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识 是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度， 让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能 让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风 险。</p>
<p> 实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们 能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式。</p>
<h1 id="职责链模式-1"><a href="#职责链模式-1" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框-架？"><a href="#职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框-架？" class="headerlink" title="职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框 架？"></a>职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框 架？</h2><p>前几节课中，我们学习了模板模式、策略模式，今天，我们来学习职责链模式。<strong>这三种模式 具有相同的作用：复用和扩展</strong>，在实际的项目开发中比较常用，特别是框架开发中，我们可 以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩 展点定制化框架的功能。</p>
<h3 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h3><p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它 为止。</p>
<p>这么说比较抽象，我用更加容易理解的话来进一步解读一下。 </p>
<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再 传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职 责，所以叫作职责链模式。</p>
<p>职责链模式有多种实现方式，我们这里介绍两种比较常用的。</p>
<p>第一种实现方式如下所示。其中，Handler 是所有处理器类的抽象父类，handle() 是抽象 方法。每个具体的处理器类（HandlerA、HandlerB）的 handle() 函数的代码结构类似， 如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也 就是调用 successor.handle()）。HandlerChain 是处理器链，从数据结构的角度来看，它 就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (!handled &amp;&amp; successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (!handled &amp;&amp; successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        handler.setSuccessor(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        tail.setSuccessor(handler);<br>        tail = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，上面的代码实现不够优雅。处理器类的 handle() 函数，不仅包含自己的业务逻 辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()。一个不熟悉这 种代码结构的程序员，在添加新的处理器类的时候，很有可能忘记在 handle() 函数中调用 successor.handle()，这就会导致代码出现 bug。 </p>
<p>针对这个问题，我们对代码进行重构，利用模板模式，将调用 successor.handle() 的逻辑 从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业 务逻辑就可以了。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> doHandle();<br>        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span> &amp;&amp; !handled) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// HandlerChain和Application代码不变</span><br></code></pre></td></tr></table></figure>

<p>我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain 类用 数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次 调用每个处理器的 handle() 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;IHandler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(IHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handlers.add(handler);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (IHandler handler : handlers) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> handler.handle();<br>            <span class="hljs-keyword">if</span> (handled) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往 下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一 遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储 处理器，跟上面的两种实现方式类似，只需要稍微修改即可。 </p>
<p>我这里只给出其中一种实现方式，如下所示。另外一种实现方式你对照着上面的实现自行修 改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        doHandle();<br>        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handle();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        handler.setSuccessor(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        tail.setSuccessor(handler);<br>        tail = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handle();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerA</span>());<br>        chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerB</span>());<br>        chain.handle();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h3><p>职责链模式的原理和实现讲完了，我们再通过一个实际的例子，来学习一下职责链模式的应 用场景。 </p>
<p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说， 用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、 反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。 </p>
<p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打 马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链 模式的定义，第二种处理方式是职责链模式的变体。 </p>
<p>我们这里只给出第一种实现方式的代码示例，如下所示，并且，我们只给出了代码实现的骨 架，具体的敏感词过滤算法并没有给出，你可以参看我的另一个专栏《数据结构与算法 之美中多模式字符串匹配的相关章节自行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Content content)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SexyWordFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">legal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> legal;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensitiveWordFilterChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(SensitiveWordFilter filter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filters.add(filter);<br>    &#125;<br>    <span class="hljs-comment">// return true if content doesn&#x27;t contain sensitive words.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-keyword">for</span> (SensitiveWordFilter filter : filters) &#123;<br>            <span class="hljs-keyword">if</span> (!filter.doFilter(content)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SensitiveWordFilterChain</span> <span class="hljs-variable">filterChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SensitiveWordFilterChain</span>();<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdsWordFilter</span>());<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SexyWordFilter</span>());<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PoliticalWordFilter</span>());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">legal</span> <span class="hljs-operator">=</span> filterChain.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>());<br>        <span class="hljs-keyword">if</span> (!legal) &#123;<br><span class="hljs-comment">// 不发表</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 发表</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看了上面的实现，你可能会说，我像下面这样也可以实现敏感词过滤功能，而且代码更加简 单，为什么非要使用职责链模式呢？这是不是过度设计呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensitiveWordFilter</span> &#123;<br>    <span class="hljs-comment">// return true if content doesn&#x27;t contain sensitive words.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Content content)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!filterSexyWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!filterAdsWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!filterPoliticalWord(content)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterSexyWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//....</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterAdsWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filterPoliticalWord</span><span class="hljs-params">(Content content)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们前面多次讲过，应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高 代码的扩展性。这里应用职责链模式也不例外。实际上，我们在讲解策略模式的时候， 也讲过类似的问题，比如，为什么要用策略模式？当时的给出的理由，与现在应用职责链模 式的理由，几乎是一样的，你可以结合着当时的讲解一块来看下。 </p>
<p>首先，我们来看，职责链模式如何应对代码的复杂性。 </p>
<p>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责 链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。 </p>
<p>其次，我们再来看，职责链模式如何让代码满足开闭原则，提高代码的扩展性。 </p>
<p>当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的 代码实现方式，我们需要修改 SensitiveWordFilter 的代码，违反开闭原则。不过，这样的 修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一 个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不 需要修改。 </p>
<p>不过，你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改 客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。</p>
<p>实际上，细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中， ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外 的代码属于敏感词过滤框架代码。 </p>
<p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展 一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。 换句话说，我们在框架这个代码范围内实现了开闭原则。 </p>
<p>除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤 算法更加灵活，可以只选择使用某几个过滤算法。</p>
<h3 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块儿总结回顾一下，你需要重点掌握的内容。 </p>
<p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后 再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链 条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。 </p>
<p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理 器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递， 而是会被所有的处理器都处理一遍。 </p>
<p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处 理器，后面一种实现方式更加简单。</p>
<h2 id="职责链模式（下）：框架中常用的过滤器、拦截器是如何实现-的？"><a href="#职责链模式（下）：框架中常用的过滤器、拦截器是如何实现-的？" class="headerlink" title="职责链模式（下）：框架中常用的过滤器、拦截器是如何实现 的？"></a>职责链模式（下）：框架中常用的过滤器、拦截器是如何实现 的？</h2><h3 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h3><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规 范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支 持过滤器功能。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131103.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119161128367"></p>
<p>在实际项目中，我们该如何使用 Servlet Filter 呢？我写了一个简单的示例代码，如下所 示。添加一个过滤器，我们只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并 且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置， 创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-comment">// 在创建Filter时自动调用，</span><br>        <span class="hljs-comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, Filte </span><br><span class="hljs-params">            System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>)</span>;<br>        chain.doFilter(request,response);<br>        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 在销毁Filter时自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 在web.xml配置文件中如下配置：<br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xzg.cd.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>从刚刚的示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实 现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。那 Servlet Filter 是如何做到如此好的扩展性的呢？我想你应该已经猜到了，它利用的就是职责链模式。现 在，我们通过剖析它的源码，详细地看看它底层是如何实现的。 </p>
<p>在上一节课中，我们讲到，职责链模式的实现包含处理器接口（IHandler）或抽象类 （Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter， javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。接下来，我们重点来看 FilterChain 是如何实现的。 </p>
<p>不过，我们前面也讲过，Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中 的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提 供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如 下所示。 </p>
<p>为了让代码更易读懂，我对代码进行了简化，只保留了跟设计思路相关的代码片段。完整的 代码你可以自行去 Tomcat 中查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//当前执行到了哪个filter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">//filter的个数</span><br>    <span class="hljs-keyword">private</span> ApplicationFilterConfig[] filters;<br>    <span class="hljs-keyword">private</span> Servlet servlet;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>            <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>            <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>            filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>            servlet.service(request, response);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(ApplicationFilterConfig filterConfig)</span> &#123;<br>        <span class="hljs-keyword">for</span> (ApplicationFilterConfig filter:filters)<br>            <span class="hljs-keyword">if</span> (filter==filterConfig)<br>                <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (n == filters.length) &#123;<span class="hljs-comment">//扩容</span><br>            ApplicationFilterConfig[] newFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterConfig</span>[n + IN<br>            System.arraycopy(filters, <span class="hljs-number">0</span>, newFilters, <span class="hljs-number">0</span>, n);<br>            filters = newFilters;<br>        &#125;<br>        filters[n++] = filterConfig;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调 用。你可以用每个 Filter（比如 LogFilter）的 doFilter() 的代码实现，直接替换 ApplicationFilterChain 的第 12 行代码，一眼就能看出是递归调用了。我替换了一下，如 下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>&#123;<br>        <span class="hljs-keyword">if</span>(pos&lt;n)&#123;<br>        	ApplicationFilterConfig filterConfig=filters[pos++];<br>        	Filter filter=filterConfig.getFilter();<br>			<span class="hljs-comment">//filter.doFilter(request, response, this);</span><br>			<span class="hljs-comment">//把filter.doFilter的代码实现展开替换到这里</span><br>        	System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>        	chain.doFilter(request,response); <span class="hljs-comment">// chain就是this</span><br>        	System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>        	servlet.service(request,response);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请 求，也能拦截发送给客户端的响应，你可以结合着 LogFilter 那个例子，以及对比待会要讲 到的 Spring Interceptor，来自己理解一下。而我们上一节课给出的两种实现方式，都没 法做到在业务逻辑执行的前后，同时添加处理代码。 </p>
<h3 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h3><p>刚刚讲了 Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上 可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。 </p>
<p>它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131104.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119161823621"></p>
<p>在项目中，我们该如何使用 Spring Interceptor 呢？我写了一个简单的示例代码，如下所 示。LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区 别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse resp</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>)</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 继续后续的处理</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse respon</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span><br><span class="hljs-params">        System.out.println(<span class="hljs-string">&quot;这里总是被执行.&quot;</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//在Spring MVC配置文件中配置interceptors<br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*&quot;</span>/&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xzg.cd.LogInterceptor&quot;</span> /&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>同样，我们还是来剖析一下，Spring Interceptor 底层是如何实现的。 </p>
<p>当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中 的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清 晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中 实现。HandlerExecutionChain 的源码如下所示，同样，我对代码也进行了一些简化，只 保留了关键代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExecutionChain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object handler;<br>    <span class="hljs-keyword">private</span> HandlerInterceptor[] interceptors;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">(HandlerInterceptor interceptor)</span> &#123;<br>        initInterceptorList().add(interceptor);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse respons</span><br><span class="hljs-params">HandlerInterceptor[]interceptors=getInterceptors()</span>;<br><span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interceptors.length; i++) &#123;<br>            <span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors[i];<br>            <span class="hljs-keyword">if</span> (!interceptor.preHandle(request, response, <span class="hljs-built_in">this</span>.handler)) &#123;<br>                triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response</span><br><span class="hljs-params">HandlerInterceptor[]interceptors=getInterceptors()</span>;<br>	<span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=interceptors.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        	HandlerInterceptor interceptor=interceptors[i];<br>        	interceptor.postHandle(request,response,<span class="hljs-built_in">this</span>.handler,mv);<br>        &#125;<br>     &#125;<br>&#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">triggerAfterCompletion</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse re</span><br><span class="hljs-params">        <span class="hljs-keyword">throws</span> Exception&#123;</span><br><span class="hljs-params">        	HandlerInterceptor[]interceptors=getInterceptors()</span>;<br>       		<span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(interceptors))&#123;<br>        		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">this</span>.interceptorIndex;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        			HandlerInterceptor interceptor=interceptors[i];<br>        			<span class="hljs-keyword">try</span>&#123;<br>        				interceptor.afterCompletion(request,response,<span class="hljs-built_in">this</span>.handler,ex);<br>        			&#125;<span class="hljs-keyword">catch</span>(Throwable ex2)&#123;<br>        				logger.error(<span class="hljs-string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>,ex2);<br>        			&#125;<br>        		&#125;<br>        	&#125;<br>        &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业 务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。具体的代码实现很简单，你自己应该能 脑补出来，这里就不罗列了。感兴趣的话，你可以自行去查看.</p>
<h3 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容 </p>
<p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不 需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、 对修改关闭的设计原则。</p>
<p>今天，我们通过 Servlet Filter、Spring Interceptor 两个实际的例子，给你展示了在框架 开发中职责链模式具体是怎么应用的。从源码中，我们还可以发现，尽管上一节课中我们有 给出职责链模式的经典代码实现，但在实际的开发中，我们还是要具体问题具体对待，代码 实现会根据不同的需求有所变化。实际上，这一点对于所有的设计模式都适用。</p>
<p><strong>Q：AOP、Servlet Filter、Spring Interceptor 都可以做访问控制？</strong></p>
<p>Spring AOP 是基于代理模式来实现的。在实际 的项目开发中，我们可以利用 AOP 来实现访问控制功能，比如鉴权、限流、日志等。今 天我们又讲到，Servlet Filter、Spring Interceptor 也可以用来实现访问控制。那在项 目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、 Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</p>
<h1 id="状态模式-1"><a href="#状态模式-1" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"><a href="#状态模式：游戏、工作流引擎中常用的状态机是如何实现的？" class="headerlink" title="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"></a>状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</h2><p>状态模式一般用来实现状态机，而状态机常用在<strong>游戏、工作流引擎</strong>等系统开发中。不过，状 态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。今天，我们 就详细讲讲这几种实现方式，并且对比一下它们的优劣和应用场景。</p>
<h3 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h3><p>有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转 移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必 须的，也可能只转移状态，不执行任何动作。</p>
<p>对于刚刚给出的状态机的定义，我结合一个具体的例子，来进一步解释一下。 </p>
<p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马 里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷 马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减 积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积 分。 </p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状 态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动 作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触 发动作的执行（增加 100 积分）。 </p>
<p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状 态转移如下图所示：</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131105.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119162931049"></p>
<p>我们如何编程来实现上面的状态机呢？换句话说，如何将上面的状态转移图翻译成代码呢？ </p>
<p>我写了一个骨架代码，如下所示。其中，obtainMushRoom()、obtainCape()、 obtainFireFlower()、meetMonster() 这几个函数，能够根据当前的状态和事件，更新状 态和增减积分。不过，具体的代码实现我暂时并没有给出。你可以把它当做面试题，试着补 全一下，然后再来看我下面的讲解，这样你的收获会更大。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131106.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119163500089"></p>
<h3 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h3><p>对于如何实现状态机，我总结了三种方式。其中，最简单直接的实现方式是，参照状态转移 图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为 分支逻辑法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> State currentState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SUPER;<br>            <span class="hljs-built_in">this</span>.score += <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) )<br>            <span class="hljs-built_in">this</span>.currentState = State.CAPE;<br>        <span class="hljs-built_in">this</span>.score += <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) )<br>            <span class="hljs-built_in">this</span>.currentState = State.FIRE;<br>        <span class="hljs-built_in">this</span>.score += <span class="hljs-number">300</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.SUPER)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.CAPE)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">200</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currentState.equals(State.FIRE)) &#123;<br>            <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>            <span class="hljs-built_in">this</span>.score -= <span class="hljs-number">300</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>	<span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来 说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 ifelse 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机 中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引 入 bug。</p>
<h3 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h3><p>实际上，上面这种实现方法有点类似 hard code，对于复杂的状态机来说不适用，而状态 机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表 法来补全骨架代码。 </p>
<p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个 二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到 的新状态及其执行的动作。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131107.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119163838923"></p>
<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改 状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上， 如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改 任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Event</span> &#123;<br>    GOT_MUSHROOM(<span class="hljs-number">0</span>),<br>    GOT_CAPE(<span class="hljs-number">1</span>),<br>    GOT_FIRE(<span class="hljs-number">2</span>),<br>    MET_MONSTER(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Event</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> State currentState;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> State[][] transitionTable = &#123;<br>            &#123;SUPER, CAPE, FIRE, SMALL&#125;,<br>            &#123;SUPER, CAPE, FIRE, SMALL&#125;,<br>            &#123;CAPE, CAPE, CAPE, SMALL&#125;,<br>            &#123;FIRE, FIRE, FIRE, SMALL&#125;<br>    &#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[][] actionTable = &#123;<br>            &#123;+<span class="hljs-number">100</span>, +<span class="hljs-number">200</span>, +<span class="hljs-number">300</span>, +<span class="hljs-number">0</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">200</span>, +<span class="hljs-number">300</span>, -<span class="hljs-number">100</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, -<span class="hljs-number">200</span>&#125;,<br>            &#123;+<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>, -<span class="hljs-number">300</span>&#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = State.SMALL;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_MUSHROOM);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_CAPE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.GOT_FIRE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        executeEvent(Event.MET_MONSTER);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeEvent</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stateValue</span> <span class="hljs-operator">=</span> currentState.getValue();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">eventValue</span> <span class="hljs-operator">=</span> event.getValue();<br>        <span class="hljs-built_in">this</span>.currentState = transitionTable[stateValue][eventValue];<br>        <span class="hljs-built_in">this</span>.score = actionTable[stateValue][eventValue];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h3><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型 的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能 发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的 实现方式有一定局限性。</p>
<p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断 逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们 可以使用状态模式来解决。 </p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断 逻辑。我们还是结合代码来理解这句话。 </p>
<p>利用状态模式，我们来补全 MarioStateMachine 类，补全后的代码如下所示。</p>
<p>其中，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、 CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所 有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代 码逻辑被分散到了这 4 个状态类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMario</span> &#123; <span class="hljs-comment">//所有状态类的接口</span><br>    State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//以下是定义的事件</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> MarioStateMachine stateMachine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmallMario</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SMALL;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CapeMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FireMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do nothing...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> MarioStateMachine stateMachine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SuperMario</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SUPER;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do nothing...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CapeMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FireMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>(stateMachine));<br>        stateMachine.setScore(stateMachine.getScore() - <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略CapeMario、FireMario类...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> IMario currentState; <span class="hljs-comment">// 不再使用枚举来表示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainMushRoom();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainCape();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainFireFlower();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.meetMonster();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState.getName();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(IMario currentState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState = currentState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码实现不难看懂，我只强调其中的一点，即 MarioStateMachine 和各个状态类之 间是双向依赖关系。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来， 各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。 </p>
<p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含 任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递 MarioStateMachine 了，而状态类又要依赖 MarioStateMachine，那该如何解决这个问 题呢？ </p>
<p>实际上，在第 42 讲单例模式的讲解中，我们提到过几种解决方法，你可以回过头去再查 看一下。在这里，我们可以通过函数参数将 MarioStateMachine 传递进状态类。根据这个 设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMario</span> &#123;<br>    State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">(MarioStateMachine stateMachine)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallMario</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMario</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SmallMario</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallMario</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SmallMario</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SmallMario <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> State.SMALL;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(SuperMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(CapeMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">200</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br>        stateMachine.setCurrentState(FireMario.getInstance());<br>        stateMachine.setScore(stateMachine.getScore() + <span class="hljs-number">300</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">(MarioStateMachine stateMachine)</span> &#123;<br><span class="hljs-comment">// do nothing...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 省略SuperMario、CapeMario、FireMario类...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarioStateMachine</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">private</span> IMario currentState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarioStateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.currentState = SmallMario.getInstance();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainMushRoom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainMushRoom(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainCape</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainCape(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">obtainFireFlower</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.obtainFireFlower(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetMonster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState.meetMonster(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentState.getName();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(IMario currentState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentState = currentState;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状 态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种 类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业 务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。 </p>
<h3 id="重点回顾-8"><a href="#重点回顾-8" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>今天我们讲解了状态模式。虽然网上有各种状态模式的定义，但是你只要记住状态模式是状 态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动 作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须 的，也可能只转移状态，不执行任何动作。 </p>
<p>针对状态机，今天我们总结了三种实现方式。 </p>
<p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移 图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简 单、最直接，是首选。 </p>
<p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合 适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。 </p>
<p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动 作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<h1 id="迭代器模式-1"><a href="#迭代器模式-1" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些-优势？"><a href="#迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些-优势？" class="headerlink" title="迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些 优势？"></a>迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些 优势？</h2><p>迭代器模式。它用来遍历集合对象。不过，很多 编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开 发，我们直接使用即可，很少会自己去实现一个迭代器。不过，知其然知其所以然，弄懂原 理能帮助我们更好的使用这些工具类，所以，我觉得还是有必要学习一下这个模式。</p>
<p>我们知道，大部分编程语言都提供了多种遍历集合的方式，比如 for 循环、foreach 循环、 迭代器等。所以，今天我们除了讲解迭代器的原理和实现之外，还会重点讲一下，相对于其 他遍历方式，利用迭代器来遍历集合的优势。</p>
<h3 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h3><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。 </p>
<p>在开篇中我们讲到，它用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合 对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将 集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。 </p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部 分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代 器又包含迭代器接口、迭代器实现类。对于迭代器模式，我画了一张简单的类图，你可以看 一看，先有个大致的印象。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131108.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119164813318"></p>
<p>接下来，我们通过一个例子来具体讲，如何实现一个迭代器。</p>
<p>开篇中我们有提到，大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直 接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原 理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我 们从零开始开发。现在，我们一块来看具体该如何去做。 </p>
<p>我们知道，线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种 数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分 别对应 ArrayList 和 LinkedList 两个类。除此之外，我们从两个类中抽象出公共的接口， 定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结 构之间灵活切换。 </p>
<p>现在，我们针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。按照之 前给出的迭代器模式的类图，我们定义一个迭代器接口 Iterator，以及针对两种容器的具体 的迭代器实现类 ArrayIterator 和 ListIterator。</p>
<p>我们先来看下 Iterator 接口的定义。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义方式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 接口定义方式二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Iterator 接口有两种定义方式。 </p>
<p>在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前 游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函 数 next() 中完成。</p>
<p>第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不 移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。 </p>
<p>现在，我们再来看下 ArrayIterator 的代码实现，具体如下所示。代码实现非常简单，不需 要太多解释。你可以结合着我给出的 demo，自己理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != arrayList.size(); <span class="hljs-comment">//注意这里，cursor在指向最后一个元素的时候，ha</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        cursor++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br>        Iterator&lt;String&gt; iterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(names);<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.currentItem());<br>            iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际 上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应 的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口 中。具体的代码实现和使用示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//...省略其他接口函数...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...省略其他代码</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.currentItem());<br>            iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 LinkedIterator，它的代码结构跟 ArrayIterator 完全相同，我这里就不给出具体的代 码实现了，你可以参照 ArrayIterator 自己去写一下。 </p>
<p>结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：<strong>迭代器中需要定 义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注 入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。</strong></p>
<p>这里我画了一张类图，如下所示。实际上就是对上面那张类图的细化，你可以结合着一块 看。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131109.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119165137583"></p>
<p>迭代器的原理和代码实现讲完了。接下来，我们来一块看一下，使用迭代器遍历集合的优 势。 </p>
<p>一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。对于这 三种方式，我拿 Java 语言来举例说明一下。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;xzg&quot;</span>);<br>names.add(<span class="hljs-string">&quot;wang&quot;</span>);<br>names.add(<span class="hljs-string">&quot;zheng&quot;</span>);<br><br><span class="hljs-comment">// 第一种遍历方式：for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.size(); i++) &#123;<br>    System.out.print(names.get(i) + <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 第二种遍历方式：foreach循环</span><br><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    System.out.print(name + <span class="hljs-string">&quot;,&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 第三种遍历方式：迭代器遍历</span><br>Iterator&lt;String&gt; iterator = names.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.print(iterator.next() + <span class="hljs-string">&quot;,&quot;</span>);<span class="hljs-comment">//Java中的迭代器接口是第二种定义方式，next</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面 代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器 遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。 </p>
<p>从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们 为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三 个。 </p>
<p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历 就足够了。但是，<u>对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比 如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。</u>如果由客户端代码来实 现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类 中，也会导致容器类代码的复杂性。 </p>
<p>前面也多次提到，<u>应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比 如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分 别来实现深度优先遍历和广度优先遍历。</u> </p>
<p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这 样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。 </p>
<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实 现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链 表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即 可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器 类，也更符合开闭原则。</p>
<h3 id="重点回顾-9"><a href="#重点回顾-9" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以 叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、 跳表。 </p>
<p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非 实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实 现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代 器类中。 </p>
<p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一 种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势： </p>
<p>1、迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器 提供的迭代器即可； </p>
<p>2、迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职 责更加单一； </p>
<p>3、迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都 实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<h2 id="迭代器模式（中）：遍历集合的同时，为什么不能增删集合元-素？"><a href="#迭代器模式（中）：遍历集合的同时，为什么不能增删集合元-素？" class="headerlink" title="迭代器模式（中）：遍历集合的同时，为什么不能增删集合元 素？"></a>迭代器模式（中）：遍历集合的同时，为什么不能增删集合元 素？</h2><h3 id="在遍历的同时增删集合元素会发生什么？"><a href="#在遍历的同时增删集合元素会发生什么？" class="headerlink" title="在遍历的同时增删集合元素会发生什么？"></a>在遍历的同时增删集合元素会发生什么？</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还 是错，要视情况而定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<span class="hljs-comment">//55</span><br>        iterator.next();<span class="hljs-comment">//56</span><br>        names.remove(<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-comment">//57</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数 组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 56 行代码的时候，游标指向元素 b，到这里都没有问题。</p>
<p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 57 行代码的时候，我们从数组 中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元 素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、 d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到 了。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131110.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119165919755"></p>
<p>不过，如果第 57 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素 （元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在 某个元素遍历不到的情况了。 </p>
<p>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删 除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的 是哪个位置的元素），就是这个意思。 </p>
<p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集 合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一 下，把删除元素改为添加元素。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<span class="hljs-comment">//9</span><br>        iterator.next();<span class="hljs-comment">//10</span><br>        names.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;x&quot;</span>);<span class="hljs-comment">//11</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已 经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、 c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重 复指向两次，也就是说，元素 a 存在被重复遍历的情况。 </p>
<p>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的 同时添加集合元素也是一种不可预期行为。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131111.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119170023489"></p>
<h3 id="如何应对遍历时改变集合导致的未决行为？"><a href="#如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="如何应对遍历时改变集合导致的未决行为？"></a>如何应对遍历时改变集合导致的未决行为？</h3><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际 上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏 很深、很难 debug 的 bug 就是这么产生的。那我们如何才能避免出现这种不可预期的运 行结果呢？ </p>
<p>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之 后让遍历报错。</p>
<p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时 间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍 历结束的时间点该如何来确定呢？</p>
<p>你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使 用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为 b 的元素就提前结束了遍历。</p>
<p>你可能还会说，那我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容 器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用 完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p>
<p>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后， 让遍历报错。接下来，我们具体来看一下如何实现。 </p>
<p>怎么确定在遍历时候，集合有没有增删元素呢？</p>
<p><u>我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1</u>。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，<u>我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</u> </p>
<p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元 素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我 们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不 正确使用迭代器而产生的 bug。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-keyword">private</span> ArrayList arrayList;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedModCount;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList arrayList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>        <span class="hljs-built_in">this</span>.expectedModCount = arrayList.modCount;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        cursor++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (arrayList.modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        iterator.next();<br>        names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>        iterator.next();<span class="hljs-comment">//抛出ConcurrentModificationException异常</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如何在遍历的同时安全地删除集合元素？ </p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的 是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里 本身就不合适。 </p>
<p>我个人觉得，J<u>ava 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删 除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操 作，多次调用 remove() 操作会报错</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        Iterator&lt;String&gt; iterator = names.iterator();<br>        iterator.next();<br>        iterator.remove();<br>        iterator.remove(); <span class="hljs-comment">//报错，抛出IllegalStateException异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘 密。我们来看下 remove() 函数是如何实现的，代码如下所示。稍微提醒一下，在 Java 实 现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前 的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> cursor; <span class="hljs-comment">// index of next element to return</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>        Itr() &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            checkForComodification();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            checkForComodification();<br>            <span class="hljs-keyword">try</span> &#123;<br>                ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>                cursor = lastRet;<br>                lastRet = -<span class="hljs-number">1</span>;<br>                expectedModCount = modCount;<br>            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>在上面的代码实现中，迭代器类新增了一个 <u>lastRet 成员变量，用来记录游标指向的前一个 元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来 保证不会因为删除元素而导致某个元素遍历不到。</u>如果通过容器来删除元素，并且希望更新 迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭 代器是否还在使用等信息，代码实现就变得比较复杂了。</p>
<h3 id="重点回顾-10"><a href="#重点回顾-10" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍 历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出 错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。 </p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候 不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很 难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解 决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。 </p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<p><strong>Q：下面代码中的第 13 行的运行结果是什么？</strong></p>
<p>基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器， 一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可 用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator1 = names.iterator();<br>        Iterator&lt;String&gt; iterator2 = names.iterator();<br>        iterator1.next();<br>        iterator1.remove();<br>        iterator2.next(); <span class="hljs-comment">// 运行结果？</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="迭代器模式（下）：如何设计实现一个支持“快照”功能的-iterator？"><a href="#迭代器模式（下）：如何设计实现一个支持“快照”功能的-iterator？" class="headerlink" title="迭代器模式（下）：如何设计实现一个支持“快照”功能的 iterator？"></a>迭代器模式（下）：如何设计实现一个支持“快照”功能的 iterator？</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？ </p>
<p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。 </p>
<p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器 list 中初始存储 了 3、8、2 三个元素。尽管在创建迭代器 iter1 之后，容器 list 删除了元素 3，只剩下 8、 2 两个元素，但是，通过 iter1 遍历的对象是快照，而非容器 list 本身。所以，遍历的结果 仍然是 3、8、2。同理，iter2、iter3 也是在各自的快照上遍历，输出的结果如代码中注释 所示。</p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量 snapshot 来存储快 照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。</p>
<p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快 照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内 存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对 象并非真的拷贝了多份，而只是拷贝了对象的引用而已。关于深拷贝、浅拷贝，我们在 第 47 讲中有详细的讲解，你可以回过头去再看一下。 </p>
<p>那有没有什么方法，既可以支持快照，又不需要拷贝容器呢？</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一 个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素 被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。 </p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。 </p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestampsnapshotTimestamp，说明元素在创建了迭代器之后才加入 的，不属于这个迭代器的快照；如果元素的 delTimestamp&lt;snapshotTimestamp，说明<br>元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑 ArrayList 的扩容问题，感兴趣的话，你可以自己完善一<br>下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层 依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法 支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的 《数据结构与算法之美》专栏，这里我就不展开讲解了。 </p>
<p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？ </p>
<p>解决的方法也不难，我稍微提示一下。我们可以在 ArrayList 中存储两个数组。一个支持标 记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从</p>
<p>数组中移除），用来支持随机访问。对应的代码我这里就不给出了，感兴趣的话你可以自己 实现一下。 </p>
<h3 id="重点回顾-11"><a href="#重点回顾-11" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>今天我们讲了如何实现一个支持“快照”功能的迭代器。其实这个问题本身并不是学习的重 点，因为在真实的项目开发中，我们几乎不会遇到这样的需求。所以，基于今天的内容我不 想做过多的总结。我想和你说一说，为什么我要来讲今天的内容呢？ </p>
<p><u>实际上，学习本节课的内容，如果你只是从前往后看一遍，看懂就觉得 ok 了，那收获几乎 是零。</u>一个好学习方法是，把它当作一个思考题或者面试题，在看我的讲解之前，自己主动 思考如何解决，并且把解决方案用代码实现一遍，然后再来看跟我的讲解有哪些区别。这个 过程对你分析问题、解决问题的能力的锻炼，代码设计能力、编码能力的锻炼，才是最有价 值的，才是我们这篇文章的意义所在。所谓“知识是死的，能力才是活的”就是这个道理。 </p>
<p>其实，不仅仅是这一节的内容，整个专栏的学习都是这样的。</p>
<p><strong>只掌握了知识，没 锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。</strong></p>
<h1 id="行为型模式-下篇"><a href="#行为型模式-下篇" class="headerlink" title="行为型模式 | 下篇"></a>行为型模式 | 下篇</h1><h2 id="行为型模式总览-1"><a href="#行为型模式总览-1" class="headerlink" title="行为型模式总览"></a>行为型模式总览</h2><p>创建型设计模式：主要解决“对象的创建”问题</p>
<p>结构型设计模式：主要解决“类或对象的组合或组装”问题</p>
<p>行为型设计模式：主要解决“类或对象之间的交互”问题</p>
<hr>
<p>观察者模式：发布订阅模式，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>
<p>模板方法模式：让子类在不改变业务逻辑整体结构的情况下，重新定义其中的某些步骤</p>
<p>策略模式：定义一族算法类将每个算法分别封装起来，让它们可以互相替换</p>
<p>职责链模式：多个处理器依次处理同一个请求</p>
<p>迭代器模式：遍历集合对象</p>
<p>状态模式：将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</p>
<hr>
<p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</p>
<p>备忘录模式：存储副本以便后期恢复</p>
<p>命令模式：将函数封装成对象，把函数像对象一样使用</p>
<p>解释器模式：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</p>
<p>中介模式：一组对象之间的交互关系从多对多（网状关系）转换为一对多（星状关系）</p>
<h2 id="设计模式使用频率-1"><a href="#设计模式使用频率-1" class="headerlink" title="设计模式使用频率"></a>设计模式使用频率</h2><p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220110155903.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220106141529342"></p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote>
<p>提前说明</p>
</blockquote>
<p>23 种经典设计模式中最难理解的几个之一。因为它难理解、难实 现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很 少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<blockquote>
<p>模式定义</p>
</blockquote>
<p>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保 持类职责单一、满足开闭原则以及应对代码的复杂性。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作 （抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile） 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访 问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类 （Extractor、Compressor）中。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：为什么支持双分派的语言不需要访问者模式？</strong></p>
<p>Single Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>编译时类型</strong>来决定</p>
<p>Double Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>运行时类型</strong>来决定。</p>
<p>当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch</p>
<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函 数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪 个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的 运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我 们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现， 备份更侧重架构设计或产品设计。</p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对 这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的 数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结 合来做恢复。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>应用范围并不广，它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行。</p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主 要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做 命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<p><strong>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。</strong></p>
<p>我们知道，C 语 言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函 数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数 封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样 就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：命令模式 vs 工厂模式 vs 策略模式</strong></p>
<p>设计模式之间的主要区别还是在于设计意图，也就是应用场景</p>
<p><strong>策略模式 vs 工厂模式</strong></p>
<p>策略模式包含策略的定义、创建和使用三部分，从代 码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个 特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式 侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是 其他东西。</p>
<p><strong>策略模式 vs 命令模式</strong></p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对 应不同的处理逻辑，并且互相之间不可替换。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p>某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法</p>
<p>解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>生活案例：中英文翻译</strong></p>
<p>把英文翻译成中文是有一定 规则的。这个规则就是定义中的“语法”。我们开发一个类似 Google Translate 这样的翻 译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器 模式定义中的“解释器”</p>
<p><strong>实战案例：自定义接口告警规则</strong></p>
<p>自定义一个表达式，来 表示一个告警规则，然后实现这个规则的解释器</p>
<p><strong>其他的重要应用场景</strong></p>
<p>只在一些特定的领域会被用到，比如编译器、规则引擎、正则 表达式。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编 译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生 成机器可以执行的汇编指令。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p><strong>Q：代码实现的核心思想</strong></p>
<p>将语法 解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆 分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><blockquote>
<p>模式定义</p>
</blockquote>
<p><strong>概念：</strong> 中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。 将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p><strong>设计思想：</strong> 通过引入中介这个中间层，将一组对象之间的 交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。</p>
<p>原来一个 对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关 系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p><strong>生活场景：航空管制</strong></p>
<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需 要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引 入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来 负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p><strong>编程相关：UI 控件</strong></p>
<p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。 当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选 择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登 陆相关的控件就会显示在对话框中。</p>
<p>实现方式一：控件和控件之间互相操作、互相依赖。</p>
<p>实现方式二：各个控件只跟中介 对象交互，中介对象负责所有业务逻辑的处理。</p>
<p>好处是简化了控件之间的交互，坏处是中介类有可能会 变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实 际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<blockquote>
<p>源码设计</p>
</blockquote>
<p>现在流行的微服务，注册中心可以理解为广义的中介模式，防止各个服务间错综复 杂的调用</p>
<blockquote>
<p>其他问题</p>
</blockquote>
<p><strong>Q：观察者模式和中介模式的区别</strong></p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应 用场景上。</p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分 情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具 两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。当维护成本很高的时候，我们 才考虑使用中介模式。</p>
<h1 id="访问者模式-1"><a href="#访问者模式-1" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="访问者模式（上）：手把手带你还原访问者模式诞生的思维过程"><a href="#访问者模式（上）：手把手带你还原访问者模式诞生的思维过程" class="headerlink" title="访问者模式（上）：手把手带你还原访问者模式诞生的思维过程"></a>访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</h2><p>23 种经典设计模式中最难理解的几个之一。因为它难理解、难实 现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很 少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<p>带你“发明”访问者模式 </p>
<p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现 在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的 文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？ </p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其 中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、 WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<h3 id="带你“发明”访问者模式"><a href="#带你“发明”访问者模式" class="headerlink" title="带你“发明”访问者模式"></a>带你“发明”访问者模式</h3><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现 在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的 文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？ </p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其 中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、 WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PPTFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PPTFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...省略一大坨从PPT中抽取文本的代码...</span><br>        <span class="hljs-comment">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 运行结果是：</span><br><span class="hljs-comment">// Extract PDF.</span><br><span class="hljs-comment">// Extract WORD.</span><br><span class="hljs-comment">// Extract PPT.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.extract2txt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文 件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思 路，就会存在这样几个问题：</p>
<p>1、违背开闭原则，添加一个新的功能，所有类的代码都要修改； </p>
<p>2、虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</p>
<p>3、把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的 职责不够单一，变成了大杂烩。</p>
<p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦， 设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后 的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile代码省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重 载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类 中函数名相同、参数不同的一组函数。 </p>
<p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 37 行会报错。这是 为什么呢？ </p>
<p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应 的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明 类型执行声明类型对应的方法。 </p>
<p>在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile， 而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数， 所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。 那如何解决这个问题呢？ </p>
<p>解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span> &#123;<br>        extractor.extract2txt(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-comment">//...Extractor代码不变...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的， 在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函 数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访 问者模式不好理解的原因。 </p>
<p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不 同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类 的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除 此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Compressor compressor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Extractor extractor)</span> &#123;<br>        extractor.extract2txt(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Compressor compressor)</span> &#123;<br>        compressor.compress(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-comment">//...Extractor代码不变</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>        <span class="hljs-type">Compressor</span> <span class="hljs-variable">compressor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compressor</span>();<br>        <span class="hljs-keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(compressor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭 原则。针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我 们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。 </p>
<p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor vistor)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pdfFile)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile pdfFile)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compressor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Compress WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(extractor);<br>        &#125;<br>        <span class="hljs-type">Compressor</span> <span class="hljs-variable">compressor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compressor</span>();<br>        <span class="hljs-keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;<br>            resourceFile.accept(compressor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="重新来看访问者模式"><a href="#重新来看访问者模式" class="headerlink" title="重新来看访问者模式"></a>重新来看访问者模式</h3><p>刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这 个模式的原理和代码实现。 访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它 是这么定义的：</p>
<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>
<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。 </p>
<p>定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实 现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现 代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看 一下。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131227.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220119194824931"></p>
<p>最后，我们再来看下，访问者模式的应用场景。 </p>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，</p>
<h3 id="重点回顾-12"><a href="#重点回顾-12" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保 持类职责单一、满足开闭原则以及应对代码的复杂性。 </p>
<p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重 载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编 译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。 </p>
<p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如 果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得 已，不要使用这种模式。</p>
<h2 id="访问者模式（下）：为什么支持双分派的语言不需要访问者模-式？"><a href="#访问者模式（下）：为什么支持双分派的语言不需要访问者模-式？" class="headerlink" title="访问者模式（下）：为什么支持双分派的语言不需要访问者模 式？"></a>访问者模式（下）：为什么支持双分派的语言不需要访问者模 式？</h2><h3 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h3><p> 实际上，讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为 双分派。虽然学习访问者模式，并不用非得理解这个概念，我们前面的讲解就没有提到它， 但是，为了让你在查看其它书籍或者资料的时候，不会卡在这个概念上，我觉得有必要在这 里讲一下。 </p>
<p>除此之外，我觉得，学习 Double Dispatch 还能加深你对访问者模式的理解，而且能一并 帮你搞清楚今天文章标题中的这个问题：为什么支持双分派的语言就不需要访问者模式？这 个问题在面试中可是会被问到的哦！ </p>
<p>既然有 Double Dispatch，对应的就有 Single Dispatch。所谓 Single Dispatch，指的 是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参 数的编译时类型来决定。所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象 的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 </p>
<p><strong>如何理解“Dispatch”这个单词呢？</strong> </p>
<p>在面向对象编程语言中，我们可以把方法调用理解为 一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发 送一条消息。这条消息起码要包含对象名、方法名、方法参数。 </p>
<p><strong>如何理解“Single”“Double”这两个单词呢？</strong></p>
<p>“Single”“Double”指的是执行哪个 对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有 关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对 象”和“方法参数”两者的运行时类型有关。 </p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直 接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。 接下来，我们拿 Java 语言来举例说明一下。</p>
<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函 数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪 个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的 运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。 </p>
<p>这么说比较抽象，我举个例子来具体说明一下，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am ParentClass&#x27;s f().&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am ChildClass&#x27;s f().&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleDispatchClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">polymorphismFunction</span><span class="hljs-params">(ParentClass p)</span> &#123;<br>        p.f();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">overloadFunction</span><span class="hljs-params">(ParentClass p)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">overloadFunction</span><span class="hljs-params">(ChildClass c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SingleDispatchClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleDispatchClass</span>();<br>        <span class="hljs-type">ParentClass</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildClass</span>();<br>        demo.polymorphismFunction(p);<span class="hljs-comment">//执行哪个对象的方法，由对象的实际类型决定</span><br>        demo.overloadFunction(p);<span class="hljs-comment">//执行对象的哪个方法，由参数对象的声明类型决定</span><br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//代码执行结果:</span><br>    I am ChildClass<span class="hljs-string">&#x27;s f().</span><br><span class="hljs-string">    I am overloadFunction(ParentClass p).</span><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，第 31 行代码的 polymorphismFunction() 函数，执行 p 的实际类型的 f() 函数，也就是 ChildClass 的 f() 函数。第 32 行代码的 overloadFunction() 函数，匹配 的是重载函数中的 overloadFunction(ParentClass p)，也就是根据 p 的声明类型来决定 匹配哪个重载函数。 </p>
<p>假设 Java 语言支持 Double Dispatch，那下面的代码（摘抄自上节课中第二段代码，建议 结合上节课的讲解一块理解）中的第 37 行就不会报错。代码会在运行时，根据参数 （resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用 extract2txt 的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式 了。这也回答了为什么支持 Double Dispatch 的语言不需要访问者模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile、WordFile代码省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PPTFile pptFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PPT.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(PdfFile pdfFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract PDF.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(WordFile wordFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>        System.out.println(<span class="hljs-string">&quot;Extract WORD.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Extractor</span>();<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">        List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>            resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="除了访问者模式，上一节的例子还有其他实现方案吗？"><a href="#除了访问者模式，上一节的例子还有其他实现方案吗？" class="headerlink" title="除了访问者模式，上一节的例子还有其他实现方案吗？"></a>除了访问者模式，上一节的例子还有其他实现方案吗？</h3><p>上节课，我通过一个例子来给你展示了，访问者模式是如何一步一步设计出来的。我们这里 再一块回顾一下那个例子。我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、 PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压 缩资源文件、提取文件元信息等。 </p>
<p>实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选 择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂 模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、 PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数 中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据 不同的文件类型，返回不同的 Extractor。 </p>
<p>这个实现思路其实更加简单，我们直接看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">protected</span> String filePath;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ResourceFileType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PdfFile</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-built_in">super</span>(filePath);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ResourceFileType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ResourceFileType.PDF;<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(ResourceFile resourceFile)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfExtractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Extractor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extract2txt</span><span class="hljs-params">(ResourceFile resourceFile)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtractorFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMa</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        extractors.put(ResourceFileType.PDF, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfExtractor</span>());<br>        extractors.put(ResourceFileType.PPT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTExtractor</span>());<br>        extractors.put(ResourceFileType.WORD, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WordExtractor</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Extractor <span class="hljs-title function_">getExtractor</span><span class="hljs-params">(ResourceFileType type)</span> &#123;<br>        <span class="hljs-keyword">return</span> extractors.get(type);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;<br>            <span class="hljs-type">Extractor</span> <span class="hljs-variable">extractor</span> <span class="hljs-operator">=</span> ExtractorFactory.getExtractor(resourceFile.getType<br>                    extractor.extract2txt(resourceFile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;ResourceFile&gt; <span class="hljs-title function_">listAllResourceFiles</span><span class="hljs-params">(String resourceDirecto</span><br><span class="hljs-params">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;()</span>;<br>        <span class="hljs-comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfFile</span>(<span class="hljs-string">&quot;a.pdf&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WordFile</span>(<span class="hljs-string">&quot;b.word&quot;</span>));<br>        resourceFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PPTFile</span>(<span class="hljs-string">&quot;c.ppt&quot;</span>));<br>        <span class="hljs-keyword">return</span> resourceFiles;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们 只需要添加一个 Compressor 接口，PdfCompressor、PPTCompressor、 WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一 需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关 闭”的设计原则。 </p>
<p>对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我 更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的 功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂 模式的实现方式少很多，类太多也会影响到代码的可维护性。 </p>
<h3 id="重点回顾-13"><a href="#重点回顾-13" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>总体上来讲，访问者模式难以理解，应用场景有限，不是特别必需，我不建议在项目中使用 它。所以，对于上节课中的处理资源文件的例子，我更推荐使用工厂模式来设计和实现。 </p>
<p>除此之外，我们今天重点讲解了 Double Dispatch。在面向对象编程语言中，方法调用可 以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发 送一条消息，这条消息起码要包含对象名、方法名和方法参数。 </p>
<p>所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行 对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispatch，指的是执 行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的 运行时类型来决定。</p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直 接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>
<h1 id="备忘录模式-1"><a href="#备忘录模式-1" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的-消耗？"><a href="#备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的-消耗？" class="headerlink" title="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的 消耗？"></a>备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的 消耗？</h2><p>应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等</p>
<h3 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h3><p>备忘录模式，也叫快照（Snapshot）模式：</p>
<p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>在我看来，这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这 一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这 部分不太好理解。接下来，我就结合一个例子来解释一下，特别带你搞清楚这两个问题：</p>
<p>1为什么存储和恢复副本会违背封装原则？ </p>
<p>2备忘录模式是如何做到不违背封装原则的？</p>
<p>假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本 时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的 内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输 入的文本删除掉。</p>
<p>怎么来编程实现呢？你可以打开 IDE 自己先试着编写一下，然后再看我下面的讲解。整体 上来讲，这个小程序实现起来并不复杂。我写了一种实现思路，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputText</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(String input)</span> &#123;<br>        text.append(input);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text.replace(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.text.length(), text);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;InputText&gt; snapshots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> InputText <span class="hljs-title function_">popSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snapshots.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushSnapshot</span><span class="hljs-params">(InputText inputText)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">deepClonedInputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        deepClonedInputText.setText(inputText.getText());<br>        snapshots.push(deepClonedInputText);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">inputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        <span class="hljs-type">SnapshotHolder</span> <span class="hljs-variable">snapshotsHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotHolder</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:list&quot;</span>)) &#123;<br>                System.out.println(inputText.toString());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:undo&quot;</span>)) &#123;<br>                <span class="hljs-type">InputText</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotsHolder.popSnapshot();<br>                inputText.setText(snapshot.getText());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                snapshotsHolder.pushSnapshot(inputText);<br>                inputText.append(input);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编 程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功 能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二 点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一 点，主要体现在下面两方面：</p>
<p>第一，为了能用快照恢复 InputText 对象，我们在 InputText 类中定义了 setText() 函 数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原 则；</p>
<p>第二，快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数， 但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，用 InputText 类来表示快照违 背了封装原则。</p>
<p>针对以上问题，我们对代码做两点修改。其一，定义一个独立的类（Snapshot 类）来表示 快照，而不是复用 InputText 类。这个类只暴露 get() 方法，没有 set() 等任何修改内部状 态的方法。其二，在 InputText 类中，我们把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确，只用来恢复对象。 </p>
<p>按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputText</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(String input)</span> &#123;<br>        text.append(input);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Snapshot <span class="hljs-title function_">createSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(text.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreSnapshot</span><span class="hljs-params">(Snapshot snapshot)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text.replace(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.text.length(), snapshot.getText());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Snapshot</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Snapshot</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.text;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> Snapshot <span class="hljs-title function_">popSnapshot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snapshots.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushSnapshot</span><span class="hljs-params">(Snapshot snapshot)</span> &#123;<br>        snapshots.push(snapshot);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputText</span> <span class="hljs-variable">inputText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputText</span>();<br>        <span class="hljs-type">SnapshotHolder</span> <span class="hljs-variable">snapshotsHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotHolder</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:list&quot;</span>)) &#123;<br>                System.out.println(inputText.toString());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.equals(<span class="hljs-string">&quot;:undo&quot;</span>)) &#123;<br>                <span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotsHolder.popSnapshot();<br>                inputText.restoreSnapshot(snapshot);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                snapshotsHolder.pushSnapshot(inputText.createSnapshot());<br>                inputText.append(input);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 GoF 的 《设计模式》）中给出的实现方法。 </p>
<p>除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在我们平时的开发中更常听 到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都 应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和 实现，备份更侧重架构设计或产品设计。这个不难理解，这里我就不多说了。</p>
<h3 id="如何优化内存和时间消耗？"><a href="#如何优化内存和时间消耗？" class="headerlink" title="如何优化内存和时间消耗？"></a>如何优化内存和时间消耗？</h3><p>前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要 备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗 时会比较长。这个问题该如何解决呢？ </p>
<p>不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘 录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入， 不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，我们不 需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用 这个值结合 InputText 类对象存储的文本来做撤销操作。 我们再举一个例子。假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果 需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对 时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会采用“低频率全量备 份”和“高频率增量备份”相结合的方法。 </p>
<p>全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下 来。所谓“增量备份”，指的是记录每次操作或数据变动。 </p>
<p>当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来 恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份， 然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的 操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p>
<h3 id="重点回顾-14"><a href="#重点回顾-14" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内 部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义 表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则 的前提下，进行对象的备份和恢复。 </p>
<p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我 们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现， 备份更侧重架构设计或产品设计。 </p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对 这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的 数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结 合来做恢复。</p>
<h1 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="命令模式：如何利用命令模式实现一个手游后端架构？"><a href="#命令模式：如何利用命令模式实现一个手游后端架构？" class="headerlink" title="命令模式：如何利用命令模式实现一个手游后端架构？"></a>命令模式：如何利用命令模式实现一个手游后端架构？</h2><p>命令 模式、解释器模式、中介模式。这 3 个模式使用频率低、理解难度大，只在非常特定的应 用场景下才会用到，所以，不是我们学习的重点，你只需要稍微了解，见了能认识就可以 了。</p>
<p>在学习这个模式的过程中，你可能会遇到的最大的疑 惑是，感觉命令模式没啥用，是一种过度设计，有更加简单的设计思路可以替代。所以，我 今天讲解的重点是这个模式的设计意图，带你搞清楚到底什么情况下才真正需要使用它。</p>
<h3 id="命令模式的原理解读"><a href="#命令模式的原理解读" class="headerlink" title="命令模式的原理解读"></a>命令模式的原理解读</h3><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。 </p>
<p>GoF 给出的定义，我这里再进一步解读一下。 </p>
<p>落实到编码实现，命令模式用的最核心的实现手段，<strong>是将函数封装成对象。</strong>我们知道，C 语 言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函 数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数 封装成对象。具体来说就是，设计<strong>一个包含这个函数的类，实例化一个对象传来传去，这样 就可以实现把函数像对象一样使用。</strong>从实现的角度来说，它类似我们之前讲过的回调。 </p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，<strong>命令模式的主 要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做 命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</strong></p>
<h3 id="命令模式的实战讲解"><a href="#命令模式的实战讲解" class="headerlink" title="命令模式的实战讲解"></a>命令模式的实战讲解</h3><p>上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。 </p>
<p>假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的 复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询， 所以，后端逻辑相对于客户端来说，要简单很多。</p>
<p>考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。 </p>
<p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内 存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低 实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个 玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简 单了很多。 </p>
<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建 立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服 务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据 是执行这个指令所需的数据。 </p>
<p>服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同 的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。 </p>
<p>常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线 程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一 个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。 </p>
<p>另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它 无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切 换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器 开发中比较常见的架构模式了。 </p>
<p>我们接下来就重点讲一下第二种实现方式。</p>
<p>整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求 包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定 数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示， 你可以结合着一块看下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GotDiamondCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">// 省略成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GotDiamondCommand</span><span class="hljs-params">(<span class="hljs-comment">/*数据*/</span>)</span> &#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 执行相应的逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameApplication</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_HANDLED_REQ_COUNT_PER_LOOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> Queue&lt;Command&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mainloop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            List&lt;Request&gt; requests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span><br><span class="hljs-comment">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span><br>            <span class="hljs-keyword">for</span> (Request request : requests) &#123;<br>                <span class="hljs-type">Event</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> request.getEvent();<br>                <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GotDiamondCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.GOT_STAR)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GotStartCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HitObstacleCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.equals(Event.ARCHIVE)) &#123;<br>                    command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArchiveCommand</span>(<span class="hljs-comment">/*数据*/</span>);<br>                &#125; <span class="hljs-comment">// ...一堆else if...</span><br>                queue.add(command);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">handledCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;<br>                <span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> queue.poll();<br>                command.execute();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="命令模式-VS-策略模式"><a href="#命令模式-VS-策略模式" class="headerlink" title="命令模式 VS 策略模式"></a>命令模式 VS 策略模式</h3><p>看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区 别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都 很相似。不知道你有没有类似的感觉呢？ </p>
<p>实际上，这个问题我之前简单提到过，可能没有作为重点来说，有些同学印象不是很深刻， 这里我就再跟你讲一讲。 </p>
<p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪 类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现 并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就 会产生大部分模式看起来都很相似的错觉。 </p>
<p>实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路 或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。 </p>
<p>之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代 码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个 特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式 侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是 其他东西。从设计意图上来，这两个模式完全是两回事儿。 </p>
<p>有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的 执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区 别。 </p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如， BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现 的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对 应不同的处理逻辑，并且互相之间不可替换。</p>
<h3 id="重点回顾-15"><a href="#重点回顾-15" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>命令模式在平时工作中并不常用，你稍微了解一下就可以。今天，我重点讲解了它的设计意 图，也就是能解决什么问题。 </p>
<p><u>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在 大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令 模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</u> </p>
<p><u>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命 令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用 的地方。</u></p>
<h1 id="解释器模式-1"><a href="#解释器模式-1" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="解释器模式：如何设计实现一个自定义接口告警规则功能？"><a href="#解释器模式：如何设计实现一个自定义接口告警规则功能？" class="headerlink" title="解释器模式：如何设计实现一个自定义接口告警规则功能？"></a>解释器模式：如何设计实现一个自定义接口告警规则功能？</h2><p>解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令 模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则 表达式。</p>
<h3 id="解释器模式的原理和实现"><a href="#解释器模式的原理和实现" class="headerlink" title="解释器模式的原理和实现"></a>解释器模式的原理和实现</h3><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解 释器用来处理这个语法。</p>
<p>实际上，这里的“语言”不仅仅指我们平时说的中、英、 日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语 言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。 </p>
<p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据 语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅 读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是 应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的<u>核心思想，就是将语法 解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆 分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</u></p>
<p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。 利用解释器模式，我们把解析的工作拆分到 NumberExpression、AdditionExpression、 SubstractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析 类中。</p>
<h3 id="解释器模式实战举例"><a href="#解释器模式实战举例" class="headerlink" title="解释器模式实战举例"></a>解释器模式实战举例</h3><p>接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一 个自定义接口告警规则功能？ </p>
<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时 将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微 信、邮件等方式发送告警给开发者。 </p>
<p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来 表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调 用数超过 10000 就触发告警。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">api_error_per_minute &gt; <span class="hljs-number">100</span> || api_count_per_minute &gt; <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块 将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块。接下来，我们只 关注告警模块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Long&gt; apiStat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>apiStat.put(<span class="hljs-string">&quot;api_error_per_minute&quot;</span>, <span class="hljs-number">103</span>);<br>apiStat.put(<span class="hljs-string">&quot;api_count_per_minute&quot;</span>, <span class="hljs-number">987</span>);<br></code></pre></td></tr></table></figure>

<p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这 五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算 符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可 以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。 </p>
<p>那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给 出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertRuleInterpreter</span> &#123;<br>    <span class="hljs-comment">// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertRuleInterpreter</span><span class="hljs-params">(String ruleExpression)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>由你来完善</span><br>    &#125;<br>    <span class="hljs-comment">//&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();</span><br><span class="hljs-comment">//apiStat.put(&quot;key1&quot;, 103);</span><br><span class="hljs-comment">//apiStat.put(&quot;key2&quot;, 987);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>由你来完善</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;</span>;<br>        <span class="hljs-type">AlertRuleInterpreter</span> <span class="hljs-variable">interpreter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertRuleInterpreter</span>(rule);<br>        Map&lt;String, Long&gt; stats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        stats.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">101l</span>);<br>        stats.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">121l</span>);<br>        stats.put(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-number">88l</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">alert</span> <span class="hljs-operator">=</span> interpreter.interpret(stats);<br>        System.out.println(alert);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个 解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们 把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路， 我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> String key;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GreaterExpression</span><span class="hljs-params">(String strExpression)</span> &#123;<br>        String[] elements = strExpression.trim().split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <span class="hljs-keyword">if</span> (elements.length != <span class="hljs-number">3</span> || !elements[<span class="hljs-number">1</span>].trim().equals(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Expression is invalid: &quot;</span> + strExpression);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.key = elements[<span class="hljs-number">0</span>].trim();<br>        <span class="hljs-built_in">this</span>.value = Long.parseLong(elements[<span class="hljs-number">2</span>].trim());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GreaterExpression</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!stats.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">statValue</span> <span class="hljs-operator">=</span> stats.get(key);<br>        <span class="hljs-keyword">return</span> statValue &gt; value;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(String strAndExpression)</span> &#123;<br>        String[] strExpressions = strAndExpression.split(<span class="hljs-string">&quot;&amp;&amp;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String strExpr : strExpressions) &#123;<br>            <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GreaterExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;&lt;&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LessExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strExpr.contains(<span class="hljs-string">&quot;==&quot;</span>)) &#123;<br>                expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExpression</span>(strExpr));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Expression is invalid: &quot;</span> + strAndExpression<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(List&lt;Expression&gt; expressions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expressions.addAll(expressions);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Expression expr : expressions) &#123;<br>            <span class="hljs-keyword">if</span> (!expr.interpret(stats)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(String strOrExpression)</span> &#123;<br>        String[] andExpressions = strOrExpression.split(<span class="hljs-string">&quot;\\|\\|&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String andExpr : andExpressions) &#123;<br>            expressions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AndExpression</span>(andExpr));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(List&lt;Expression&gt; expressions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expressions.addAll(expressions);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Expression expr : expressions) &#123;<br>            <span class="hljs-keyword">if</span> (expr.interpret(stats)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertRuleInterpreter</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression expression;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertRuleInterpreter</span><span class="hljs-params">(String ruleExpression)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expression = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(ruleExpression);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Map&lt;String, Long&gt; stats)</span> &#123;<br>        <span class="hljs-keyword">return</span> expression.interpret(stats);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点回顾 </p>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。 </p>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个 语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义 上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、 盲文、哑语、摩斯密码等。 </p>
<p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根 据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅 读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现 根据语法规则解读“句子”的解释器。 </p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应 对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作 拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的 独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<p><strong>Q：什么地方用到了解释器模式？</strong></p>
<p>Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编 译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生 成机器可以执行的汇编指令。</p>
<h1 id="中介模式-1"><a href="#中介模式-1" class="headerlink" title="中介模式"></a>中介模式</h1><h2 id="中介模式：什么时候用中介模式？什么时候用观察者模式？"><a href="#中介模式：什么时候用中介模式？什么时候用观察者模式？" class="headerlink" title="中介模式：什么时候用中介模式？什么时候用观察者模式？"></a>中介模式：什么时候用中介模式？什么时候用观察者模式？</h2><h3 id="中介模式的原理和实现"><a href="#中介模式的原理和实现" class="headerlink" title="中介模式的原理和实现"></a>中介模式的原理和实现</h3><p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。 将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>还记得我们在第 30 节课中讲的“如何给代码解耦”吗？其中一个方法就是引入中间层。 </p>
<p>实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的 交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个 对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关 系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>这里我画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关 系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁。</p>
<p><img   class="lazyload" data-original="https://gitee.com/geng_kun_yuan/myimg/raw/master/img/20220120131228.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220120083956928"></p>
<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。</p>
<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需 要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引 入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来 负责每架飞机的航线调度。这样就大大简化了通信网络。 </p>
<p>刚刚举的是生活中的例子，我们再举一个跟编程开发相关的例子。这个例子与 UI 控件有 关，算是中介模式比较经典的应用，很多书籍在讲到中介模式的时候，都会拿它来举例。</p>
<p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。 当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选 择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登 陆相关的控件就会显示在对话框中。 </p>
<p>按照通常我们习惯的 UI 界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这 个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIControl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;login_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REG_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;reg_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USERNAME_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pswd_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;repeated_pswd_input</span><br><span class="hljs-string">    private static final String HINT_TEXT_ID = &quot;</span>hint_text<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    private static final String SELECTION_ID = &quot;</span>selection<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="hljs-string">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="hljs-string">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="hljs-string">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="hljs-string">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="hljs-string">        loginButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                String username = usernameInput.text();</span><br><span class="hljs-string">                String password = passwordInput.text();</span><br><span class="hljs-string">        //校验数据...</span><br><span class="hljs-string">        //做业务处理...</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        regButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">        //获取usernameInput、passwordInput、repeatedPswdInput数据...</span><br><span class="hljs-string">        //校验数据...</span><br><span class="hljs-string">        //做业务处理...</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//...省略selection下拉选择框相关代码....</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<p>我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介 对象交互，中介对象负责所有业务逻辑的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(Component component, String event)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LandingPageDialog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">private</span> Button loginButton;<br>    <span class="hljs-keyword">private</span> Button regButton;<br>    <span class="hljs-keyword">private</span> Selection selection;<br>    <span class="hljs-keyword">private</span> Input usernameInput;<br>    <span class="hljs-keyword">private</span> Input passwordInput;<br>    <span class="hljs-keyword">private</span> Input repeatedPswdInput;<br>    <span class="hljs-keyword">private</span> Text hintText;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(Component component, String event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (component.equals(loginButton)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> usernameInput.text();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> passwordInput.text();<br><span class="hljs-comment">//校验数据...</span><br><span class="hljs-comment">//做业务处理...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.equals(regButton)) &#123;<br><span class="hljs-comment">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span><br><span class="hljs-comment">//校验数据...</span><br><span class="hljs-comment">//做业务处理...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.equals(selection)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">selectedItem</span> <span class="hljs-operator">=</span> selection.select();<br>            <span class="hljs-keyword">if</span> (selectedItem.equals(<span class="hljs-string">&quot;login&quot;</span>)) &#123;<br>                usernameInput.show();<br>                passwordInput.show();<br>                repeatedPswdInput.hide();<br>                hintText.hide();<br><span class="hljs-comment">//...省略其他代码</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedItem.equals(<span class="hljs-string">&quot;register&quot;</span>)) &#123;<br><span class="hljs-comment">//....</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIControl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;login_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REG_BTN_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;reg_btn&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USERNAME_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pswd_input&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;repeated_pswd_input</span><br><span class="hljs-string">    private static final String HINT_TEXT_ID = &quot;</span>hint_text<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    private static final String SELECTION_ID = &quot;</span>selection<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="hljs-string">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="hljs-string">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="hljs-string">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="hljs-string">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="hljs-string">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="hljs-string">        Mediator dialog = new LandingPageDialog();</span><br><span class="hljs-string">        dialog.setLoginButton(loginButton);</span><br><span class="hljs-string">        dialog.setRegButton(regButton);</span><br><span class="hljs-string">        dialog.setUsernameInput(usernameInput);</span><br><span class="hljs-string">        dialog.setPasswordInput(passwordInput);</span><br><span class="hljs-string">        dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class="hljs-string">        dialog.setHintText(hintText);</span><br><span class="hljs-string">        dialog.setSelection(selection);</span><br><span class="hljs-string">        loginButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                dialog.handleEvent(loginButton, &quot;</span>click<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        regButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public void onClick(View v) &#123;</span><br><span class="hljs-string">                dialog.handleEvent(regButton, &quot;</span>click<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//....</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实 际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会 变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实 际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<h3 id="中介模式-VS-观察者模式"><a href="#中介模式-VS-观察者模式" class="headerlink" title="中介模式 VS 观察者模式"></a>中介模式 VS 观察者模式</h3><p>前面讲观察者模式的时候，我们讲到，观察者模式有多种实现方式。虽然经典的实现方式没 法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用 观察者的 update() 方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底 解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被 观察者也完全不知道观察者的存在。 </p>
<p>我们前面提到，中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交 互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察 者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式 的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？ </p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分 情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具 两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。 </p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们 才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能 会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作 有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者 的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。 </p>
<h3 id="重点回顾-16"><a href="#重点回顾-16" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系 （或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代 码的复杂度，提高了代码的可读性和可维护性。 </p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应 用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的， 一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中， 参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>kygeng</li>
    <li><strong>本文链接：</strong><a href="https://kygeng.github.io/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E03_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html" title="https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng.github.io&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E03_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html">https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng.github.io&#x2F;2022&#x2F;01&#x2F;07&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E03_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/kygeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul> 

        
  <nav class="nav">
    <a href="/kygeng.github.io/2022/02/23/%E5%A4%A7%E5%8E%82%E5%AD%A6%E9%99%A2%EF%BC%9ARedis6/"><i class="iconfont iconleft"></i>Redis6</a>
    <a href="/kygeng.github.io/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式02-结构型模式<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%B8%8A%E7%AF%87"><span class="toc-text">行为型模式 | 上篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-text">行为型模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87"><span class="toc-text">设计模式使用频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="toc-text">模板模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">职责链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">迭代器模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E8%AF%A6%E8%A7%A3%E5%90%84%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0-%E6%96%B9%E5%BC%8F"><span class="toc-text">观察者模式（上）：详解各种应用场景下观察者模式的不同实现 方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%89%96%E6%9E%90"><span class="toc-text">原理及应用场景剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">基于不同应用场景的不同实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84EventBus%E6%A1%86-%E6%9E%B6%EF%BC%9F"><span class="toc-text">观察者模式（下）：如何实现一个异步非阻塞的EventBus框 架？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">异步非阻塞观察者模式的简易实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventBus-%E6%A1%86%E6%9E%B6%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E4%BB%8B%E7%BB%8D"><span class="toc-text">EventBus 框架功能需求介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-EventBus-%E6%A1%86"><span class="toc-text">手把手实现一个 EventBus 框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-1"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">模板模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%89%96%E6%9E%90%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E3%80%81Servlet%E3%80%81JUnit%E7%AD%89%E4%B8%AD-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">模板模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BD%9C%E7%94%A8%E4%B8%80%EF%BC%9A%E5%A4%8D%E7%94%A8"><span class="toc-text">模板模式作用一：复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BD%9C%E7%94%A8%E4%BA%8C%EF%BC%9A%E6%89%A9%E5%B1%95"><span class="toc-text">模板模式作用二：扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-2"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%B8%8ECallback%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-text">模板模式（下）：模板模式与Callback回调函数有何区别和联系？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">回调的原理解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E4%B8%80%EF%BC%9AJdbcTemplate"><span class="toc-text">应用举例一：JdbcTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E4%BA%8C%EF%BC%9AsetClickListener-%EF%BC%89"><span class="toc-text">应用举例二：setClickListener(）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E4%B8%89%EF%BC%9AaddShutdownHook"><span class="toc-text">应用举例三：addShutdownHook()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-VS-%E5%9B%9E%E8%B0%83"><span class="toc-text">模板模式 VS 回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-3"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%97%E9%95%BF%E7%9A%84if-else-switch%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%E4%BB%A3-%E7%A0%81%EF%BC%9F"><span class="toc-text">策略模式（上）：如何避免冗长的if-else&#x2F;switch分支判断代 码？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">策略模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.策略的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AD%96%E7%95%A5%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.策略的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%81%BF%E5%85%8D%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-text">如何利用策略模式避免分支判断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-4"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E7%BB%99%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%8F%E7%A8%8B-%E5%BA%8F%EF%BC%9F"><span class="toc-text">策略模式（下）：如何实现一个支持给不同大小文件排序的小程 序？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-text">代码实现与分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E9%87%8D%E6%9E%84"><span class="toc-text">代码优化与重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-5"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">职责链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%81%B5%E6%B4%BB%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E8%BF%87%E6%BB%A4%E6%A1%86-%E6%9E%B6%EF%BC%9F"><span class="toc-text">职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框 架？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">职责链模式的原理和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">职责链模式的应用场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-6"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-%E7%9A%84%EF%BC%9F"><span class="toc-text">职责链模式（下）：框架中常用的过滤器、拦截器是如何实现 的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-Filter"><span class="toc-text">Servlet Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Interceptor"><span class="toc-text">Spring Interceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-7"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B8%B8%E6%88%8F%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9F"><span class="toc-text">什么是有限状态机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%88%86%E6%94%AF%E9%80%BB%E8%BE%91%E6%B3%95"><span class="toc-text">状态机实现方式一：分支逻辑法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E6%9F%A5%E8%A1%A8%E6%B3%95"><span class="toc-text">状态机实现方式二：查表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">状态机实现方式三：状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-8"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E7%9B%B8%E6%AF%94%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B-%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-text">迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些 优势？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">迭代器模式的原理和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-9"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A2%9E%E5%88%A0%E9%9B%86%E5%90%88%E5%85%83-%E7%B4%A0%EF%BC%9F"><span class="toc-text">迭代器模式（中）：遍历集合的同时，为什么不能增删集合元 素？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%81%8D%E5%8E%86%E7%9A%84%E5%90%8C%E6%97%B6%E5%A2%9E%E5%88%A0%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">在遍历的同时增删集合元素会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E9%81%8D%E5%8E%86%E6%97%B6%E6%94%B9%E5%8F%98%E9%9B%86%E5%90%88%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9C%AA%E5%86%B3%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-text">如何应对遍历时改变集合导致的未决行为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-10"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E2%80%9C%E5%BF%AB%E7%85%A7%E2%80%9D%E5%8A%9F%E8%83%BD%E7%9A%84-iterator%EF%BC%9F"><span class="toc-text">迭代器模式（下）：如何设计实现一个支持“快照”功能的 iterator？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-text">解决方案一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-text">解决方案二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-11"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%B8%8B%E7%AF%87"><span class="toc-text">行为型模式 | 下篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88-1"><span class="toc-text">行为型模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87-1"><span class="toc-text">设计模式使用频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">中介模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E8%BF%98%E5%8E%9F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%9E%E7%94%9F%E7%9A%84%E6%80%9D%E7%BB%B4%E8%BF%87%E7%A8%8B"><span class="toc-text">访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E4%BD%A0%E2%80%9C%E5%8F%91%E6%98%8E%E2%80%9D%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">带你“发明”访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%9D%A5%E7%9C%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">重新来看访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-12"><span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8F%8C%E5%88%86%E6%B4%BE%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1-%E5%BC%8F%EF%BC%9F"><span class="toc-text">访问者模式（下）：为什么支持双分派的语言不需要访问者模 式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8F%8C%E5%88%86%E6%B4%BE%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">为什么支持双分派的语言不需要访问者模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%8A%E4%B8%80%E8%8A%82%E7%9A%84%E4%BE%8B%E5%AD%90%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-text">除了访问者模式，上一节的例子还有其他实现方案吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-13"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84-%E6%B6%88%E8%80%97%EF%BC%9F"><span class="toc-text">备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的 消耗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">备忘录模式的原理与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E5%92%8C%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%EF%BC%9F"><span class="toc-text">如何优化内存和时间消耗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-14"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%89%8B%E6%B8%B8%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-text">命令模式：如何利用命令模式实现一个手游后端架构？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB"><span class="toc-text">命令模式的原理解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E6%88%98%E8%AE%B2%E8%A7%A3"><span class="toc-text">命令模式的实战讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-VS-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">命令模式 VS 策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-15"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%91%8A%E8%AD%A6%E8%A7%84%E5%88%99%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">解释器模式：如何设计实现一个自定义接口告警规则功能？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">解释器模式的原理和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B8%BE%E4%BE%8B"><span class="toc-text">解释器模式实战举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">中介模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">中介模式：什么时候用中介模式？什么时候用观察者模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">中介模式的原理和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F-VS-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">中介模式 VS 观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE-16"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/kygeng.github.io/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/kygeng.github.io/js/utils.js"></script>
<script src="/kygeng.github.io/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>