

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>MySQL百科全书 - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content=", MySQL">
  <meta name="description" content="MySQL高级一、Linux下的安装与使用常用命令行1...">
  <meta name="author" content="John Doe">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/kygeng/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: false
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">MySQL百科全书</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226220356.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">MySQL百科全书</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>March 23, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>85355</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Linux下的安装与使用"><a href="#一、Linux下的安装与使用" class="headerlink" title="一、Linux下的安装与使用"></a>一、Linux下的安装与使用</h1><h2 id="常用命令行"><a href="#常用命令行" class="headerlink" title="常用命令行"></a>常用命令行</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查看MySQL版本</span><br>mysql --version<br><br><span class="hljs-section"># 查看是否安装成功</span><br>rpm -qa|grep -i mysql<br><br><span class="hljs-section"># 启动MySQL，查看状态</span><br>启动：systemctl start mysqld.service<br>关闭：systemctl stop mysqld.service<br>重启：systemctl restart mysqld.service<br>查看状态：systemctl status mysqld.service<br><br><span class="hljs-section"># 重新启动MySQL服务</span><br>systemctl restart mysqld<br><br><span class="hljs-section"># 设置MySQL服务自启动</span><br>systemctl enable mysqld.service<br><br><span class="hljs-section"># 修改已创建数据库的字符集</span><br>alter database dbtest1 character set &#x27;utf8&#x27;;<br><br><span class="hljs-section"># 修改已创建数据表的字符集</span><br>alter table t<span class="hljs-emphasis">_emp convert to character set &#x27;utf8&#x27;;</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure>



<p>登录MySQL服务器 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下： </p>
<p>下面详细介绍命令中的参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql –h hostname<span class="hljs-operator">|</span>hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>hlocalhost <span class="hljs-operator">-</span>P3306 mysql <span class="hljs-operator">-</span>e &quot;select host,user from user&quot;<br></code></pre></td></tr></table></figure>

<p>-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </p>
<p>-P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306， 不使用该参数时自动连接到3306端口，port为连接的端口号。 </p>
<p>-u参数 后面接用户名，username为用户名。 </p>
<p>-p参数 会提示输入密码。 </p>
<p>DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库 中，然后可以使用USE命令来选择数据库。 </p>
<p>-e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL 服务器。</p>
<h2 id="SQL大小写规范"><a href="#SQL大小写规范" class="headerlink" title="SQL大小写规范"></a>SQL大小写规范</h2><p>不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大 小写问题。 windows系统默认大小写不敏感 ，但是 linux系统是大小写敏感的 。 </p>
<p>通过如下命令查看：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%lower_case_table_names%&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210154.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121150030248"></p>
<p>lower_case_table_names参数值的设置： </p>
<ul>
<li><p>默认为0，大小写敏感 。 </p>
</li>
<li><p>设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转 换为小写对表和数据库进行查找。 </p>
</li>
<li><p>设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。 </p>
</li>
</ul>
<p><strong>两个平台上SQL大小写的区别具体来说：</strong></p>
<p>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的： </p>
<p>1、数据库名、表名、表的别名、变量名是严格区分大小写的； </p>
<p>2、关键字、函数名称在 SQL 中不区分大小写； </p>
<p>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的； </p>
<p>MySQL在Windows的环境下全部不区分大小写</p>
<h2 id="sql-mode的合理设置"><a href="#sql-mode的合理设置" class="headerlink" title="sql_mode的合理设置"></a>sql_mode的合理设置</h2><p>sql_mode 会影响MySQL支持的SQL语法以及它执行的<code>数据验证检查</code>。通过设置sql_mode，可以完成不同严格程度的数据校验，有效地保障数据准确性。</p>
<p>MySQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于sql_mode系统变量的值。</p>
<p>MySQL5.6和MySQL5.7默认的sql_mode模式参数是不一样的:</p>
<ul>
<li><p>5.6的mode默认值为空(即: NO_ENGINE_SUBSTITUTION )，其实表示的是一个空值，相当于没有什么模式设置，可以理解为<code>宽松模式</code>。在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。</p>
</li>
<li><p>5.7的mode是 STRICT_TRANS_TABLES，也就是<code>严格模式</code>。用于进行数据的严格校验，错误数据不能插入，报error(错误)，并且事务回滚。</p>
</li>
</ul>
<hr>
<p><strong>宽松模式：</strong> </p>
<p>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受， 并且不报错。 </p>
<p><strong>举例 ：</strong>我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时 char(10) ，如果我 在插入数据的时候，其中name这个字段对应的有一条数据的 长度超过了10 ，例如’1234567890abc’，超 过了设定的字段长度10，那么不会报错，并且取前10个字符存上，也就是说你这个数据被存为 了’1234567890’，而’abc’就没有了。但是，我们给的这条数据是错误的，因为超过了字段长度，但是并没 有报错，并且mysql自行处理并接受了，这就是宽松模式的效果。 </p>
<p><strong>应用场景 ：</strong>通过设置sql mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据 库之间进行 迁移 时，则不需要对业务sql 进行较大的修改。 </p>
<p><strong>严格模式：</strong> </p>
<p>出现上面宽松模式的错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式。所 以在 生产等环境 中，我们必须采用的是严格模式，进而 开发、测试环境 的数据库也必须要设置，这样在 开发测试阶段就可以发现问题。并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式。 </p>
<p><strong>开发经验 ：</strong>MySQL等数据库总想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实开发 中，我们应该在自己 开发的项目程序级别将这些校验给做了 ，虽然写项目的时候麻烦了一些步骤，但是这 样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。 </p>
<p><strong>改为严格模式后可能会存在的问题：</strong></p>
<p>若设置模式中包含了 NO_ZERO_DATE ，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而 不是警告。例如，表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配 DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这显然是不满足sql_mode中的NO_ZERO_DATE而报错。</p>
<h1 id="二、MySQL的数据目录"><a href="#二、MySQL的数据目录" class="headerlink" title="二、MySQL的数据目录"></a>二、MySQL的数据目录</h1><h2 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">find / -name mysql<br></code></pre></td></tr></table></figure>

<p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>
<p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和 /usr/sbin</p>
<p>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</p>
<h2 id="MySQL自带的系统数据库"><a href="#MySQL自带的系统数据库" class="headerlink" title="MySQL自带的系统数据库"></a>MySQL自带的系统数据库</h2><p>SHOW DATABASES;</p>
<p>可以看到有4个数据库是属于MySQL自带的系统数据库。 </p>
<p><strong>mysql</strong></p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定 义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 </p>
<p><strong>information_schema</strong> </p>
<p>MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有 哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些 描述性信息，有时候也称之为 元数据 。在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表，用于表示内部系统表。</p>
<p><strong>performance_schema</strong></p>
<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以 用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。 </p>
<p><strong>sys</strong></p>
<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
<h2 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h2><h3 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a>InnoDB存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：<code>表名.frm</code></p>
<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>
<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件 的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的。</p>
<p><strong>2、表中数据和索引</strong></p>
<p><strong>① 系统表空间（system tablespace）</strong> </p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自 己增加文件大小。 </p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名 难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置 文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_data_file_path</span>=data1:<span class="hljs-number">512</span>M<span class="hljs-comment">;data2:512M:autoextend</span><br></code></pre></td></tr></table></figure>

<p><strong>② 独立表空间(file-per-table tablespace)</strong></p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来 存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表 名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：<code>表名.ibd</code></p>
<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应 的 atguigu 目录下会为 test 表创建这两个文件：<code>test.frm</code>  <code>test.ibd</code></p>
<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>
<p><strong>③ 系统表空间与独立表空间的设置</strong> </p>
<p>我们可以自己指定使用 <code>系统表空间</code> 还是 <code>独立表空间</code> 来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动 MySQL服务器的时候这样配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span> <span class="hljs-comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></code></pre></td></tr></table></figure>

<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| innodb_file_per_table | ON    |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>



<p><strong>④ 其他类型的表空间</strong> </p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用 表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h3 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h3><p><strong>1、表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专 门用于描述表结构的文件：<code>表名.frm</code></p>
<p><strong>2、表中数据和索引</strong> </p>
<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test 表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文 件：</p>
<p><code>test.frm 存储表结构 </code></p>
<p><code>test.MYD 存储数据 (MYData) </code></p>
<p><code>test.MYI 存储索引 (MYIndex)</code></p>
<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student_myisam` (<br>`id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`sex` <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>)ENGINE=MYISAM AUTO_INCREMENT=<span class="hljs-number">0</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb3;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>举例： <code>数据库a ， 表b </code>。 </p>
<p><strong>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</strong> </p>
<p><code>b.frm </code>：描述表结构文件，字段长度等 </p>
<p>如果采用 <code>系统表空间</code> 模式的，数据信息和索引信息都存储在 <code>ibdata1</code> 中 </p>
<p>如果采用 <code>独立表空间</code> 存储模式，data\a 中还会产生 <code>b.ibd</code> 文件（存储数据信息和索引信息） </p>
<p>此外： </p>
<p>​    ① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较 规则。而MySQL8.0不再提供db.opt文件。 </p>
<p>​    ② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。 </p>
<p><strong>2、如果表b采用 <code>MyISAM</code> ，data\a 中会产生3个文件：</strong> </p>
<p>​    MySQL5.7 中：<code>b.frm</code> ：描述表结构文件，字段长度等。 </p>
<p>​    MySQL8.0 中 <code>b.xxx.sdi </code>：描述表结构文件，字段长度等 </p>
<p>​    <code>b.MYD (MYData)</code>：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>
<p>​    <code>b.MYI (MYIndex)</code>：存放索引信息文件</p>
<h2 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h2><p>我们知道MysQL中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只余存储一个 <code>视图名.frm</code>的文件。如下图中的: emp_details_view.frm</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[ root<span class="hljs-symbol">@atguigu82</span> mysql]<span class="hljs-meta"># cd ./temp</span><br>[ root<span class="hljs-symbol">@atguigu82</span> temp]<span class="hljs-meta"># ll</span><br></code></pre></td></tr></table></figure>

<h2 id="其他的文件"><a href="#其他的文件" class="headerlink" title="其他的文件"></a>其他的文件</h2><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件:</p>
<p><strong>1、服务器进程文件</strong></p>
<p>我们知道每运行一个MySQL服务器程序，都意味着启动一个进程。MySQL服务器会把自己的进程ID写入到一个文件中。</p>
<p><strong>2、服务器日志文件</strong></p>
<p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等。这些日志各有各的用途，后面讲解。</p>
<p><strong>3、默认/自动生成的SSL和RSA证书和密钥文件</strong></p>
<p>主要是为了客户端和服务器安全通信而创建的一些文件。</p>
<h1 id="三、用户与权限管理"><a href="#三、用户与权限管理" class="headerlink" title="三、用户与权限管理"></a>三、用户与权限管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>MySQL用户可以分为普通用户和root用户。root用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限;普通用户只拥有被授予的各种权限。</p>
<p>MysQL提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出MysQL服务器、创建用户、删除用户、密码管理和权限管理等内容。</p>
<p><strong>MySQL数据库的安全性需要通过账户管理来保证。</strong></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210155.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220120174452352"></p>
<p><strong>可以创建同名的用户，该表中使用 host 和 user 作为联合主键，就算 user相同，只要 host不同就可以</strong></p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>][,用户名 [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>]];<br></code></pre></td></tr></table></figure>

<p>用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成； </p>
<p>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户 可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY指定明文密码值。 </p>
<p>CREATE USER语句可以同时创建多个用户。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> zhang3 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123123&#x27;</span>; # 默认host是 %<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户名：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;li4&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">USER</span>=<span class="hljs-string">&#x27;wang5&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>方式1：使用DROP方式删除（推荐） 使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span>[,<span class="hljs-keyword">user</span>]…;<br></code></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">li4</span> ; <span class="hljs-comment"># 默认删除host为%的用户</span><br>DROP <span class="hljs-keyword">USER</span> <span class="hljs-title">&#x27;kangshifu</span>&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure>

<p>方式2：使用DELETE方式删除 </p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=’hostname’ <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=’username’;<br></code></pre></td></tr></table></figure>

<p>执行完DELETE命令后要使用FLUSH命令来使用户生效，命令如下： </p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH PRIVILEGES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host=<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">User</span>=<span class="hljs-string">&#x27;Emily&#x27;</span>;<br>FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure>

<p>注意：不推荐通过 DELETE FROM USER u WHERE USER=’li4’ 进行删除，系统会有残留信息保 留。而drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表 的相应记录都消失了。</p>
<h3 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h3><p>旧的写法如下 ： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 修改当前用户的密码：（MySQL5<span class="hljs-number">.7</span>测试有效）<br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-operator">=</span> PASSWORD(<span class="hljs-string">&#x27;123456&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>这里介绍 推荐的写法 ： </p>
<p>1、使用ALTER USER命令来修改当前用户密码 用户可以使用ALTER命令来修改自身密码，如下语句代表修 改当前登录用户的密码。基本语法如下： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">USER</span>() IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>2、使用SET语句来修改当前用户密码 使用root用户登录MySQL后，可以使用SET语句来修改密码，具体 SQL语句如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">PASSWORD</span>=<span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>该语句会自动将密码加密后再赋给当前用户。</p>
<h3 id="修改其它用户密码"><a href="#修改其它用户密码" class="headerlink" title="修改其它用户密码"></a>修改其它用户密码</h3><p>1、使用ALTER语句来修改普通用户的密码 可以使用ALTER USER语句来修改普通用户的密码。基本语法形 式如下： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span> [IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]<br>[,<span class="hljs-keyword">user</span>[IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>]]…;<br></code></pre></td></tr></table></figure>



<p>2、使用SET命令来修改普通用户的密码 使用root用户登录到MySQL服务器后，可以使用SET语句来修改普 通用户的密码。SET语句的代码如下：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-comment">FOR</span> <span class="hljs-comment">&#x27;username&#x27;</span><span class="hljs-comment">@</span><span class="hljs-comment">&#x27;hostname&#x27;</span><span class="hljs-comment">=</span><span class="hljs-comment">&#x27;new_password&#x27;</span>;<br><br></code></pre></td></tr></table></figure>



<p>3、使用UPDATE语句修改普通用户的密码（不推荐）</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> MySQL.<span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> authentication_string=<span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&quot;123456&quot;</span>)<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">User</span> = <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">AND</span> Host = <span class="hljs-string">&quot;hostname&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8密码管理-了解"><a href="#MySQL8密码管理-了解" class="headerlink" title="MySQL8密码管理(了解)"></a>MySQL8密码管理(了解)</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210156.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121153526888"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210157.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121153540169"></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h3><p>MySQL到底都有哪些权限呢？ </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210158.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121075608980"></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure>

<p>（1） <code>CREATE和DROP权限</code> ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将 MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 </p>
<p>（2） <code>SELECT、INSERT、UPDATE和DELETE权限</code> 允许在一个数据库现有的表上实施操作。 </p>
<p>（3） <code>SELECT权限</code> 只有在它们真正从一个表中检索行时才被用到。 </p>
<p>（4） <code>INDEX权限</code> 允许创建或删除索引，INDEX适用于已 有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 </p>
<p>（5） <code>ALTER权 限</code> 可以使用ALTER TABLE来更改表的结构和重新命名表。 </p>
<p>（6） <code>CREATE ROUTINE权限</code> 用来创建保存的 程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的 程序。 </p>
<p>（7） <code>GRANT权限</code> 允许授权给其他用户，可用于数据库、表和保存的程序。 </p>
<p>（8） <code>FILE权限</code> 使用 户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权 限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务 器可以访问这些文件）。</p>
<h3 id="授予权限的原则"><a href="#授予权限的原则" class="headerlink" title="授予权限的原则"></a>授予权限的原则</h3><p>权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ： </p>
<p>1、只授予能 满足需要的最小权限 ，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可 以了，不要给用户赋予update、insert或者delete权限。 </p>
<p>2、创建用户的时候 限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。 </p>
<p>3、为每个用户 设置满足密码复杂度的密码 。 </p>
<p>4、 定期清理不需要的用户 ，回收权限或者删除用户。 </p>
<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>给用户授权的方式有 2 种，分别是通过把 角色赋予用户给用户授权 和 直接给用户授权 。用户是数据库的 使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全 隐患。 </p>
<p>授权命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GRANT 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];<br></code></pre></td></tr></table></figure>

<p>该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>比如： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> atguigudb.* <span class="hljs-keyword">TO</span> li4@localhost ;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为<span class="hljs-number">123</span>。注意这里唯独不包括<span class="hljs-keyword">grant</span>的权限<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> joe@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210159.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121080515215"></p>
<p>我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的 分组。 </p>
<p>所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据； </p>
<p>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是 删除。</p>
<p><strong>总结</strong></p>
<p>有一些程序员喜欢使用Root超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。</p>
<p>但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用Root账号。因为Root账号密码放在代码里面不安全，一旦泄露，数据库就会完全<code>失去保护</code>。</p>
<p>而且，MySQL的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p>
<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>查看当前用户权限</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">SHOW</span> GRANTS;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER;<br><span class="hljs-meta"># 或</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> CURRENT_USER();<br></code></pre></td></tr></table></figure>

<p>查看某用户的全局权限</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;主机地址&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全 性。MySQL中使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从 db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中 的账户记录使用DROP USER语句）。 </p>
<p>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</p>
<p>收回权限命令</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">REVOKE</span> 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,…权限n <span class="hljs-literal">ON</span> 数据库名称.表名称 FROM 用户名@用户地址;<br></code></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#收回全库全表的所有权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">FROM</span> joe@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br>#收回mysql库下的所有表的插删改查权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> mysql.* <span class="hljs-keyword">FROM</span> joe@localhost;<br></code></pre></td></tr></table></figure>

<p>注意： 须用户重新登录后才能生效</p>
<h2 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h2><p>MySQL服务器通过<code>权限表</code>来控制用户对数据库的访问，权限表存放在<code>my sql数据库</code>中。MySQL数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是<code>user表、db表</code>。除此之外，还有<code>table_priv表</code>、<code>column_priv表</code>和<code>proc_priv表</code>等。在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<h3 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210200.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121154742904"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210201.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121154629134"></p>
<h3 id="db表"><a href="#db表" class="headerlink" title="db表"></a>db表</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210202.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123100714323"></p>
<h3 id="tables-priv表和columns-priv表"><a href="#tables-priv表和columns-priv表" class="headerlink" title="tables_priv表和columns_priv表"></a>tables_priv表和columns_priv表</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210203.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123100703138"></p>
<h3 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210204.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121154806757"></p>
<h2 id="访问控制-了解"><a href="#访问控制-了解" class="headerlink" title="访问控制(了解)"></a>访问控制(了解)</h2><p>正常情况下，并不希望每个用户都可以执行所有的数据库操作。当MySQL允许一个用户执行各种操作时，它将首先核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为MySQL中的<code>访问控制过程</code>。MySQL的访问控制分为两个阶段：<code>连接核实阶段</code>和<code>请求核实阶段</code>。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210205.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121160707889"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210206.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121081848851"></p>
<h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><p>角色是在<code>MySQL 8.0</code>中引入的新功能。在MysQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以拥有授予和撤消的权限。</p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关 重要的。</p>
<h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><p>创建角色使用 CREATE ROLE 语句，语法如下： </p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">CREATE</span> <span class="hljs-symbol">ROLE</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>] [,<span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>]]...<br></code></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为 空。 </p>
<p>练习：我们现在需要创建一个经理的角色，就可以用下面的代码： </p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-string">&#x27;manager&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="给角色赋予权限"><a href="#给角色赋予权限" class="headerlink" title="给角色赋予权限"></a>给角色赋予权限</h3><p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;role_name&#x27;</span>[@<span class="hljs-string">&#x27;host_name&#x27;</span>];<br></code></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，图11-43 列出了部分权限列表。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">PRIVILEGES</span>\G;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210207.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121160914019"></p>
<p>练习1：我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码 来实现：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.settlement <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.goodsmaster <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> demo.invcount <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="查看角色的权限"><a href="#查看角色的权限" class="headerlink" title="查看角色的权限"></a>查看角色的权限</h3><p>赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br><span class="hljs-section">| Grants for manager@% |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br>| GRANT USAGE ON <span class="hljs-strong">*.*</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`goodsmaster`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br>| GRANT SELECT ON <span class="hljs-code">`demo`</span>.<span class="hljs-code">`invcount`</span> TO <span class="hljs-code">`manager`</span>@<span class="hljs-code">`%`</span> |<br><span class="hljs-section">| GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |</span><br><span class="hljs-section">+-------------------------------------------------------+</span><br></code></pre></td></tr></table></figure>

<p><strong>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是 连接登录数据库的权限 。</strong>代码的 最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权 限。 </p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。 </p>
<h3 id="回收角色的权限"><a href="#回收角色的权限" class="headerlink" title="回收角色的权限"></a>回收角色的权限</h3><p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色 授权相同。撤销角色或角色权限使用REVOKE语句。 </p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。 </p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> tablename <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;rolename&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>练习1：撤销school_write角色的权限。 </p>
<p>（1）使用如下语句撤销school_write角色的权限。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> school.* <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后使用SHOW语句查看school_write对应的权限，语句如下。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;school_write&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h3><p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角 色。删除角色的操作很简单，你只要掌握语法结构就行了。 </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">role</span> [,role2]...<br></code></pre></td></tr></table></figure>

<p>注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。 </p>
<p>练习：执行如下SQL删除角色school_read。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">DROP <span class="hljs-keyword">ROLE</span> <span class="hljs-title">&#x27;school_read</span>&#x27;;<br></code></pre></td></tr></table></figure>

<h3 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h3><p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语 法形式如下： </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">GRANT <span class="hljs-keyword">role</span> <span class="hljs-title">[,role2</span>,...] TO <span class="hljs-keyword">user</span> <span class="hljs-title">[,user2</span>,...];<br></code></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。 </p>
<p>练习：给kangshifu用户添加角色school_read权限。 </p>
<p>（1）使用GRANT语句给kangshifu添加school_read权 限，SQL语句如下。 </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（3）使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如 下。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_ROLE</span>();<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210208.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121161252761"></p>
<h3 id="激活角色"><a href="#激活角色" class="headerlink" title="激活角色"></a>激活角色</h3><p>方式1：使用set default role 命令激活角色 </p>
<p>举例： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>举例：使用 SET DEFAULT ROLE 为下面4个用户默认激活所有已拥有的角色如下： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">ROLE</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TO</span><br><span class="hljs-string">&#x27;dev1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;read_user2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>,<br><span class="hljs-string">&#x27;rw_user1&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方式2：将activate_all_roles_on_login设置为ON </p>
<p>默认情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br><span class="hljs-section">| activate_all_roles_on_login | OFF |</span><br><span class="hljs-section">+-----------------------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>设置：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> GLOBAL <span class="hljs-attribute">activate_all_roles_on_login</span>=ON;<br></code></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有 权限。 </p>
<h3 id="撤销用户的角色"><a href="#撤销用户的角色" class="headerlink" title="撤销用户的角色"></a>撤销用户的角色</h3><p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure>

<p>练习：撤销kangshifu用户的school_read角色。 </p>
<p>（1）撤销的SQL语句如下 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-string">&#x27;school_read&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>（2）撤销后，执行如下查询语句，查看kangshifu用户的角色信息 执行发现，用户kangshifu之前的school_read角色已被撤销。 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;kangshifu&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="设置强制角色-mandatory-role"><a href="#设置强制角色-mandatory-role" class="headerlink" title="设置强制角色(mandatory role)"></a>设置强制角色(mandatory role)</h3><p>方式1：服务启动前设置 </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">mandatory_roles</span>=<span class="hljs-string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></code></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> PERSIST <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后仍然<br>有效<br><span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">mandatory_roles =</span> <span class="hljs-comment">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; #系统重启后失效<br></code></pre></td></tr></table></figure>



<h1 id="四、逻辑架构"><a href="#四、逻辑架构" class="headerlink" title="四、逻辑架构"></a>四、逻辑架构</h1><h2 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a>逻辑架构剖析</h2><p>首先MySQL是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的mysqld</p>
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示:</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210209.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123095116439"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210210.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123095127826"></p>
<h3 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a>第1层：连接层</h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是<code>建立 TCP 连接</code>。 </p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码<code>做身份认证、权限获取</code>。 </p>
<ul>
<li><p>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</p>
</li>
<li><p>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限 </p>
</li>
</ul>
<p>TCP 连接收到请求后，必须要<code>分配给一个线程专门与这个客户端的交互</code>。所以还会有个<code>线程池</code>，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h3 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a>第2层：服务层</h3><p>SQL Interface: SQL接口 </p>
<p><strong>接收用户的SQL命令，并且返回用户需要查询的结果。</strong>比如SELECT … FROM就是调用SQL Interface </p>
<p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口 </p>
<p>Parser: 解析器</p>
<p><strong>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤</strong>，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。 </p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其<strong>创建 语法树</strong> ，并根据数据字 典丰富查询语法树，会 <strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还 会对SQl查询进行<strong>语法上的优化，进行查询重写。</strong> </p>
<p>Optimizer: 查询优化器</p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 <strong>执行计划</strong> 。</p>
<p>这个执行计划表明应该 <strong>使用哪些索引</strong> 进行查询（全表检索还是使用索引检索），<strong>表之间的连 接顺序如何</strong>，最后会<strong>按照执行计划中的步骤调用存储引擎提供的方法</strong>来真正的执行查询，并将 查询结果返回给用户。 </p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> id,<span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> gender = <span class="hljs-string">&#x27;女&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 <strong>投影</strong> ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 <strong>连接</strong> 起来生成最终查询结果。</p>
<p>Caches &amp; Buffers： 查询缓存组件</p>
<p>MySQL内部维持着一些<strong>Cache和Buffer</strong>，比如Query Cache用来缓存一条SELECT语句的执行结 果，<strong>如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</strong> </p>
<p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 </p>
<p>这个查询缓存可以在 <strong>不同客户端之间共享</strong> 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</p>
<h3 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a>第3层：引擎层</h3><p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<code>插件式的存储引擎</code>架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MysQL还允许<code>开发人员设置自己的存储引擎</code>。</p>
<p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况）的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p>
<p><strong>插件式存储引擎层</strong>（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取</strong>，对物理服务器级别 维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。 </p>
<p>MySQL 8.0.25默认支持的存储引擎如下：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210211.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123100149104"></p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 <strong>文件系统</strong> 上，以 <strong>文件</strong> 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210212.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123100313025"></p>
<p>简化为三层结构： </p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； </li>
<li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关； </li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><h3 id="MySQL中的SQL执行流程"><a href="#MySQL中的SQL执行流程" class="headerlink" title="MySQL中的SQL执行流程"></a>MySQL中的SQL执行流程</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210213.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123100934027"></p>
<p>MySQL的查询流程：</p>
<p>1、查询缓存：</p>
<p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能。 </p>
<p>大多数情况查询缓存就是个鸡肋，为什么呢？ </p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> employee_id,last_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> employee_id = <span class="hljs-number">101</span>;<br></code></pre></td></tr></table></figure>

<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，<code>不是缓存查询计划，而是查询对应的结果。</code>这就意味着查询匹配的 <code>鲁棒性大大降 低 </code>，只有 <code>相同的查询操作</code>才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、 大小写），都会<code>导致缓存不会命中</code>。因此 MySQL 的 查询缓存命中率不高 。 </p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数 举例，<code>可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW</code> ，每次调用都会产生最新的当前 时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的！ </p>
<p>此外，既然是缓存，那就有它 <code>缓存失效的时候</code> 。MySQL的缓存系统会监测涉及到的每张表，只要该表的 结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高 速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。</p>
<p>2、解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210214.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101152349"></p>
<p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> department_id,job_id,<span class="hljs-keyword">avg</span>(salary) <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> department_id;<br></code></pre></td></tr></table></figure>

<p>如果SQL语句正确，则会生成一个这样的语法树：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210215.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101255802"></p>
<p>3、优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。 </p>
<p>举例：如下语句是执行两个表的 join：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test1 <span class="hljs-keyword">join</span> test2 <span class="hljs-keyword">using</span>(ID)<br><span class="hljs-keyword">where</span> test1.name=<span class="hljs-string">&#x27;zhangwei&#x27;</span> <span class="hljs-keyword">and</span> test2.name=<span class="hljs-string">&#x27;mysql高级课程&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>方案1：可以先从表 test1 里面取出 name=’zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 ‘mysql高级课程’。 </p>
<p>方案2：可以先从表 test2 里面取出 name=’mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。 </p>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化 器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 </p>
<p>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p>
<p>在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210216.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121091908948"></p>
<p>4、执行器： </p>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210217.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101409028"></p>
<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；<br><br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br><br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。<br></code></pre></td></tr></table></figure>



<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。 SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210218.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101456214"></p>
<h3 id="MySQL8中SQL执行原理"><a href="#MySQL8中SQL执行原理" class="headerlink" title="MySQL8中SQL执行原理"></a>MySQL8中SQL执行原理</h3><p>前面的结构图很复杂，我们需要抓取最核心的部分: SQL的执行原理。不同的DBMS的sQL的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条SQL语句会经历不同的模块，那我们就来看下，在不同的模块中，SQL执行所使用的资源（时间)是怎样的。如何在 MysQL中对一条sQL语句的执行时间进行分析。</p>
<p>了解查询语句底层执行的过程: <code>select @@profiling;</code> 或者 <code>show variables like ‘%profiling%&#39;</code> 查看是否开启计划。开启它可以让MySQL收集在SQL执行时所使用的资源情况，命令如下:</p>
<p>1、确认profiling 是否开启</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@profiling</span>; <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;profiling&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210219.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101555370"></p>
<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>2、多次执行相同SQL查询 </p>
<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employees;<br></code></pre></td></tr></table></figure>

<p>3、查看profiles </p>
<p>查看当前会话所产生的所有 profiles：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">mysql&gt; <span class="hljs-keyword">show</span> profiles; <span class="hljs-meta"># 显示最近的几次查询</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210220.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101707949"></p>
<p>4、查看profile</p>
<p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210221.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101731882"></p>
<p>当然你也可以查询指定的 Query ID，比如： </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">mysql&gt; <span class="hljs-keyword">show </span>profile<span class="hljs-comment">; mysql&gt; show profile for query 7;</span><br></code></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。 </p>
<p>此外，还可以查询更丰富的内容： </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210222.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101814969"></p>
<p>继续：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mysql&gt; <span class="hljs-built_in">show</span> profile cpu,<span class="hljs-built_in">block</span> io <span class="hljs-keyword">for</span> query <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210223.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123101830053"></p>
<h3 id="MySQL5-7中SQL执行原理"><a href="#MySQL5-7中SQL执行原理" class="headerlink" title="MySQL5.7中SQL执行原理"></a>MySQL5.7中SQL执行原理</h3><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用 缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置： </p>
<p>1、配置文件中开启查询缓存 </p>
<p>在 /etc/my.cnf 中新增一行：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>重启mysql服务 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart mysqld</span><br></code></pre></td></tr></table></figure>

<p>3、开启查询执行计划 </p>
<p>由于重启过服务，需要重新执行如下指令，开启profiling。 </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-built_in">set</span> <span class="hljs-attribute">profiling</span>=1;<br></code></pre></td></tr></table></figure>

<p>4、执行语句两次： </p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> locations;<br></code></pre></td></tr></table></figure>

<p>5、查看profiles</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210224.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102149177"></p>
<p>6、查看profile </p>
<p>显示执行计划，查看程序的执行步骤：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210225.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102228217"></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysql&gt; show profile for query <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210226.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102256808"></p>
<p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中 获取数据。 </p>
<h3 id="SQL语法顺序"><a href="#SQL语法顺序" class="headerlink" title="SQL语法顺序"></a>SQL语法顺序</h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同 而动态调整执行顺序。 </p>
<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 下面是经常出现的查询顺序：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210227.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102323930"></p>
<h3 id="Oracle中的SQL执行流程-了解"><a href="#Oracle中的SQL执行流程-了解" class="headerlink" title="Oracle中的SQL执行流程(了解)"></a>Oracle中的SQL执行流程(了解)</h3><p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用 硬解析还是软解析。 </p>
<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210228.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102353539"></p>
<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。 </p>
<p>1.语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。 </p>
<p>2.语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统 就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。 </p>
<p>3.权限检查：看用户是否具备访问该数据的权限。</p>
<p>4.共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计 划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析 和硬解析又该怎么理解呢？ </p>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中 查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。 </p>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器” 这个步骤，这就是 硬解析 。 </p>
<p>5.优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。 </p>
<p>6.执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执 行语句了。</p>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要 缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对 象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。 </p>
<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量 避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。 </p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量 就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解 析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况 而定。 </p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br></code></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> player <span class="hljs-keyword">where</span> player_id <span class="hljs-operator">=</span> :player_id;<br></code></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变 量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。 </p>
<p>因此，我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点， 使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。 </p>
<p>Oracle的架构图：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210229.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102535032"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210230.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102542352"></p>
<p>小结： </p>
<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享 池来判断是进行软解析，还是硬解析。</p>
<h2 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池(buffer pool)"></a>数据库缓冲池(buffer pool)</h2><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访 问。 </p>
<p>这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="缓冲池-vs-查询缓存"><a href="#缓冲池-vs-查询缓存" class="headerlink" title="缓冲池 vs 查询缓存"></a>缓冲池 vs 查询缓存</h3><p>缓冲池和查询缓存是一个东西吗？不是。 </p>
<h4 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h4><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。 </p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种 数据的缓存，如下图所示：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210231.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102701116"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典 信息等。 </p>
<p><strong>缓存池的重要性：</strong> </p>
<p><strong>缓存原则：</strong> </p>
<p>“ 位置 * 频次 ”这个原则，可以帮我们对 I/O 访问效率进行优化。 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲 池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。 </p>
<p><strong>缓冲池的预读特性：</strong></p>
<p>了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<code>预读</code>。</p>
<p>缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<code>大概率还会使用它周围的一些数据</code>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p>
<p><strong>如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?</strong></p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<code>以一定的频率刷新</code>到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做<code>checkpoint</code>的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirty page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>那么什么是查询缓存呢？ </p>
<p>查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。 </p>
<h3 id="什么时候使用查询缓存"><a href="#什么时候使用查询缓存" class="headerlink" title="什么时候使用查询缓存"></a>什么时候使用查询缓存</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210232.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121090932464"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210233.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123103753070"></p>
<h3 id="缓冲池如何读取数据"><a href="#缓冲池如何读取数据" class="headerlink" title="缓冲池如何读取数据"></a>缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进 行读取。 </p>
<p>缓存在数据库中的结构和作用如下图所示：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210234.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102818823"></p>
<h3 id="查看-设置缓冲池的大小"><a href="#查看-设置缓冲池的大小" class="headerlink" title="查看/设置缓冲池的大小"></a>查看/设置缓冲池的大小</h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大 小。命令如下： </p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_size&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210235.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102902971"></p>
<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set global innodb_buffer_pool_size <span class="hljs-operator">=</span> <span class="hljs-number">268435456</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210236.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102927306"></p>
<p>或者： </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">268435456</span><br></code></pre></td></tr></table></figure>

<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210237.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123102947321"></p>
<h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>Buffer Pool本质是InnoDB向操作系统申请的一块<code>连续的内存空间</code>，在多线程环境下，访问Buffer Pool中的数据都需要<code>加锁</code>处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<code>拆分成若干个小的Buffer Pool</code>，每个Buffer Pool都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code>的值来修改Buffer Pool实例的个数，比方说这样:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_buffer_pool_instances</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p> 这样就表明我们要创建2个 Buffer Pool 实例。 </p>
<p>我们看下如何查看缓冲池的个数，使用命令：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;innodb_buffer_pool_instances&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210238.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123103042487"></p>
<p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<h3 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>
<p>黑盒下的更新数据流程</p>
<p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于BufferPool，同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MysQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MysQL宕机了，这部分数据将会永久地丢失;</p>
<p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办?连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复?</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210239.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123103120290"></p>
<h1 id="五、存储引擎"><a href="#五、存储引擎" class="headerlink" title="五、存储引擎"></a>五、存储引擎</h1><h2 id="存储引擎先关配置"><a href="#存储引擎先关配置" class="headerlink" title="存储引擎先关配置"></a>存储引擎先关配置</h2><p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为MysQL server的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。所以在MySQL server完成了<code>查询优化</code>后，只需按照生成的<code>执行计划</code>调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MySQL中提到了存储引擎的概念。简而言之，<code>存储引擎就是指表的类型</code>。其实存储引擎以前叫做<code>表处理器</code>，后来改名为存储引擎，它的功能就是<code>接收上层传下来的指令</code>，<code>然后对表中的数据进行提取或写入操作</code>。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><p>查看mysql提供什么存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show engines<span class="hljs-comment">;</span><br>show engines \G<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>引擎、是否支持、描述、事务、分布式事务、savepointer</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210240.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123104311188"></p>
<p>显式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: InnoDB<br>Support: DEFAULT<br>Comment: Supports transactions, row-level locking, and foreign keys<br>Transactions: YES<br>XA: YES<br>Savepoints: YES<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 2. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: MRG<span class="hljs-emphasis">_MYISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Collection of identical MyISAM tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 3. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MEMORY</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Hash based, stored in memory, useful for temporary tables</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 4. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: BLACKHOLE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: /dev/null storage engine (anything you write to it disappears)</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">2. 设置系统默认的存储引擎</span><br><span class="hljs-emphasis">查看默认的存储引擎：</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 5. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: MyISAM</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: MyISAM storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 6. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: CSV</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: CSV storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 7. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: ARCHIVE</span><br><span class="hljs-emphasis">Support: YES</span><br><span class="hljs-emphasis">Comment: Archive storage engine</span><br><span class="hljs-emphasis">Transactions: NO</span><br><span class="hljs-emphasis">XA: NO</span><br><span class="hljs-emphasis">Savepoints: NO</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 8. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span><br><span class="hljs-emphasis">Engine: PERFORMANCE_</span>SCHEMA<br>Support: YES<br>Comment: Performance Schema<br>Transactions: NO<br>XA: NO<br>Savepoints: NO<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 9. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Engine: FEDERATED<br>Support: NO<br>Comment: Federated MySQL storage engine<br>Transactions: NULL<br>XA: NULL<br>Savepoints: NULL<br></code></pre></td></tr></table></figure>

<h3 id="设置系统默认的存储引擎"><a href="#设置系统默认的存储引擎" class="headerlink" title="设置系统默认的存储引擎"></a>设置系统默认的存储引擎</h3><p>查看默认的存储引擎：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">show</span> variables like <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br><span class="hljs-comment">#或</span><br><span class="hljs-attribute">SELECT</span> @<span class="hljs-variable">@default_storage_engine</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210241.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123104407947"></p>
<p>修改默认的存储引擎 </p>
<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">DEFAULT_STORAGE_ENGINE</span>=MyISAM;<br></code></pre></td></tr></table></figure>

<p>或者修改 my.cnf 文件：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=MyISAM<br># 重启服务<br>systemctl <span class="hljs-keyword">restart</span> mysqld.service<br></code></pre></td></tr></table></figure>

<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式。 </p>
<h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CREATE TABLE 表名(<br>建表语句<span class="hljs-comment">;</span><br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h3><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎： </p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ALTER TABLE 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>比如我们修改一下 engine_demo_table 表的存储引擎： </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span> Duplicates: <span class="hljs-number">0</span> Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>这时我们再查看一下 engine_demo_table 的表结构：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">mysql&gt; SHOW CREATE TABLE engine<span class="hljs-emphasis">_demo_</span>table\G<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** 1. row **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>Table: engine<span class="hljs-emphasis">_demo_</span>table<br>Create Table: CREATE TABLE <span class="hljs-code">`engine_demo_table`</span> (<br><span class="hljs-code">`i`</span> int(11) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>

<h2 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h2><h3 id="InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>InnoDB 引擎：具备外键支持功能的事务存储引擎</h3><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 </p>
<p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务 的完整提交(Commit)和回滚(Rollback)。 </p>
<p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 </p>
<p>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） </p>
</li>
<li><p>表名.ibd 存储数据和索引 </p>
</li>
</ul>
<p>InnoDB是 为处理巨大数据量的最大性能设计 。 </p>
<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。 </li>
</ul>
<p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和 索引。 </p>
<p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p>
<h3 id="MyISAM-引擎：主要的非事务处理存储引擎"><a href="#MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="MyISAM 引擎：主要的非事务处理存储引擎"></a>MyISAM 引擎：主要的非事务处理存储引擎</h3><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 </p>
<p>5.5之前默认的存储引擎 </p>
<p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用 </p>
<p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 </p>
<p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构 </p>
</li>
<li><p>表名.MYD 存储数据 (MYData) </p>
</li>
<li><p>表名.MYI 存储索引 (MYIndex) </p>
</li>
</ul>
<p>应用场景：只读应用或者以读为主的业务</p>
<h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210242.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121102140263"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210243.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123105832462"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210244.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121102353775"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210245.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220121103116264"></p>
<h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p>
<p>其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功 能。 </p>
<p>其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存 储引擎。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210246.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123110038734"></p>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？ </p>
<p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210247.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123110144759"></p>
<h3 id="阿里巴巴、淘宝用哪个"><a href="#阿里巴巴、淘宝用哪个" class="headerlink" title=".阿里巴巴、淘宝用哪个"></a>.阿里巴巴、淘宝用哪个</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210248.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123110239707"></p>
<p>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。 </p>
<p>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外 有更多的参数和命令来控制服务器行为。 </p>
<p>该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好 </p>
<p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p>
<h2 id="课外补充："><a href="#课外补充：" class="headerlink" title="课外补充："></a>课外补充：</h2><h3 id="1、InnoDB表的优势"><a href="#1、InnoDB表的优势" class="headerlink" title="1、InnoDB表的优势"></a>1、InnoDB表的优势</h3><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如<code>操作便利、提高了数据库的性能、维护成本低</code>等。如 果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。<code>InnoDB崩溃 恢复功能</code>自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。 </p>
<p>InnoDB存储引擎在主内存中<code>维护缓冲池</code>，高频率使用的数据将在内存中直接被处理。这种缓存方式应用 于多种信息，加速了处理进程。 </p>
<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以 设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插 入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃， 在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被 自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 <code>InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘</code> 。 </p>
<p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高 查询的速度。使用InnoDB可以压缩表和相关的索引，可以 <code>在不影响性能和可用性的情况下创建或删除索 引 </code>。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他 存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 <code>当处理大数据量时， InnoDB兼顾CPU，以达到最大性能</code> 。 </p>
<h3 id="2、InnoDB和ACID模型"><a href="#2、InnoDB和ACID模型" class="headerlink" title="2、InnoDB和ACID模型"></a>2、InnoDB和ACID模型</h3><p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应 用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不 会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的 软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只 依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p>
<p>1、原子方面 </p>
<p>ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>COMMIT语句。 </p>
<p>ROLLBACK语句。 </p>
<p>操作INFORMATION_SCHEMA库中的表数据。 </p>
<p>2、一致性方面 </p>
<p>ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性 主要包括： </p>
<p>InnoDB双写缓存。 </p>
<p>InnoDB崩溃恢复。 </p>
<p>3、隔离方面 </p>
<p>隔离是应用于事务的级别，与MySQL相关的特性主要包括： </p>
<p>自动提交设置。 </p>
<p>SET ISOLATION LEVEL语句。 </p>
<p>InnoDB锁的低级别信息。 </p>
<p>4、耐久性方面 </p>
<p>ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样 化，耐久性方面没有具体的规则可循。与MySQL相关的特性有： </p>
<p>InnoDB双写缓存，通过innodb_doublewrite配置项配置。 </p>
<p>配置项innodb_flush_log_at_trx_commit。 </p>
<p>配置项sync_binlog。 </p>
<p>配置项innodb_file_per_table。 </p>
<p>存储设备的写入缓存。 </p>
<p>存储设备的备用电池缓存。 </p>
<p>运行MySQL的操作系统。 </p>
<p>持续的电力供应。 </p>
<p>备份策略。 </p>
<p>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</p>
<h3 id="3、InnoDB架构"><a href="#3、InnoDB架构" class="headerlink" title="3、InnoDB架构"></a>3、InnoDB架构</h3><p><strong>1.缓冲池</strong> </p>
<p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的 数据能够直接在内存中获得，从而提高速度。 </p>
<p><strong>2.更改缓存</strong> </p>
<p>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索 引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索 引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。 在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管 理。 </p>
<p><strong>3.自适应哈希索引</strong></p>
<p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行， 不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。 </p>
<p><strong>4.重做日志缓存</strong> </p>
<p>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。 </p>
<p><strong>5.系统表空间</strong> </p>
<p>系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引 数据。多表共享，系统表空间被视为共享表空间。 </p>
<p><strong>6.双写缓存</strong></p>
<p>双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存 后，InnoDB才会将数据页写入合适的位置。 </p>
<p><strong>7.撤销日志</strong> </p>
<p>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他 事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这 些片段包含于回滚片段中。 </p>
<p><strong>8.每个表一个文件的表空间</strong> </p>
<p>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数 据文件代表，该文件默认被创建在数据库目录中。 </p>
<p><strong>9.通用表空间</strong> </p>
<p>使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数 据目录之外能够管理多个表并支持所有行格式的表。 </p>
<p><strong>10.撤销表空间</strong> </p>
<p>撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces配置项配置。 </p>
<p><strong>11.临时表空间</strong></p>
<p>用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。 </p>
<p><strong>12.重做日志</strong></p>
<p>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自 动在初始化期间重新进行。</p>
<h1 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h1><h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找相关数据</code>，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个<code>索引的数据结构</code>，即这个二叉搜索树。二叉搜索树的每个结点存储的是<code>（K，V) 结构</code>，key是Col2，value是该<code>key 所在行的文件指针(地址)</code>。比如：该二叉搜索树的根节点就是（34，0x07）。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34；继续右侧数据，读89到内存，89 == 89；找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了<code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210249.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123195051911"></p>
<p><code>索引是在存储引擎中实现的</code>，因此<code>每种存储引擎的索引不一定完全相同</code>，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。所有存储引擎支持每个表<code>至少16个索引</code>，总索引长度<code>至少为256字节</code>。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<p>提示：</p>
<p>索引可以提高查询的速度，但是<code>会影响插入记录的速度</code>。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
<h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong> </p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。 </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主 要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<p> （1）创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加。</p>
<p> （2）索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 </p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<h2 id="Innode中的索引"><a href="#Innode中的索引" class="headerlink" title="Innode中的索引"></a>Innode中的索引</h2><h3 id="目录项记录页的目录页"><a href="#目录项记录页的目录页" class="headerlink" title="目录项记录页的目录页"></a>目录项记录页的目录页</h3><p>树的层次越低，加载的 页越少（页读取到内存之后，使用二分进一步查找），IO次数越少</p>
<p>一个数据页，默认 16kb</p>
<p>B+ 树：叶子节点之间用双向链表，非叶子节点之间单向链表</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210250.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123195650125"></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么： </p>
<p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。 </p>
<p>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 </p>
<p>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记 录！！！ </p>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们 通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又 因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。</p>
<h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。 </p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>（所有的用户记录都存储在了叶子节点)，也就是所谓的<code>索引即数据，数据即索引</code>。</p>
<p>术语”聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内 的记录是按照主键的大小顺序排成一个 单向链表 。 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MysQL语句中显式的使用INDEX语句去创建，<code>InnoDB</code>存储引擎会<code>自动</code>的为我们创建聚簇索引。</p>
<p><strong>特点：</strong> </p>
<p>1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<p>页内 的记录是按照主键的大小顺序排成一个 单向链表 。 </p>
<p>各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 </p>
<p>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。 </p>
<p>2、B+树的 叶子节点 存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p>
<p><strong>优点：</strong> </p>
<p>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 </p>
<p>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 </p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。 </p>
<p><strong>缺点：</strong> </p>
<p>1、插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 </p>
<p>2、更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新 </p>
<p>3、二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据 </p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<p><strong>限制：</strong></p>
<p>1、对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。</p>
<p>2、由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>3、如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。|</p>
<p>4、为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
<h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><blockquote>
<p>二级索引：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。</p>
</blockquote>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210251.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123091747335"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210252.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123091441479"></p>
<p><strong>概念：回表</strong> </p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！ </p>
<p><strong>问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</strong></p>
<p><strong>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</strong></p>
<p>1、聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</p>
<p>2、一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</p>
<p>3、使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<p>1、先把各个记录和页按照c2列进行排序。 </p>
<p>2、在记录的c2列相同的情况下，采用c3列进行排序</p>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p>
<p>1、建立 联合索引 只会建立如上图一样的1棵B+树。 </p>
<p>2、为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210253.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123094039750"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210254.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123094343764"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210255.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123094446434"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210256.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123094744274"></p>
<h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根页面位置万年不动"><a href="#根页面位置万年不动" class="headerlink" title="根页面位置万年不动"></a>根页面位置万年不动</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210257.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202403635"></p>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210258.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202445109"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210259.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202455155"></p>
<h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210300.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202415852"></p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>B树索引适用存储引擎如表所示： </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210301.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202552912"></p>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。</p>
<p>Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。 </p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，<strong>叶子节点的data域存放的是 数据记录的地址 。</strong></p>
<h3 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210302.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202626492"></p>
<p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210303.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123202831722"></p>
<h3 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区 别：</strong> </p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。 </p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。 </p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。 </p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： </p>
<p><strong>空间上的代价</strong> </p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。 </p>
<p><strong>时间上的代价</strong> </p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h2><p>从MysQL的角度讲，不得不考虑一个现实问题就是磁盘I0。如果我们能让索引的数据结构尽量<code>减少硬盘的I/O操作</code>，所消耗的时间也就越小。可以说，磁盘的I/O操作次数对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘上的。</strong>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MysQL衡量查询效率的标准就是磁盘I/O次数。</p>
<h3 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h3><p>略</p>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210304.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123203956171"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210305.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204007505"></p>
<h3 id="自适应式哈希"><a href="#自适应式哈希" class="headerlink" title="自适应式哈希"></a>自适应式哈希</h3><p>InnoDB会监控对表上各索引页的查询，如果观察该数据被访问的频次符合规则，那么就建立哈希索引来加快数据访问的速度，这个哈希索引称之为”<strong>Adaptive Hash Index,AHI</strong>“,AHI是通过缓冲池的B+树页构建的，建立的速度很快，而且不对整颗树都建立哈希索引。(可以理解成热点的数据才会进入这个哈希表)</p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。 </p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如： </p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">mysql&gt; show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%adaptive_hash_index&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210306.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123203315740"></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210307.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204105287"></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210308.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204147288"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210309.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204206739"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210310.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204216682"></p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210311.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204230149"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210312.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204313188"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210313.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204325576"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210314.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204335710"></p>
<h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210315.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204353865"></p>
<h2 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h2><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210316.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123204424866"></p>
<h1 id="七、InnoDB数据存储结构"><a href="#七、InnoDB数据存储结构" class="headerlink" title="七、InnoDB数据存储结构"></a>七、InnoDB数据存储结构</h1><h2 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p>
<h3 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210317.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123171731077"></p>
<h3 id="页结构概述-页的大小"><a href="#页结构概述-页的大小" class="headerlink" title="页结构概述/页的大小"></a>页结构概述/页的大小</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210318.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123171810345"></p>
<h3 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210319.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123171900691"></p>
<h2 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h2><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210320.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123171932421"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210321.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172018972"></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="FileHeader（文件头部）"><a href="#FileHeader（文件头部）" class="headerlink" title="FileHeader（文件头部）"></a>FileHeader（文件头部）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210322.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172224825"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210323.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172540410"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210324.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172556371"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210325.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172609036"></p>
<h4 id="File-Trailer（文件尾部）"><a href="#File-Trailer（文件尾部）" class="headerlink" title="File Trailer（文件尾部）"></a>File Trailer（文件尾部）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210326.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172719823"></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210327.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172831136"></p>
<h4 id="FreeSpace（空闲空间）"><a href="#FreeSpace（空闲空间）" class="headerlink" title="FreeSpace（空闲空间）"></a>FreeSpace（空闲空间）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210328.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172859640"></p>
<h4 id="UserRecords（用户记录）"><a href="#UserRecords（用户记录）" class="headerlink" title="UserRecords（用户记录）"></a>UserRecords（用户记录）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210329.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172911774"></p>
<h4 id="Infimum-Supremum（最小最大记录）"><a href="#Infimum-Supremum（最小最大记录）" class="headerlink" title="Infimum+Supremum（最小最大记录）"></a>Infimum+Supremum（最小最大记录）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210330.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123172946473"></p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><h4 id="PageDirectory（页目录）"><a href="#PageDirectory（页目录）" class="headerlink" title="PageDirectory（页目录）"></a>PageDirectory（页目录）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210331.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173407883"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210332.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173452062"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210333.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173512149"></p>
<h5 id="页目录分组的个数如何确定"><a href="#页目录分组的个数如何确定" class="headerlink" title="页目录分组的个数如何确定?"></a>页目录分组的个数如何确定?</h5><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210334.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173533141"></p>
<h5 id="页目录结构下如何快速查找记录"><a href="#页目录结构下如何快速查找记录" class="headerlink" title="页目录结构下如何快速查找记录?"></a>页目录结构下如何快速查找记录?</h5><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210335.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173658766"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210336.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173707547"></p>
<h4 id="PageHeader（页面头部）"><a href="#PageHeader（页面头部）" class="headerlink" title="PageHeader（页面头部）"></a>PageHeader（页面头部）</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210337.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173858788"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210338.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123173940900"></p>
<h2 id="InnoDB行格式（或记录格式）"><a href="#InnoDB行格式（或记录格式）" class="headerlink" title="InnoDB行格式（或记录格式）"></a>InnoDB行格式（或记录格式）</h2><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210339.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220123174014918"></p>
<h1 id="八、索引的创建与设计原则"><a href="#八、索引的创建与设计原则" class="headerlink" title="八、索引的创建与设计原则"></a>八、索引的创建与设计原则</h1><h2 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a>索引的声明与使用</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 </p>
<p>从 <code>功能逻辑</code> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p>
<p>按照 <code>物理实现方式</code> ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p>
<p>按照 <code>作用字段个数</code> 进行划分，分成单列索引和联合索引。</p>
<p>1.普通索引</p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表<br>student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p>2.唯一性索引</p>
<p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯—量可以更快速地确定某条记录。</p>
<p>3.主键索引</p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE 一张表里最多只有一个主键索引。</p>
<p>Why?这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p>4.单列索引</p>
<p>在表中的单个字段上创建索引。单列索引央根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<p>5.多列(组合、联合)索引</p>
<p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<p>6.全文索引</p>
<p>全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。</p>
<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、ElasticSearch等专门的搜索引擎所替代。</p>
<p>7.补充：空间索引</p>
<p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p>小结：不同的存储引擎支持的索引类型也不一样</p>
<p>nnoDB：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>MylSAM：支持B-tree、Full-text等索引，不支持Hash索引;</p>
<p>Memory：支持B-tree、Hash等索引，不支持Full-text索引;</p>
<p>NDB：支持Hash索引，不支持 B-tree、Full-text等索引;</p>
<p>Archive：不支持B-tree、Hash、Full-text等索引;</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span>,<br>dept_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> emp_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY(dept_id) <span class="hljs-keyword">REFERENCES</span> dept(dept_id)<br>);<br></code></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name [col_name data_type]<br>[<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY] [index_name] (col_name [length]) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span><br><span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </p>
<p>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </p>
<p>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </p>
<p>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </p>
<p>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </p>
<p>ASC 或 DESC 指定升序或者降序的索引值存储。 </p>
<h5 id="1-创建普通索引"><a href="#1-创建普通索引" class="headerlink" title="1.创建普通索引"></a>1.创建普通索引</h5><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> book(<br>book_id <span class="hljs-type">INT</span> ,<br>book_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>authors <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) ,<br>comment <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>year_publication <span class="hljs-keyword">YEAR</span>,<br>INDEX(year_publication)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="2-创建唯一索引"><a href="#2-创建唯一索引" class="headerlink" title="2.创建唯一索引"></a>2.创建唯一索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test1(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX uk_idx_id(id)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> test1 \G<br></code></pre></td></tr></table></figure>

<h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法： </p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT ,<br>student_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>student_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY(id)<br>);<br></code></pre></td></tr></table></figure>

<p>删除主键索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">PRIMARY</span> KEY ;<br></code></pre></td></tr></table></figure>

<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引 </p>
<h5 id="4-创建单列索引"><a href="#4-创建单列索引" class="headerlink" title="4.创建单列索引"></a>4.创建单列索引</h5><p>举例： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test2(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span>,<br>INDEX single_idx_name(name(<span class="hljs-number">20</span>))<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test2 \G<br></code></pre></td></tr></table></figure>

<h5 id="5-创建组合索引"><a href="#5-创建组合索引" class="headerlink" title="5.创建组合索引"></a>5.创建组合索引</h5><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test3(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>INDEX multi_idx(id,name,age)<br>);<br></code></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW INDEX 查看： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> test3 \G<br></code></pre></td></tr></table></figure>

<h5 id="6-创建全文索引"><a href="#6-创建全文索引" class="headerlink" title="6.创建全文索引"></a>6.创建全文索引</h5><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test4(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">CHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>FULLTEXT INDEX futxt_idx_info(info)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
<p>举例2： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> articles (<br>id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>title <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">200</span>),<br>body TEXT,<br>FULLTEXT index (title, body)<br>) ENGINE <span class="hljs-operator">=</span> INNODB ;<br></code></pre></td></tr></table></figure>

<p>创建了一个给title和body字段添加全文索引的表。 </p>
<p>举例3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `papers` (<br>`id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`title` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>FULLTEXT KEY `title` (`title`,`content`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure>

<p>不同于like方式的的查询： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> content <span class="hljs-keyword">LIKE</span> ‘<span class="hljs-operator">%</span>查询字符串<span class="hljs-operator">%</span>’;<br></code></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> papers <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);<br></code></pre></td></tr></table></figure>

<p><strong>注意点</strong> </p>
<p>1.使用全文索引前，搞清楚版本支持情况； </p>
<p>2.全文索引比 like + % 快 N 倍，但是可能存在精度问题； </p>
<p>3.如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</p>
<h5 id="7-创建空间索引"><a href="#7-创建空间索引" class="headerlink" title="7.创建空间索引"></a>7.创建空间索引</h5><p>空间索引创建中，要求空间类型的字段必须为 <code>非空 </code>。 </p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test5(<br>geo GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>SPATIAL INDEX spa_idx_geo(geo)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>

<h4 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。 </p>
<p><strong>1.使用ALTER TABLE语句创建索引</strong> </p>
<p>ALTER TABLE语句创建索引的基本语法如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY]<br>[index_name] (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<p><strong>2.使用CREATE INDEX创建索引</strong> </p>
<p>CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><strong>1.使用ALTER TABLE删除索引</strong> </p>
<p>ALTER TABLE删除索引的基本语法格式如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure>

<p><strong>2.使用DROP INDEX语句删除索引</strong> </p>
<p>DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>

<p>提示：</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成 索引的所有列都被删除，则整个索引将被删除。</p>
<h2 id="MySQL8索引新特性"><a href="#MySQL8索引新特性" class="headerlink" title="MySQL8索引新特性"></a>MySQL8索引新特性</h2><h3 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h3><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ts1(a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span>,index idx_a_b(a,b <span class="hljs-keyword">desc</span>));<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210340.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220124093009807"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210341.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220124093056738"></p>
<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。 </p>
<blockquote>
<p>提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员 可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。 </p>
</blockquote>
<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用 Using filesort。 </p>
<blockquote>
<p>注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述 查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。 </p>
</blockquote>
<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本 中查看数据表ts1的执行计划，结果如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ts1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a <span class="hljs-keyword">DESC</span>,b <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>在MySQL 8.0版本中查看数据表ts1的执行计划。 </p>
<p>从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210342.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220124092321533"></p>
<h1 id="十三、事务基础知识"><a href="#十三、事务基础知识" class="headerlink" title="十三、事务基础知识"></a>十三、事务基础知识</h1><h2 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持<code>一致性</code>，同时我们还能通过事务的机制<code>恢复到某个时间点</code>，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h3 id="存储引擎支持情况"><a href="#存储引擎支持情况" class="headerlink" title="存储引擎支持情况"></a>存储引擎支持情况</h3><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。 </p>
<p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210343.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125165016772"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。 </p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210344.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125165049411"></p>
<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><h4 id="原子性（atomicity）："><a href="#原子性（atomicity）：" class="headerlink" title="原子性（atomicity）："></a>原子性（atomicity）：</h4><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 </p>
<h4 id="一致性（consistency）："><a href="#一致性（consistency）：" class="headerlink" title="一致性（consistency）："></a>一致性（consistency）：</h4><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述） </p>
<p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态 是 语义上 的而不是语法上的，跟具体的业务有关。 </p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己 来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。 </p>
<p>举例1：A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;=0。</p>
<p>举例2：A账户2o0元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。</p>
<p>举例3：在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</p>
<h4 id="隔离型（isolation）："><a href="#隔离型（isolation）：" class="headerlink" title="隔离型（isolation）："></a>隔离型（isolation）：</h4><p>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 </p>
<p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210345.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125165436801"></p>
<h4 id="持久性（durability）："><a href="#持久性（durability）：" class="headerlink" title="持久性（durability）："></a>持久性（durability）：</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。 </p>
<p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 事务 大致划分成几个状态： </p>
<h4 id="活动的（active）"><a href="#活动的（active）" class="headerlink" title="活动的（active）"></a>活动的（active）</h4><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。 </p>
<h4 id="部分提交的（partially-committed）"><a href="#部分提交的（partially-committed）" class="headerlink" title="部分提交的（partially committed）"></a>部分提交的（partially committed）</h4><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘 时，我们就说该事务处在 部分提交的 状态。 </p>
<h4 id="失败的（failed）"><a href="#失败的（failed）" class="headerlink" title="失败的（failed）"></a>失败的（failed）</h4><p>当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。 </p>
<h4 id="中止的（aborted）"><a href="#中止的（aborted）" class="headerlink" title="中止的（aborted）"></a>中止的（aborted）</h4><p>如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称 之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 中止的 状态。 </p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money - <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;AA&#x27;</span>;<br>UPDATE accounts <span class="hljs-type">SET</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> money + <span class="hljs-number">50</span> <span class="hljs-type">WHERE</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BB&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="提交的（committed）"><a href="#提交的（committed）" class="headerlink" title="提交的（committed）"></a>提交的（committed）</h4><p>当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处 在了 提交的 状态。 一个基本的状态转换图如下所示：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210346.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125165704463"></p>
<h2 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h2><p>使用事务有两种方式，分别为 <code>显式事务</code> 和<code> 隐式事务</code> 。 </p>
<h3 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h3><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>#或者<br>mysql&gt; START TRANSACTION;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>后面可以跟: <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span> / <span class="hljs-keyword">read</span> <span class="hljs-keyword">write</span>(默认) / <span class="hljs-keyword">with</span> consistent <span class="hljs-keyword">snapshot</span><br></code></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：</p>
<p>① READ ONLY ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不 能修改数据。 </p>
<p>② READ WRITE ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。 </p>
<p>③ WITH CONSISTENT SNAPSHOT ：启动一致性读。 </p>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL） </p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 回滚事务。即撤销正在进行的所有没有提交的修改<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br># 将事务回滚到某个保存点。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> [<span class="hljs-keyword">SAVEPOINT</span>]<br></code></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。<br><span class="hljs-keyword">SAVEPOINT</span> 保存点名称;<br><br># 删除某个保存点。<br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名称:<br></code></pre></td></tr></table></figure>



<h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>每条DML语句都是一条独立的事务。</p>
<p>针对于DML操作是有效的，对DDL操作是无效的。</p>
<p>关闭了自动提交之后，写语句要自己 commit，否则会<code>锁表</code></p>
<p>MySQL中有一个系统变量 autocommit ： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> autocommit <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种 自动提交 的功能，可以使用下边两种方法之一： </p>
<p>显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回 滚前会暂时关闭掉自动提交的功能。 </p>
<p>把系统变量 autocommit 的值设置为 OFF ，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> OFF;<br>#或<br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210347.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125172112442"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210348.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125172120904"></p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。 </p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个<code>会话（ Session ）</code>。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理 多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影响太大 ，我们既想保持 事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取 舍了。</p>
<h3 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题： </p>
<p><strong>脏写（ Dirty Write ）</strong> </p>
<p>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数 据，那就意味着发生了 脏写</p>
<p><strong>脏读（ Dirty Read ）</strong></p>
<p>对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。 之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。 </p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象 就称之为 脏读 。 </p>
<p><strong>不可重复读（ Non-Repeatable Read ）</strong> </p>
<p>对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后 Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。 </p>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看 到最新的值，这种现象也被称之为 不可重复读 。 </p>
<p><strong>幻读（ Phantom ）</strong> </p>
<p>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。 </p>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 幻影记录 。</p>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序： </p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并 发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ： </p>
<p>READ UNCOMMITTED ：</p>
<p>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。 </p>
<p>READ COMMITTED ：</p>
<p>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。 </p>
<p>REPEATABLE READ ：</p>
<p>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。 </p>
<p>SERIALIZABLE ：</p>
<p>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。 </p>
<p>SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210349.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125173629691"></p>
<p>脏写 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。 不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210350.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125173641123"></p>
<h3 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h3><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本之前：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;tx_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-operator">|</span> tx_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br># MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation<br><br># 查看隔离级别，MySQL <span class="hljs-number">5.7</span><span class="hljs-number">.20</span>的版本及之后：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;transaction_isolation&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-operator">|</span> transaction_isolation <span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+-----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.02</span> sec)<br><br>#或者不同MySQL版本中都可以使用的：<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><br></code></pre></td></tr></table></figure>

<h3 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h3><p><strong>通过下面的语句修改事务的隔离级别：</strong> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;<br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>或者： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;隔离级别&#x27;</span><br>#其中，隔离级别格式：<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>UNCOMMITTED<br><span class="hljs-operator">&gt;</span> READ<span class="hljs-operator">-</span>COMMITTED<br><span class="hljs-operator">&gt;</span> REPEATABLE<span class="hljs-operator">-</span>READ<br><span class="hljs-operator">&gt;</span> SERIALIZABLE<br></code></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响： </p>
<p>使用 GLOBAL 关键字（在全局范围影响）： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>当前已经存在的会话无效 </p>
</li>
<li><p>只对执行完该语句之后产生的会话起作用 </p>
</li>
</ul>
<p>使用 SESSION 关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>#或<br><span class="hljs-keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>则： </p>
<ul>
<li><p>对当前会话的所有后续的事务有效 </p>
</li>
<li><p>如果在事务之间执行，则对后续的事务有效 </p>
</li>
<li><p>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</p>
</li>
</ul>
<blockquote>
<p>小结： </p>
<p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性 就越好，但并发性越弱。</p>
</blockquote>
<h2 id="事务的常见分类"><a href="#事务的常见分类" class="headerlink" title="事务的常见分类"></a>事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型： </p>
<p>扁平事务（Flat Transactions） </p>
<p>带有保存点的扁平事务（Flat Transactions with Savepoints） </p>
<p>链事务（Chained Transactions） </p>
<p>嵌套事务（Nested Transactions） </p>
<p>分布式事务（Distributed Transactions）</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210351.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125174041369"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210352.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220125174109035"></p>
<h1 id="十四、MySQL事务日志"><a href="#十四、MySQL事务日志" class="headerlink" title="十四、MySQL事务日志"></a>十四、MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？ </p>
<p>事务的隔离性由 <code>锁机制</code> 实现。 </p>
<p>而事务的原子性、一致性和持久性由<code>事务的 redo 日志</code>和<code>undo 日志</code>来保证。 </p>
<p>REDO LOG 称为 <code>重做日志</code> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。 </p>
<p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。 </p>
<p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。</p>
<table>
<thead>
<tr>
<th></th>
<th>undo日志</th>
<th>redo日志</th>
</tr>
</thead>
<tbody><tr>
<td>用来保证</td>
<td>持久性</td>
<td>原子性、一致性</td>
</tr>
<tr>
<td>记录的是</td>
<td>物理级别上页的修改操作</td>
<td>逻辑日志</td>
</tr>
<tr>
<td>主要作用</td>
<td>保证数据的可靠性</td>
<td>事务回滚、MVCC</td>
</tr>
<tr>
<td>产生位置</td>
<td>存储引擎层</td>
<td>数据库层</td>
</tr>
<tr>
<td>产生时机</td>
<td>事务执行过程中</td>
<td>事务提交时</td>
</tr>
<tr>
<td>组成部分</td>
<td>redo log buffer 、redo log file</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到<code>内存中的Buffer Pool</code>之后才可以访问。所有的变更都必须先<code>更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘（ <code>checkPoint机制</code>），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h3 id="为什么需要REDO日志"><a href="#为什么需要REDO日志" class="headerlink" title="为什么需要REDO日志"></a>为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发 </code>的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。 </p>
<p>另一方面，事务包含 <code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩 溃，这个事务对数据库中所做的更改也不能丢失。 </p>
<p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题：</p>
<p>1、修改量与刷新磁盘工作量严重不成比例</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在innoDB中是以页为单位来进行磁盘lo的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</p>
<p>2、随机IO刷新较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机Io比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
<p><code>另一个解决的思路 ：</code>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2 。</p>
<p>InnoDB引擎的事务采用了WAL技术(（Write-Ahead Logging )，这种技术的思想就是<code>先写日志，再写磁盘</code>，<code>只有日志写入成功，才算事务提交成功</code>，这里的日志就是<code>redo log</code>。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210353.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126163216220"></p>
<h3 id="REDO日志的好处、特点"><a href="#REDO日志的好处、特点" class="headerlink" title="REDO日志的好处、特点"></a>REDO日志的好处、特点</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>redo日志降低了刷盘频率 </p>
<p>redo日志占用的空间非常小</p>
<ul>
<li>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>redo日志是顺序写入磁盘的</strong></p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快。</p>
<p><strong>事务执行过程中，redo log不断记录</strong></p>
<p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<h3 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h3><p>Redo log可以简单分为以下两个部分： </p>
<p>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。 </p>
<p>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210354.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164106278"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210355.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164116794"></p>
<h3 id="redo的整体流程"><a href="#redo的整体流程" class="headerlink" title="redo的整体流程"></a>redo的整体流程</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210356.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164250628"></p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<h3 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一 定的频率 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210357.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164334492"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存 （page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系 统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。 </p>
<p>针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略： </p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） </p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210358.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164459943"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210359.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164511633"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210400.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164523067"></p>
<h3 id="不同刷盘策略演示"><a href="#不同刷盘策略演示" class="headerlink" title="不同刷盘策略演示"></a>不同刷盘策略演示</h3><p>流程图</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210401.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164550158"></p>
<p>小结: innodb_flush_log_at_trx_commit=1</p>
<p>为1时,只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失,但是<code>效率最差</code>的。</p>
<p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210402.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164557233"></p>
<p>小结：innodb_flush_log_at_trx_commit=2</p>
<p>为2时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存（page cache )。</p>
<p>如果仅仅只是MySQL挂了不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210403.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164603143"></p>
<p>小结: innodb_flush_log_at_trx_commit=0</p>
<p>为0时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p>
<p>数值o的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，也无法保证D。</p>
<h3 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h3><h4 id="补充概念：Mini-Transaction"><a href="#补充概念：Mini-Transaction" class="headerlink" title="补充概念：Mini-Transaction"></a>补充概念：Mini-Transaction</h4><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210404.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164811826"></p>
<h4 id="redo-日志写入log-buffer"><a href="#redo-日志写入log-buffer" class="headerlink" title="redo 日志写入log buffer"></a>redo 日志写入log buffer</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210405.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164841075"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210406.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164849968"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210407.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126164900488"></p>
<h4 id="redo-log-block的结构图"><a href="#redo-log-block的结构图" class="headerlink" title="redo log block的结构图"></a>redo log block的结构图</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210408.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165004100"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210409.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165019180"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210410.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165025786"></p>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><h4 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210411.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165107986"></p>
<h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210412.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165125652"></p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210413.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165156959"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210414.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165204252"></p>
<h3 id="redolog小结"><a href="#redolog小结" class="headerlink" title="redolog小结"></a>redolog小结</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210415.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165229526"></p>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要 先写入一个 undo log 。 </p>
<h3 id="如何理解undo日志"><a href="#如何理解undo日志" class="headerlink" title="如何理解undo日志"></a>如何理解undo日志</h3><p>事务需要保证 原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半 会出现一些情况，比如： </p>
<p>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突 然 断电 导致的错误。 </p>
<p>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行。 以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 回滚 ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 原子性 要求。</p>
<p>每当我们要对一条记录做<code>改动</code>时(这里的改动可以指INSERT、DELETE、UPDATE)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p>
<p>你<code>插入一条记录时</code>，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</p>
<p>你<code>删除了一条记录</code>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</p>
<p>你<code>修改了一条记录</code>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,I将修改前的行放回去)</p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即undo log )。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log 会<code>产生 redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h3 id="undo日志的作用"><a href="#undo日志的作用" class="headerlink" title="undo日志的作用"></a>undo日志的作用</h3><p><strong>作用1：回滚数据</strong></p>
<p>用户对undo日志可能<code>有误解</code>：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p><strong>作用2: MVCC</strong></p>
<p>undo的另一个作用是MVcd，即在InnoDB存储引擎中MVcc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
<h3 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h3><h4 id="回滚段与undo页"><a href="#回滚段与undo页" class="headerlink" title="回滚段与undo页"></a>回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了 1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。 </p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务 限制为 1024 。虽然对绝大多数的应用来说都已经够用。 </p>
<p>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到 了 128*1024 。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show variables like &#x27;innodb_undo_logs&#x27;;</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+------------------+-------+</span><br><span class="hljs-section">| innodb_undo_logs | 128 |</span><br><span class="hljs-section">+------------------+-------+</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210416.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126165928819"></p>
<h4 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h4><p>1、每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。 </p>
<p>2、当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 据会被复制到回滚段。 </p>
<p>3、在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。 </p>
<p>4、回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210417.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170027157"></p>
<p>5、当事务提交时，InnoDB存储引擎会做以下两件事情： </p>
<ul>
<li><p>将undo log放入列表中，以供之后的purge操作 </p>
</li>
<li><p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
</li>
</ul>
<h4 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h4><p>1.未提交的回滚数据(uncommitted undo information) ∶该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p>
<p>2.已经提交但未过期的回滚数据(committed undo information) : 该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</p>
<p>3.事务已经提交并过期的数据(expired undo information)：事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</p>
<p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>
<h3 id="undo的类型"><a href="#undo的类型" class="headerlink" title="undo的类型"></a>undo的类型</h3><p>在InnoDB存储引擎中，undo log分为： </p>
<p>insert undo log </p>
<p>update undo log</p>
<p>insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
<p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h3 id="undo-log的生命周期"><a href="#undo-log的生命周期" class="headerlink" title="undo log的生命周期"></a>undo log的生命周期</h3><h4 id="简要生成过程"><a href="#简要生成过程" class="headerlink" title="简要生成过程"></a>简要生成过程</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210418.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170334099"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210419.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170342843"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210420.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170351424"></p>
<p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p>
<h4 id="详细生成过程"><a href="#详细生成过程" class="headerlink" title="详细生成过程"></a>详细生成过程</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210421.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170435107"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210422.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170446833"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210423.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170457631"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210424.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170506463"></p>
<h4 id="undo-log是如何回滚的"><a href="#undo-log是如何回滚的" class="headerlink" title="undo log是如何回滚的"></a>undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样： </p>
<p>1.通过undo no=3的日志把id=2的数据删除 </p>
<p>2.通过undo no=2的日志把id=1的数据的deletemark还原成0 </p>
<p>3.通过undo no=1的日志把id=1的数据的name还原成Tom </p>
<p>4.通过undo no=0的日志把id=1的数据删除 </p>
<h4 id="undo-log的删除"><a href="#undo-log的删除" class="headerlink" title="undo log的删除"></a>undo log的删除</h4><p><strong>针对于insert undo log</strong> </p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删 除，不需要进行purge操作。 </p>
<p><strong>针对于update undo log</strong> </p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等 待purge线程进行最后的删除。</p>
<p>补充:</p>
<p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清除page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种”假删除”;只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210425.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220126170656837"></p>
<h1 id="十五、锁"><a href="#十五、锁" class="headerlink" title="十五、锁"></a>十五、锁</h1><p>事务的<code> 隔离性</code> 由这章讲述的 <code>锁</code> 来实现。 </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>锁是计算机协调多个进程或线程<code>并发访问莱一资源</code>的机制。在程序开发中会存在<code>多线程同步</code>的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了<code>保证数据的一致性</code>，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。  </p>
<h2 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种： </p>
<h3 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h3><p>读-读 情况，即并发事务相继 <code>读取相同的记录</code> 。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。 </p>
<h3 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。 </p>
<p>在这种情况下<code>会发生 脏写 </code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓 的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示： </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210426.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128085542663"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构 </code>，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210427.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128085549070"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210428.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128085615584"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210429.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128085624956"></p>
<p>小结几种说法： </p>
<p><strong>不加锁</strong> </p>
<p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。 </p>
<p><strong>获取锁成功，或者加锁成功</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。 </p>
<p><strong>获取锁失败，或者加锁失败，或者没有获取到锁</strong> </p>
<p>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 需要等待，不可以继续执行操作。</p>
<h3 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重 复读 、 幻读 的问题。 </p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经 解决了 幻读 问题。 </p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决 <code>脏读</code> 、 <code>不可重复读</code> 、 <code>幻读</code> 这些问题呢？其实有两种可选的解决方案： </p>
<p><strong>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。</strong> </p>
<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到<code>符合条件的记录版本</code>（历史版本由<code>undo日志</code>构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadVview之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写操作并不冲突</code>。</p>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。 </p>
<ul>
<li><p>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就 是避免了脏读现象； </p>
</li>
<li><p>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会 生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读 和幻读的问题。 </p>
</li>
</ul>
<p><strong>方案二：读、写操作都采用 加锁 的方式。</strong> </p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p>
<p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p>
<p><strong>小结对比发现：</strong> </p>
<p>采用 <code>MVCC</code> 方式的话， <code>读-写</code> 操作彼此并不冲突， 性能更高 。 </p>
<p>采用 <code>加锁</code> 方式的话， <code>读-写</code> 操作彼此需要 排队执行 ，影响性能。 </p>
<p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
<h2 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h2><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210430.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128090524948"></p>
<h3 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写 或 写-读 这些情况可能会引起一些问题，需要使用WVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于<code>既要允许读-读情况不受影响</code>，<code>又要使写-写、读-写或写-读情况中的操作相互阻塞</code>，所以MysSQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁(Shared Lock，SLock)和排他锁(Exclusive Lock，XLock),也叫读锁（readlock)和写锁(write lock)。</p>
<p><code>读锁</code> ：也称为<code> 共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。 </p>
<p><code>写锁</code> ：也称为<code> 排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。 </p>
<p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210431.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128090725535"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210432.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128090742089"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210433.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128090753730"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210434.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128090812907"></p>
<h3 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h3><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h4><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 S锁 或者 X锁 的。在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 <code>MDL</code> ）结构来实现的。 </p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 <code>崩溃恢复 </code>过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取 InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写： </p>
<ul>
<li><p>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 </p>
</li>
<li><p>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。 </p>
</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 行锁 ，关于 InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210435.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091028657"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210436.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091036865"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210437.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091053120"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210438.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091104143"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210439.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091119368"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210440.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091133594"></p>
<h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p><strong>意向锁的出现是为了协调行锁和表锁的关系，支持多粒度的表锁。</strong></p>
<p>在没有意向锁的时候，如果事务A对表中的数据加了行锁，此时事务B想要对这个表加页锁，那么事务B就首先需要通过遍历的方式判断这个表中的每一行数据是不是有表锁，当数据量比较大的时候，浪费时间</p>
<p>为了解决此问题，使用了意向锁。如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<p>InnoDB 支持 <code>多粒度锁</code>（multiple granularity locking） ，它<code>允许 行级锁 与 表级锁 共存</code>，而意向 锁就是其中的一种 <code>表锁</code> 。 </p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存。</p>
<p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p>
<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p><strong>意向锁分为两种：</strong> </p>
<p>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br></code></pre></td></tr></table></figure>

<p>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p><strong>1.意向锁要解决的问题</strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p>
<p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<ul>
<li><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</p>
</li>
<li><p>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</p>
</li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210441.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091708393"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210442.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091716562"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210443.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091731490"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210444.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091748452"></p>
<p><strong>意向锁的并发性</strong></p>
<p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 他锁时的并发性。（不然我们直接用普通的表锁就行了） </p>
<p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可 能存在多种不同锁，但是这里我们只着重表现意向锁）。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210445.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128091812208"></p>
<p><strong>从上面的案例可以得到如下结论：</strong> </p>
<p>1.InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。 </p>
<p>2.意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。 </p>
<p>3.IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </p>
<p>4.意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</p>
<h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `teacher` (<br>`id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `teacher` (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>), (<span class="hljs-string">&#x27;lisi&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> lisi <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。 </p>
<p><strong>1.“Simple inserts” （简单插入）</strong> </p>
<p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行 INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。 </p>
<p><strong>2.“Bulk inserts” （批量插入）</strong> </p>
<p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p>
<p><strong>3.“Mixed-mode inserts” （混合模式插入）</strong> </p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混 合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210446.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128092234241"></p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式： </p>
<p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式) </code></p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。 </p>
<p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式) </code></p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。 </p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。 </p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p>
<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式) </code></p>
<p>从 MySQL 8.0 开始，交错锁模式是 默认 设置。 </p>
<p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但 是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能 不是连续的。</p>
<p>如果执行的语句是”simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 </p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</strong></p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210447.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128092444808"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210448.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220128092453945"></p>
<h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2.InnoDB中的行锁"></a>2.InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p>
<p>优点：锁定力度小，发生锁冲突概率低，可以实现的并发度高。</p>
<p>缺点：对于锁的开销比较大，加锁会比较慢容易出现死锁情况。</p>
<p>InnoDB与MyISAM的最大不同有两点:一是支持事务（TRANSACTION);二是采用了行级锁。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210449.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100724739"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210450.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100734982"></p>
<h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210451.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100755360"></p>
<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。 </p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁； </p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。 </p>
</li>
</ul>
<h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h5><p>MySQL 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁</code> 方案解决。</p>
<p>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210452.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100913810"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210453.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100922762"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210454.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214100947538"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210455.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214101004869"></p>
<h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a>③ 临键锁（Next-Key Locks）</h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 <code>间隙插入新记录</code> ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210456.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214101123814"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure>

<h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a>④ 插入意向锁（Insert Intention Locks）</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为:LOCK_INSERT_INTENTION，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间(gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取（4，7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待)。总结来说，插入意向锁的特性可以分成两部分:</p>
<p>(1）插入意向锁是一种特殊的间隙锁—一间隙锁可以锁定开区间内的部分记录。</p>
<p>(2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p>
<p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<code>行锁</code>。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210457.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214101429289"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210458.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214101451957"></p>
<h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h4><p>页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong> </p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h3 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 数据并发的思维方式 。需要注意的是，乐观锁和悲观锁并不是锁，而是<code>锁的 设计思想 </code>。 </p>
<h4 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身 的锁机制来实现，从而保证数据操作的排它性。 </p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上 锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<code>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</code>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当 其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是 悲观锁思想的实现。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210459.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102010016"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210500.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102029742"></p>
<h4 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过 程序来实现。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。 </p>
<h5 id="乐观锁的版本号机制"><a href="#乐观锁的版本号机制" class="headerlink" title="乐观锁的版本号机制"></a>乐观锁的版本号机制</h5><p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更 新或删除操作时，会执行 UPDATE … SET version=version+1 WHERE version=version 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。 </p>
<h5 id="乐观锁的时间戳机制"><a href="#乐观锁的时间戳机制" class="headerlink" title="乐观锁的时间戳机制"></a>乐观锁的时间戳机制</h5><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。 你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210501.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102106002"></p>
<h4 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景： </p>
<ol>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。 </li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。 </li>
</ol>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210502.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102124473"></p>
<h3 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210503.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102149966"></p>
<p>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。 </p>
<p>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210504.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102216873"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210505.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102240974"></p>
<h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210506.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102319698"></p>
<h3 id="其它锁之：全局锁"><a href="#其它锁之：全局锁" class="headerlink" title="其它锁之：全局锁"></a>其它锁之：全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>

<h3 id="其它锁之：死锁"><a href="#其它锁之：死锁" class="headerlink" title="其它锁之：死锁"></a>其它锁之：死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死 锁示例：</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210507.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102454938"></p>
<p>第二种策略的成本分析 </p>
<p>方法1：如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有 一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后 通过业务重试一般就没问题了，这是 业务无损 的。而关掉死锁检测意味着可能会出现大量的超时，这是 业务有损 的。 </p>
<p>方法2：控制并发度。如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测 的成本很低，就不会出现这个问题。 这个并发控制要做在 数据库服务端 。如果你有中间件，可以考虑在 中间件实现 ；甚至有能力修改MySQL 源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队，这样在 InnoDB内部就不会有大量的死锁检测工作了。</p>
<h1 id="十六、多版本并发控制"><a href="#十六、多版本并发控制" class="headerlink" title="十六、多版本并发控制"></a>十六、多版本并发控制</h1><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210508.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214102633787"></p>
<h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><p> MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版 本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保 证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。 </p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到 即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。 </p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞 读；比如这样： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。 </p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 </p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student LOCK <span class="hljs-keyword">IN</span> SHARE MODE; # 共享锁<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; # 排他锁<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">values</span> ... # 排他锁<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> ... # 排他锁<br><span class="hljs-keyword">UPDATE</span> student <span class="hljs-keyword">SET</span> ... # 排他锁<br></code></pre></td></tr></table></figure>

<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题： </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210509.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103021784"></p>
<p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p>
<p>MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210510.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103029537"></p>
<h3 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必 要的隐藏列。</p>
<p>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。 </p>
<p>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210511.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103110105"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210512.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103124895"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210513.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103144338"></p>
<h2 id="MVCC实现原理之ReadView"><a href="#MVCC实现原理之ReadView" class="headerlink" title="MVCC实现原理之ReadView"></a>MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</p>
<h3 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h3><p>在MCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID(“”活跃”指的就是，启动了但还没提交)。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了。 </p>
<p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。 </p>
<p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问 题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210514.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103336220"></p>
<h3 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。 </p>
<p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前 事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p>
<p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p>
<p> 如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判 断一下trx_id属性值是不是在 trx_ids 列表中。 </p>
<ul>
<li><p>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </p>
</li>
<li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p>
</li>
</ul>
<h3 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它： </p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。 在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。 如表所示：</li>
</ol>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210515.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214103536185"></p>
<h1 id="十七、其他数据库日志"><a href="#十七、其他数据库日志" class="headerlink" title="十七、其他数据库日志"></a>十七、其他数据库日志</h1><p>我们在讲解数据库事务时，讲过两种日志:重做日志、回滚日志。</p>
<p>对于线上数据库应用系统，突然遭遇数据库宕机怎么办?在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的sQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p>
<p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。 </p>
<p>MySQL8.0 官网日志地址：“ <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a> ”</p>
<h2 id="MySQL支持的日志"><a href="#MySQL支持的日志" class="headerlink" title="MySQL支持的日志"></a>MySQL支持的日志</h2><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志 和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。 </p>
<p><strong>这6类日志分别为：</strong> </p>
<p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。 </p>
<p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。 </p>
<p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。 </p>
<p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。 </p>
<p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。 </p>
<p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。 </p>
<p>除二进制日志外，其他日志都是 文本文件 。默认情况下，所有日志创建于 MySQL数据目录 中。 </p>
<h3 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h3><p>日志功能会 降低MySQL数据库的性能 。 </p>
<p>日志会 占用大量的磁盘空间 。</p>
<h2 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志(slow query log)"></a>慢查询日志(slow query log)</h2><p>前面章节《第09章_性能分析工具的使用》已经详细讲述。 </p>
<h2 id="通用查询日志-general-query-log"><a href="#通用查询日志-general-query-log" class="headerlink" title="通用查询日志(general query log)"></a>通用查询日志(general query log)</h2><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志， 还原操作时的具体场景，可以帮助我们准确定位问题。</p>
<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p>
<p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p>
<p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点so，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p>
<p>由于网络的原因导致了重复支付。至于解决问题的方案就很多了，这里省略。</p>
<p>可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。</p>
<h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-operator">|</span> general_log <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span> #通用查询日志处于关闭状态<br><span class="hljs-operator">|</span> general_log_file <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu01.log <span class="hljs-operator">|</span> #通用查询日志文件的名称是atguigu01.log<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+------------------------------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>

<p>说明1：系统变量general_log 的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的默认值是关闭的。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。</p>
<p>说明2：通用查询日志文件的名称是atguiguo1.log。存储路径是/var/ib/mysql/，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了。</p>
<h3 id="启动日志"><a href="#启动日志" class="headerlink" title="启动日志"></a>启动日志</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210516.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104404634"></p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>通用查询日志是以 文本文件 的形式存储在文件系统中的，可以使用 文本编辑器 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。 </p>
<p>在Windows操作系统中，使用文本文件查看器； </p>
<p>在Linux系统中，可以使用vi工具或者gedit工具查看； </p>
<p>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。 </p>
<p>从 SHOW VARIABLES LIKE ‘general_log%’; 结果中可以看到通用查询日志的位置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>sbin<span class="hljs-operator">/</span>mysqld, Version: <span class="hljs-number">8.0</span><span class="hljs-number">.26</span> (MySQL Community Server <span class="hljs-operator">-</span> GPL). started <span class="hljs-keyword">with</span>:<br>Tcp port: <span class="hljs-number">3306</span> Unix socket: <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>mysql.sock<br><span class="hljs-type">Time</span> Id Command Argument<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">44</span>:<span class="hljs-number">58.052890</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">15.666672</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;general_log%&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">45</span>:<span class="hljs-number">28.970765</span>Z <span class="hljs-number">10</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.706804</span>Z <span class="hljs-number">11</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@localhost</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> Socket<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">47</span>:<span class="hljs-number">38.707435</span>Z <span class="hljs-number">11</span> Query <span class="hljs-keyword">select</span> @<span class="hljs-variable">@version</span>_comment limit <span class="hljs-number">1</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.384886</span>Z <span class="hljs-number">12</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385253</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.385640</span>Z <span class="hljs-number">12</span> Query USE `atguigu12`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">21.386179</span>Z <span class="hljs-number">12</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.901778</span>Z <span class="hljs-number">13</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.902128</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905179</span>Z <span class="hljs-number">13</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">23.905825</span>Z <span class="hljs-number">13</span> Query <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> TABLES <span class="hljs-keyword">WHERE</span> Table_Type <span class="hljs-operator">!=</span><br><span class="hljs-string">&#x27;VIEW&#x27;</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.163833</span>Z <span class="hljs-number">14</span> <span class="hljs-keyword">Connect</span> root<span class="hljs-variable">@172</span><span class="hljs-number">.16</span><span class="hljs-number">.210</span><span class="hljs-number">.1</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> TCP<span class="hljs-operator">/</span>IP<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164451</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">SET</span> NAMES utf8<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">32.164840</span>Z <span class="hljs-number">14</span> Query USE `atguigu`<br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>T07:<span class="hljs-number">48</span>:<span class="hljs-number">40.006687</span>Z <span class="hljs-number">14</span> Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account<br></code></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什 么 SQL 操作，针对的是哪个数据表等信息。</p>
<h3 id="停止日志"><a href="#停止日志" class="headerlink" title="停止日志"></a>停止日志</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210517.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104540183"></p>
<h4 id="删除-刷新日志"><a href="#删除-刷新日志" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很 长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210518.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104610167"></p>
<h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h2><h3 id="启动日志-1"><a href="#启动日志-1" class="headerlink" title="启动日志"></a>启动日志</h3><p>在MySQL数据库中，错误日志功能是 默认开启 的。而且，错误日志 无法被禁止 。 默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或 hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>error<span class="hljs-operator">=</span>[path<span class="hljs-operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名<br></code></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。 </p>
<h3 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。 查询错误日志的存储路径：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_err%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> log_error <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysqld.log <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_services <span class="hljs-operator">|</span> log_filter_internal; log_sink_internal <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_suppression_list <span class="hljs-operator">|</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_verbosity <span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210519.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104745940"></p>
<h3 id="删除-刷新日志-1"><a href="#删除-刷新日志-1" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 直接删除 。 </p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210520.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104805353"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210521.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104814508"></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">install -omysql -gmysql -m0644 <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> <span class="hljs-regexp">/var/</span>log/mysqld.log<br></code></pre></td></tr></table></figure>

<h3 id="MySQL8-0新特性"><a href="#MySQL8-0新特性" class="headerlink" title="MySQL8.0新特性"></a>MySQL8.0新特性</h3><p>MySQL8.0里对错误日志的改进。MySQL8.o的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。</p>
<p><strong>下面这些是来自社区的意见:</strong></p>
<p>默认情况下内容过于冗长·遗漏了有用的信息</p>
<p>难以过滤某些信息</p>
<p>没有标识错误信息的子系统源</p>
<p>没有错误代码，解析消息需要识别错误。引导消息可能会丢失</p>
<p>固定格式</p>
<p><strong>针对这些意见，MySQL做了如下改变:</strong></p>
<p>采用组件架构，通过不同的组件执行日志的写入和过滤功能。写入错误日志的全部信息都具有唯一的错误代码从10000开始</p>
<p>增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息。增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等</p>
<p>两种过滤方式，Internal和Dragnet</p>
<p>三种写入形式，经典、JSON和syseventlog</p>
<p>小结:</p>
<p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p>
<h2 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较 重要 的日志了，在日常开发及运维过程中，经常会遇到。 binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。 </p>
<p>binlog主要应用场景： </p>
<p>一是用于 数据恢复 </p>
<p>二是用于 数据复制</p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210522.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214104854289"></p>
<h3 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210523.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105109857"></p>
<h3 id="日志参数设置"><a href="#日志参数设置" class="headerlink" title="日志参数设置"></a>日志参数设置</h3><p><strong>方式1：永久性方式</strong> </p>
<p>修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">[mysqld]<br>#启用二进制日志<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>atguigu<span class="hljs-operator">-</span>bin<br>binlog_expire_logs_seconds<span class="hljs-operator">=</span><span class="hljs-number">600</span><br>max_binlog_size<span class="hljs-operator">=</span><span class="hljs-number">100</span>M<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210524.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105507715"></p>
<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_basename <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_index <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>bin.index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events <span class="hljs-operator">|</span> OFF <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+----------------------------------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong> </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">[mysqld]<br>log<span class="hljs-operator">-</span>bin<span class="hljs-operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;<br><br></code></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">chown <span class="hljs-operator">-</span>R <span class="hljs-operator">-</span>v mysql:mysql binlog<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210525.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105548184"></p>
<p><strong>方式2：临时性方式</strong> </p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 会话级别 的设置，没有了global级别的设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">global</span> 级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>ERROR <span class="hljs-number">1228</span> (HY000): Variable <span class="hljs-string">&#x27;sql_log_bin&#x27;</span> <span class="hljs-keyword">is</span> a SESSION variable <span class="hljs-keyword">and</span> can`t be used<br><span class="hljs-keyword">with</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span><br># session级别<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> sql_log_bin<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> 秒)<br></code></pre></td></tr></table></figure>

<h3 id="查看日志-2"><a href="#查看日志-2" class="headerlink" title="查看日志"></a>查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。 </p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就 会创建一个新的日志文件。 </p>
<p>查看当前的二进制日志文件列表及大小。指令如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-type">BINARY</span> LOGS;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> Log_name <span class="hljs-operator">|</span> File_size <span class="hljs-operator">|</span> Encrypted <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-operator">|</span> atguigu<span class="hljs-operator">-</span>bin<span class="hljs-number">.000001</span> <span class="hljs-operator">|</span> <span class="hljs-number">156</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">No</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+-----------+-----------+</span><br><span class="hljs-number">1</span> 行于数据集 (<span class="hljs-number">0.02</span> 秒)<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210526.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105635944"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210527.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105656266"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210528.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105719614"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210529.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105729486"></p>
<h3 id="使用日志恢复数据"><a href="#使用日志恢复数据" class="headerlink" title="使用日志恢复数据"></a>使用日志恢复数据</h3><p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210530.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105832031"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210531.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214105954967"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210532.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110004021"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210533.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110046092"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210534.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110056135"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210535.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110106530"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210536.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110115454"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210537.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110124763"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210538.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110136968"></p>
<p><img   class="lazyload" data-original="https://gnotepng.oss-cn-shanghai.aliyuncs.com/20230226210539.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20220214110147324"></p>
<h3 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 PURGE MASTER LOGS 只删除指定部分的二进制日志文件， RESET MASTER 删除所有的二进制日志文 件。具体如下： </p>
<p>PURGE MASTER LOGS：删除指定日志文件 PURGE MASTER LOGS语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS <span class="hljs-keyword">TO</span> ‘指定日志文件名’<br>PURGE &#123;MASTER <span class="hljs-operator">|</span> <span class="hljs-type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’<br></code></pre></td></tr></table></figure>

<h3 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h3><p>二进制日志可以通过数据库的 全量备份 和二进制日志中保存的 增量信息 ，完成数据库的 无损失恢复 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数 据恢复，是很有挑战性的，因为起止位置不容易管理。 </p>
<p>在这种情况下，一个有效的解决办法是 配置主从数据库服务器 ，甚至是 一主多从 的架构，把二进制日志 文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常 等问题。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>John Doe</li>
    <li><strong>本文链接：</strong><a href="https://kygeng.github.io/kygeng/2022/03/23/%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%9AMySQL%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_%E9%AB%98%E7%BA%A7/index.html" title="https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng&#x2F;2022&#x2F;03&#x2F;23&#x2F;%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%9AMySQL%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_%E9%AB%98%E7%BA%A7&#x2F;index.html">https:&#x2F;&#x2F;kygeng.github.io&#x2F;kygeng&#x2F;2022&#x2F;03&#x2F;23&#x2F;%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%9AMySQL%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_%E9%AB%98%E7%BA%A7&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/kygeng/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/kygeng/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul> 

        
  <nav class="nav">
    <a></a>
    <a href="/kygeng/2022/02/25/%E5%A4%A7%E5%8E%82%E5%AD%A6%E9%99%A2%EF%BC%9AJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E9%AB%98%E7%BA%A7"><span class="toc-text">MySQL高级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Linux%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">一、Linux下的安装与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">常用命令行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%A4%A7%E5%B0%8F%E5%86%99%E8%A7%84%E8%8C%83"><span class="toc-text">SQL大小写规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql-mode%E7%9A%84%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE"><span class="toc-text">sql_mode的合理设置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-text">二、MySQL的数据目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">MySQL8的主要目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E8%87%AA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">MySQL自带的系统数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">表在文件系统中的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">InnoDB存储引擎模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">MyISAM存储引擎模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">视图在文件系统中的表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">其他的文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">三、用户与权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-text">用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-text">创建用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7"><span class="toc-text">修改用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-text">删除用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">设置当前用户密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%85%B6%E5%AE%83%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">修改其它用户密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL8%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86-%E4%BA%86%E8%A7%A3"><span class="toc-text">MySQL8密码管理(了解)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8"><span class="toc-text">权限列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">授予权限的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%9B%9E%E6%9D%83%E9%99%90"><span class="toc-text">收回权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%A1%A8"><span class="toc-text">权限表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#user%E8%A1%A8"><span class="toc-text">user表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#db%E8%A1%A8"><span class="toc-text">db表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tables-priv%E8%A1%A8%E5%92%8Ccolumns-priv%E8%A1%A8"><span class="toc-text">tables_priv表和columns_priv表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#procs-priv%E8%A1%A8"><span class="toc-text">procs_priv表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E4%BA%86%E8%A7%A3"><span class="toc-text">访问控制(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86"><span class="toc-text">角色管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2"><span class="toc-text">创建角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E8%A7%92%E8%89%B2%E8%B5%8B%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-text">给角色赋予权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-text">查看角色的权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-text">回收角色的权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%92%E8%89%B2"><span class="toc-text">删除角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E7%94%A8%E6%88%B7%E8%B5%8B%E4%BA%88%E8%A7%92%E8%89%B2"><span class="toc-text">给用户赋予角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E8%A7%92%E8%89%B2"><span class="toc-text">激活角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">撤销用户的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E8%A7%92%E8%89%B2-mandatory-role"><span class="toc-text">设置强制角色(mandatory role)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-text">四、逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-text">逻辑架构剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E5%B1%82%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-text">第1层：连接层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E5%B1%82%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-text">第2层：服务层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E5%B1%82%EF%BC%9A%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-text">第3层：引擎层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82"><span class="toc-text">存储层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">SQL执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">MySQL中的SQL执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL8%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">MySQL8中SQL执行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL5-7%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">MySQL5.7中SQL执行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E6%B3%95%E9%A1%BA%E5%BA%8F"><span class="toc-text">SQL语法顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E4%B8%AD%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">Oracle中的SQL执行流程(了解)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="toc-text">数据库缓冲池(buffer pool)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0-vs-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">缓冲池 vs 查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">什么时候使用查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">缓冲池如何读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">查看&#x2F;设置缓冲池的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AABuffer-Pool%E5%AE%9E%E4%BE%8B"><span class="toc-text">多个Buffer Pool实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%B3%E9%97%AE%E9%A2%98"><span class="toc-text">引申问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">五、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%85%88%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-text">存储引擎先关配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">设置系统默认的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">设置表的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">修改表的存储引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-text">引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">InnoDB 引擎：具备外键支持功能的事务存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">MyISAM 引擎：主要的非事务处理存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">其他存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">引擎对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB"><span class="toc-text">MyISAM和InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%81%E6%B7%98%E5%AE%9D%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-text">.阿里巴巴、淘宝用哪个</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%A4%96%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="toc-text">课外补充：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81InnoDB%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1、InnoDB表的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81InnoDB%E5%92%8CACID%E6%A8%A1%E5%9E%8B"><span class="toc-text">2、InnoDB和ACID模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81InnoDB%E6%9E%B6%E6%9E%84"><span class="toc-text">3、InnoDB架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-text">六、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">为什么使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">索引及其优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Innode%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">Innode中的索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E9%A1%B5%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B5"><span class="toc-text">目录项记录页的目录页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-text">常见索引概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">InnoDB的B+树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8"><span class="toc-text">根页面位置万年不动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A82%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-text">一个页面最少存储2条记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">MyISAM中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">MyISAM索引的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB%E5%AF%B9%E6%AF%94"><span class="toc-text">MyISAM 与 InnoDB对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-text">MySQL数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">全表遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84"><span class="toc-text">Hash结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%BC%8F%E5%93%88%E5%B8%8C"><span class="toc-text">自适应式哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-text">AVL树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-1"><span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R%E6%A0%91"><span class="toc-text">R树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">附录：算法的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">七、InnoDB数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-text">数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-text">磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0-%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">页结构概述&#x2F;页的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-text">第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-text">第三部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%88%96%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="toc-text">InnoDB行格式（或记录格式）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">八、索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">索引的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL8%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">MySQL8索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">支持降序索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">十三、事务基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">数据库事务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5"><span class="toc-text">存储引擎支持情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="toc-text">事务的ACID特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">事务的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="toc-text">如何使用事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">显式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">隐式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">隐式提交数据的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">使用举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">数据并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">SQL中的四种隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">MySQL支持的四种隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">如何设置事务的隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB"><span class="toc-text">事务的常见分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-text">十四、MySQL事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97"><span class="toc-text">redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81REDO%E6%97%A5%E5%BF%97"><span class="toc-text">为什么需要REDO日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REDO%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">REDO日志的好处、特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">redo的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">redo的整体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-text">redo log的刷盘策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E6%BC%94%E7%A4%BA"><span class="toc-text">不同刷盘策略演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5redo-log-buffer-%E8%BF%87%E7%A8%8B"><span class="toc-text">写入redo log buffer 过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-file"><span class="toc-text">redo log file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redolog%E5%B0%8F%E7%BB%93"><span class="toc-text">redolog小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97"><span class="toc-text">undo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3undo%E6%97%A5%E5%BF%97"><span class="toc-text">如何理解undo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">undo日志的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">undo的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">undo的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">undo log的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E9%94%81"><span class="toc-text">十五、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="toc-text">MySQL并发事务访问相同记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">读-读情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-text">写-写情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">读-写或写-读情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">并发问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-text">锁的不同角度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-text">从数据操作的类型划分：读锁、写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-text">从数据操作的粒度划分：表级锁、页级锁、行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86-%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">从对待锁的态度划分:乐观锁、悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-text">按加锁的方式划分：显式锁、隐式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">其它锁之：全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-text">其它锁之：死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">十六、多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="toc-text">什么是MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">快照读与当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">当前读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0"><span class="toc-text">复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">再谈隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81Undo-Log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-text">隐藏字段、Undo Log版本链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BReadView"><span class="toc-text">MVCC实现原理之ReadView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReadView"><span class="toc-text">什么是ReadView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">ReadView的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">MVCC整体操作流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97"><span class="toc-text">十七、其他数据库日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL支持的日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">日志类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">日志的弊端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-slow-query-log"><span class="toc-text">慢查询日志(slow query log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-general-query-log"><span class="toc-text">通用查询日志(general query log)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-text">问题场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-text">查看当前状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-text">启动日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">查看日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%97%A5%E5%BF%97"><span class="toc-text">停止日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97-error-log"><span class="toc-text">错误日志(error log)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97-1"><span class="toc-text">启动日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97-1"><span class="toc-text">查看日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97-1"><span class="toc-text">删除\刷新日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">MySQL8.0新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97-bin-log"><span class="toc-text">二进制日志(bin log)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="toc-text">查看默认情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">日志参数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97-2"><span class="toc-text">查看日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">使用日志恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-text">删除二进制日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%9C%BA%E6%99%AF"><span class="toc-text">其它场景</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/kygeng/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/kygeng/js/utils.js"></script>
<script src="/kygeng/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>